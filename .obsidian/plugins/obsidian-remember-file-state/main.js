/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => RememberFileStatePlugin
});
var import_obsidian2 = __toModule(require("obsidian"));
var import_state = __toModule(require("@codemirror/state"));

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  rememberMaxFiles: 20
};
var RememberFileStatePluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Remember files").setDesc("How many files to remember at most").addText((text) => {
      var _a;
      return text.setValue((_a = this.plugin.settings.rememberMaxFiles) == null ? void 0 : _a.toString()).onChange((value) => __async(this, null, function* () {
        const intValue = parseInt(value);
        if (!isNaN(intValue)) {
          this.plugin.settings.rememberMaxFiles = intValue;
          yield this.plugin.saveSettings();
        }
      }));
    });
  }
};

// src/main.ts
var DEFAULT_DATA = {
  rememberedFiles: {}
};
var WarningModal = class extends import_obsidian2.Modal {
  constructor(app2, title, message) {
    super(app2);
    this.title = "";
    this.message = "";
    this.title = title;
    this.message = message;
  }
  onOpen() {
    this.contentEl.createEl("h2", { text: this.title });
    this.contentEl.createEl("p", { text: this.message });
  }
};
var RememberFileStatePlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this._suppressNextFileOpen = false;
    this._nextUniqueViewId = 0;
    this._lastOpenFiles = {};
    this._viewUninstallers = {};
    this._globalUninstallers = [];
    this.registerOnUnloadFile = function(view) {
      var filePath = view.file.path;
      var viewId = this.getUniqueViewId(view, true);
      if (viewId in this._viewUninstallers) {
        return;
      }
      console.debug(`Registering callback on view ${viewId}`, filePath);
      const _this = this;
      var uninstall = around(view, {
        onUnloadFile: function(next) {
          return function(unloaded) {
            return __async(this, null, function* () {
              _this.rememberFileState(unloaded, this);
              return yield next.call(this, unloaded);
            });
          };
        }
      });
      this._viewUninstallers[viewId] = uninstall;
      view.register(() => {
        var plugin = app.plugins.getPlugin("obsidian-remember-file-state");
        if (plugin) {
          console.debug(`Unregistering view ${viewId} callback`, filePath);
          delete plugin._viewUninstallers[viewId];
          delete plugin._lastOpenFiles[viewId];
          uninstall();
        } else {
          console.debug("Plugin obsidian-remember-file-state has been unloaded, ignoring unregister");
        }
      });
    };
    this.onFileOpen = (openedFile) => __async(this, null, function* () {
      if (openedFile) {
        var activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
        if (activeView) {
          this.registerOnUnloadFile(activeView);
          var isRealFileOpen = true;
          const viewId = this.getUniqueViewId(activeView);
          if (viewId != void 0) {
            const lastOpenFileInView = this._lastOpenFiles[viewId];
            isRealFileOpen = lastOpenFileInView != openedFile.path;
            this._lastOpenFiles[viewId] = openedFile.path;
          }
          if (!this._suppressNextFileOpen && !this.isFileMultiplyOpen(openedFile) && isRealFileOpen) {
            try {
              this.restoreFileState(openedFile, activeView);
            } catch (err) {
              console.error("Couldn't restore file state: ", err);
            }
          }
        }
        this._suppressNextFileOpen = false;
      }
    });
    this.rememberFileState = (file, view) => __async(this, null, function* () {
      const scrollInfo = view.editor.getScrollInfo();
      const cm6editor = view.editor;
      const stateSelection = cm6editor.cm.state.selection;
      if (stateSelection == void 0) {
        return;
      }
      const stateSelectionJSON = stateSelection.toJSON();
      const stateData = { "scrollInfo": scrollInfo, "selection": stateSelectionJSON };
      var existingFile = this.data.rememberedFiles[file.path];
      if (existingFile) {
        existingFile.lastSavedTime = Date.now();
        existingFile.stateData = stateData;
      } else {
        let newFileState = {
          path: file.path,
          lastSavedTime: Date.now(),
          stateData
        };
        this.data.rememberedFiles[file.path] = newFileState;
        this.forgetExcessFiles();
      }
      console.debug("Remember file state for:", file.path);
    });
    this.restoreFileState = function(file, view) {
      const existingFile = this.data.rememberedFiles[file.path];
      if (existingFile) {
        console.debug("Restoring file state for:", file.path);
        const stateData = existingFile.stateData;
        view.editor.scrollTo(stateData.scrollInfo.left, stateData.scrollInfo.top);
        const cm6editor = view.editor;
        var transaction = cm6editor.cm.state.update({
          selection: import_state.EditorSelection.fromJSON(stateData.selection)
        });
        cm6editor.cm.dispatch(transaction);
      }
    };
    this.isFileMultiplyOpen = function(file) {
      var numFound = 0;
      this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
        const filePath = leaf.view.file.path;
        if (filePath == file.path) {
          ++numFound;
        }
      });
      return numFound >= 2;
    };
    this.forgetExcessFiles = function() {
      const keepMax = this.settings.rememberMaxFiles;
      if (keepMax <= 0) {
        return;
      }
      var filesData = Object.values(this.data.rememberedFiles);
      filesData.sort((a, b) => {
        if (a.lastSavedTime > b.lastSavedTime)
          return -1;
        if (a.lastSavedTime < b.lastSavedTime)
          return 1;
        return 0;
      });
      for (var i = keepMax; i < filesData.length; ++i) {
        var fileData = filesData[i];
        delete this.data.rememberedFiles[fileData.path];
      }
    };
    this.getUniqueViewId = function(view, autocreateId = false) {
      if (view.__uniqueId == void 0) {
        if (!autocreateId) {
          return -1;
        }
        view.__uniqueId = this._nextUniqueViewId++;
        return view.__uniqueId;
      }
      return view.__uniqueId;
    };
    this.clearUniqueViewId = function(view) {
      delete view["__uniqueId"];
    };
    this.onFileRename = (file, oldPath) => __async(this, null, function* () {
      const existingFile = this.data.rememberedFiles[oldPath];
      if (existingFile) {
        existingFile.path = file.path;
        delete this.data.rememberedFiles[oldPath];
        this.data.rememberedFiles[file.path] = existingFile;
      }
    });
    this.onFileDelete = (file) => __async(this, null, function* () {
      delete this.data.rememberedFiles[file.path];
    });
  }
  onload() {
    return __async(this, null, function* () {
      console.log("Loading RememberFileState plugin");
      yield this.loadSettings();
      this.data = Object.assign({}, DEFAULT_DATA);
      this.registerEvent(this.app.workspace.on("file-open", this.onFileOpen));
      this.registerEvent(this.app.vault.on("rename", this.onFileRename));
      this.registerEvent(this.app.vault.on("delete", this.onFileDelete));
      this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
        this.registerOnUnloadFile(leaf.view);
      });
      const _this = this;
      var uninstall = around(this.app.workspace, {
        openLinkText: function(next) {
          return function(linktext, sourcePath, newLeaf, openViewState) {
            return __async(this, null, function* () {
              _this._suppressNextFileOpen = true;
              return yield next.call(this, linktext, sourcePath, newLeaf, openViewState);
            });
          };
        }
      });
      this._globalUninstallers.push(uninstall);
      this.addSettingTab(new RememberFileStatePluginSettingTab(this.app, this));
      if (this.app.vault.getConfig("legacyEditor") !== false) {
        new WarningModal(this.app, "Legacy Editor Not Supported", "The 'Remember File State' plugin works only with the new editor. Please turn off 'Legacy Editor' in the options.").open();
      }
    });
  }
  onunload() {
    var numViews = 0;
    this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
      const filePath = leaf.view.file.path;
      const viewId = this.getUniqueViewId(leaf.view);
      if (viewId != void 0) {
        var uninstaller = this._viewUninstallers[viewId];
        if (uninstaller) {
          console.debug(`Uninstalling hooks for view ${viewId}`, filePath);
          uninstaller(leaf.view);
          ++numViews;
        } else {
          console.debug("Found markdown view without an uninstaller!", filePath);
        }
        this.clearUniqueViewId(leaf.view);
      } else {
        console.debug("Found markdown view without an ID!", filePath);
      }
    });
    console.debug(`Unregistered ${numViews} view callbacks`);
    this._viewUninstallers = {};
    this._lastOpenFiles = {};
    this._globalUninstallers.forEach((cb) => cb());
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
