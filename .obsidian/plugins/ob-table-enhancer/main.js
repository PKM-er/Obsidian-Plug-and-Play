/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableEnhancer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/table-editor.ts
var import_obsidian = require("obsidian");

// src/editor-utils.ts
var hashCode = function(input, seed = 0) {
  let h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (let i = 0, ch; i < input.length; i++) {
    ch = input.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
var getLineStartPos = (line) => ({
  line,
  ch: 0
});
var getLineEndPos = (line, editor) => ({
  line,
  ch: editor.getLine(line).length
});
var deleteLines = (editor, from, to) => {
  if (to === editor.lastLine() + 1) {
    replaceRangeWithoutScroll(editor, "", getLineEndPos(from - 1, editor), getLineEndPos(to, editor));
  } else {
    replaceRangeWithoutScroll(editor, "", getLineStartPos(from), getLineStartPos(to));
  }
};
var deleteLine = (editor, line) => {
  deleteLines(editor, line, line + 1);
};
var getLeadingWhitespace = (lineContent) => {
  const indentation = lineContent.match(/^\s+/);
  return indentation ? indentation[0] : "";
};
var insertLineBelow = (editor, line) => {
  const endOfCurrentLine = getLineEndPos(line, editor);
  const indentation = getLeadingWhitespace(editor.getLine(line));
  replaceRangeWithoutScroll(editor, "\n" + indentation, endOfCurrentLine);
  return { anchor: { line: line + 1, ch: indentation.length } };
};
var insertLineBelowWithText = (editor, line, text) => {
  const endOfCurrentLine = getLineEndPos(line, editor);
  const indentation = getLeadingWhitespace(editor.getLine(line));
  const textToInsert = text.split(/\r?\n/).map((s) => indentation + s).join("\n");
  replaceRangeWithoutScroll(editor, "\n" + textToInsert, endOfCurrentLine);
  return { anchor: { line: line + 1, ch: indentation.length } };
};
var inReadingView = () => {
  if (activeDocument) {
    const el = activeDocument.querySelector(".markdown-reading-view");
    if (el instanceof HTMLElement)
      return el.style.display != "none";
  }
  return false;
};
function zf(e, t2) {
  if (t2.line < 0)
    return 0;
  const n = t2.line + 1;
  if (n > e.lines)
    return e.length;
  const i = e.line(n);
  return isFinite(t2.ch) ? t2.ch < 0 ? i.from + Math.max(0, i.length + t2.ch) : i.from + t2.ch : i.to;
}
var replaceRangeWithoutScroll = (editor, replacement, from, to) => {
  const cm = editor.cm;
  const state = cm.state.doc;
  const from2 = zf(state, from);
  const to2 = to ? zf(state, to) : from2;
  cm.dispatch({
    changes: {
      from: from2,
      to: to2,
      insert: replacement
    },
    scrollIntoView: false
  });
};
var setLineWithoutScroll = (editor, n, text) => {
  const cm = editor.cm;
  const state = cm.state.doc;
  const from = zf(state, { line: n, ch: 0 });
  const to = zf(state, { line: n, ch: editor.getLine(n).length });
  cm.dispatch({
    changes: {
      from,
      to,
      insert: text
    },
    scrollIntoView: false
  });
};

// src/table-editor.ts
var TableEditor = class {
  constructor(plugin) {
    this.app = plugin.app;
    this.isDirty = true;
    this.app.vault.on("modify", (modifiedFile) => {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile && activeFile.path == modifiedFile.path) {
        this.isDirty = true;
      }
    });
  }
  getTableIds() {
    return [...this.tables.keys()];
  }
  async parseActiveFile() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView)
      await markdownView.save();
    if (!this.isDirty)
      return;
    this.activeFile = this.app.workspace.getActiveFile();
    if (!this.activeFile)
      return;
    this.tables = /* @__PURE__ */ new Map();
    const fullText = await this.app.vault.read(this.activeFile);
    this.rows = fullText.split(/\r?\n/);
    const formatRowRegex = /^\s*(\|)?(?:\s*:?\s*?-+\s*:?\s*\|){2,}/;
    const len = this.rows.length;
    let existNonStandardTable = false;
    let i = 0;
    if (this.rows[0].startsWith("---")) {
      while (++i < len) {
        if (this.rows[i].startsWith("---"))
          break;
      }
    }
    while (++i < len) {
      const row2 = this.rows[i];
      if (row2.trim() == "")
        continue;
      if (row2.startsWith("---"))
        continue;
      if (row2.startsWith("```")) {
        while (++i < len) {
          if (this.rows[i].startsWith("```"))
            break;
        }
      }
      const matchResult = row2.match(formatRowRegex);
      if (matchResult) {
        if (i - 1 < 0)
          continue;
        if (!matchResult[1]) {
          existNonStandardTable = true;
          await this.standardize(i);
          i = i - 1;
          continue;
        }
        const table2 = {
          fromRowIndex: i - 1,
          toRowIndex: i,
          formatRow: this.rows[i].split("|").slice(1, -1),
          cells: []
        };
        const rowAbove = this.rows[i - 1];
        table2.cells.push(rowAbove.split("|").slice(1, -1));
        while (++i < len) {
          const bodyRow = this.rows[i];
          if (bodyRow.trimStart().startsWith("|"))
            table2.cells.push(bodyRow.split("|").slice(1, -1));
          else
            break;
        }
        table2.toRowIndex = i;
        const tableId2 = TableEditor.getIdentifier(table2);
        if (this.tables.get(tableId2))
          continue;
        this.tables.set(tableId2, table2);
      }
    }
    if (existNonStandardTable) {
      const fullTextAfterStandardize = this.rows.join("\n");
      await this.app.vault.modify(this.activeFile, fullTextAfterStandardize);
    }
    this.isDirty = false;
  }
  async standardize(formatRowIndex) {
    this.rows[formatRowIndex - 1] = ["|", this.rows[formatRowIndex - 1], "|"].join("");
    this.rows[formatRowIndex] = ["|", this.rows[formatRowIndex], "|"].join("");
    let i = formatRowIndex;
    const len = this.rows.length;
    while (++i < len) {
      const bodyRow = this.rows[i];
      if (bodyRow.match(/^\s*[^|]*\|/)) {
        this.rows[i] = ["|", this.rows[i], "|"].join("");
      } else
        break;
    }
  }
  getCell(tableId2, rowIndex, colIndex) {
    try {
      return this.tables.get(tableId2).cells[rowIndex][colIndex];
    } catch (e) {
      return " ";
    }
  }
  getLineNumber(table2, rowIndex) {
    return table2.fromRowIndex + (rowIndex == 0 ? rowIndex : rowIndex + 1);
  }
  async update(tableId2, rowIndex, colIndex, newContent) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    table2.cells[rowIndex][colIndex] = newContent;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const rowLineNumber = this.getLineNumber(table2, rowIndex);
      const newLine = TableEditor.rowCells2rowString(table2.cells[rowIndex]);
      if (editor.getLine(rowLineNumber).length == newLine.length)
        setLineWithoutScroll(editor, rowLineNumber, newLine + " ");
      else
        setLineWithoutScroll(editor, rowLineNumber, newLine);
      await markdownView.save();
    }
  }
  async changeColWidth(tableId2, colIndex, delta) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    if (delta == -1)
      table2.cells[0][colIndex] = table2.cells[0][colIndex].replace(/ $/, "");
    else
      table2.cells[0][colIndex] = [table2.cells[0][colIndex], " "].join("");
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const rowLineNumber = this.getLineNumber(table2, 0);
      const newLine = TableEditor.rowCells2rowString(table2.cells[0]);
      if (editor.getLine(rowLineNumber).length == newLine.length)
        setLineWithoutScroll(editor, rowLineNumber, newLine + " ");
      else
        setLineWithoutScroll(editor, rowLineNumber, newLine);
      await markdownView.save();
    }
  }
  async deleteRow(tableId2, rowIndex) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (rowIndex == 0) {
      return;
    }
    const rowLineNumber = this.getLineNumber(table2, rowIndex);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      deleteLine(editor, rowLineNumber);
      await markdownView.save();
    }
  }
  async deleteCol(tableId2, colIndex) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    table2.formatRow.splice(colIndex, 1);
    for (const row2 of table2.cells)
      row2.splice(colIndex, 1);
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      if (table2.formatRow.length == 1) {
        deleteLines(editor, table2.fromRowIndex, table2.toRowIndex);
      } else {
        setLineWithoutScroll(editor, table2.fromRowIndex + 1, TableEditor.rowCells2rowString(table2.formatRow));
        for (let i = 0; i < table2.cells.length; i++) {
          const lineNumber = this.getLineNumber(table2, i);
          setLineWithoutScroll(editor, lineNumber, TableEditor.rowCells2rowString(table2.cells[i]));
        }
      }
      await markdownView.save();
    }
  }
  async insertColRight(tableId2, colIndex) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    table2.formatRow.splice(colIndex + 1, 0, "---");
    for (const row2 of table2.cells)
      row2.splice(colIndex + 1, 0, "   ");
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      setLineWithoutScroll(editor, table2.fromRowIndex + 1, TableEditor.rowCells2rowString(table2.formatRow));
      for (let i = 0; i < table2.cells.length; i++) {
        const lineNumber = this.getLineNumber(table2, i);
        setLineWithoutScroll(editor, lineNumber, TableEditor.rowCells2rowString(table2.cells[i]));
      }
      await markdownView.save();
    }
  }
  async insertRowBelow(tableId2, rowIndex) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const row2 = [];
      let i = table2.formatRow.length;
      while (i--) {
        row2.push("  ");
      }
      const rowText = TableEditor.rowCells2rowString(row2);
      const rowLineNumber = table2.fromRowIndex + rowIndex + 1;
      insertLineBelow(editor, rowLineNumber);
      setLineWithoutScroll(editor, rowLineNumber + 1, rowText);
      await markdownView.save();
    }
  }
  async setColAligned(tableId2, colIndex, aligned) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      table2.formatRow[colIndex] = aligned == "left" ? ":----" : aligned == "right" ? "----:" : ":---:";
      setLineWithoutScroll(editor, table2.fromRowIndex + 1, TableEditor.rowCells2rowString(table2.formatRow));
      await markdownView.save();
    }
  }
  async createMinimalNewTable() {
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      const rowIndex = editor.getCursor().line;
      if (this.tables)
        for (const table2 of this.tables.values()) {
          if (table2.fromRowIndex <= rowIndex && rowIndex <= table2.toRowIndex) {
            new import_obsidian.Notice("Can't create table within another table.");
            return;
          }
        }
      const text = "| Col 1 | Col 2 |\n|---|---|\n| xxxx | xxxx |\n";
      insertLineBelowWithText(editor, rowIndex, text);
      await markdownView.save();
      const firstCell = activeDocument.querySelector("#\u2C9C00");
      if (firstCell instanceof HTMLTableCellElement) {
        firstCell.click();
      }
    }
  }
  async swapCols(tableId2, colIndex1, colIndex2) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    const colNum = table2.cells[0].length;
    if (colIndex1 < 0 || colIndex2 < 0 || colIndex1 >= colNum || colIndex2 >= colNum) {
      new import_obsidian.Notice("Move out of range");
      return;
    }
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      [table2.formatRow[colIndex1], table2.formatRow[colIndex2]] = [table2.formatRow[colIndex2], table2.formatRow[colIndex1]];
      setLineWithoutScroll(editor, table2.fromRowIndex + 1, TableEditor.rowCells2rowString(table2.formatRow));
      for (let i = 0; i < table2.cells.length; i++) {
        const lineNumber = this.getLineNumber(table2, i);
        [table2.cells[i][colIndex1], table2.cells[i][colIndex2]] = [table2.cells[i][colIndex2], table2.cells[i][colIndex1]];
        setLineWithoutScroll(editor, lineNumber, TableEditor.rowCells2rowString(table2.cells[i]));
      }
      await markdownView.save();
    }
  }
  async deleteEntireTable(tableId2) {
    const table2 = this.tables.get(tableId2);
    if (!table2)
      return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (markdownView instanceof import_obsidian.MarkdownView) {
      const editor = markdownView.editor;
      replaceRangeWithoutScroll(editor, "", { line: table2.fromRowIndex, ch: 0 }, { line: table2.toRowIndex, ch: 0 });
      await markdownView.save();
    }
  }
  static getIdentifier(table2) {
    const result = [];
    const rowNum = table2.cells.length;
    for (let i2 = 0; i2 < rowNum; i2++) {
      const str2 = table2.cells[i2][0];
      if (str2 && !str2.match(/[!<>*#\[\]`$=]/))
        result.push(str2.replace(/[\r\n\t\f\v \u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\ufeff]/g, ""));
    }
    let i = table2.cells[0].length;
    while (i--) {
      const str2 = table2.cells[0][i];
      if (str2 && !str2.match(/[!<>*#\[\]`$=]/))
        result.push(str2.replace(/[\r\n\t\f\v \u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\ufeff]/g, ""));
    }
    let resultStr = result.join("");
    if (resultStr.length == 0)
      return "\u7A7A\u8868";
    resultStr += table2.cells.length.toString();
    resultStr += table2.cells[0].length.toString();
    return String.fromCharCode(hashCode(resultStr));
  }
  static rowCells2rowString(cells) {
    const result = ["|"];
    for (const cell of cells) {
      result.push(cell.length == 0 ? "  " : cell);
      result.push("|");
    }
    return result.join("");
  }
};

// src/html-utils.ts
function getCaretPosition(editableElem) {
  let caretPos = 0, sel, range;
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range = sel.getRangeAt(0);
    if (range.commonAncestorContainer.parentNode == editableElem) {
      caretPos = range.endOffset;
    }
  }
  return caretPos;
}
function setCaretPosition(editableElem, newPos) {
  let caretPos = 0, sel, range = activeDocument.createRange();
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range.setStart(editableElem.childNodes[0], newPos);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }
  return caretPos;
}
function getCaretRect(container) {
  let caretPos = 0, sel, range;
  sel = activeWindow.getSelection();
  if (sel && sel.rangeCount) {
    range = sel.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    return rect;
  }
  return null;
}

// src/table-utils.ts
function isSameCell(c1, c2) {
  if (!c1 || !c2)
    return false;
  return c1.tableId == c2.tableId && c1.rowIndex == c2.rowIndex && c1.colIndex == c2.colIndex;
}

// src/reference-suggest.ts
var import_obsidian2 = require("obsidian");
var SuggestionPopper = class {
  constructor(plugin) {
    this.onTrigger = (queryPattern) => {
      if (!this.candidates)
        this.onUpdateCandidates();
      this.isTriggered = true;
      activeDocument.body.appendChild(this.containerEl);
      this.suggestionEl.innerHTML = "";
      const fuzzySearchFunc = (0, import_obsidian2.prepareFuzzySearch)(queryPattern);
      this.fuzzySuggestions = this.candidates.map((c2, i) => {
        const queryString = this.getQueryString(c2);
        const searchResult = fuzzySearchFunc.call(null, queryString);
        return searchResult ? {
          display: this.getDisplay(c2, queryString, searchResult),
          replaceString: this.getReplaceString(c2),
          matched: searchResult.matched,
          score: searchResult.score
        } : null;
      }).filter((o) => o != null).sort((e1, e2) => e2.score - e1.score);
      const caretRect = getCaretRect(this.containerEl);
      const outerRect = this.outerEl.getBoundingClientRect();
      this.containerEl.style.left = `${caretRect.left}px`;
      this.containerEl.style.top = `${caretRect.top + outerRect.height}px`;
      this.containerEl.style.display = "block";
      this.fuzzySuggestions.map((suggestion, i) => {
        this.suggestionEl.createDiv({ cls: "suggestion-item mod-complex" }, (div) => {
          div.innerHTML = suggestion.display;
          div.onmouseover = (e) => this.select(i);
          div.onclick = (e) => this.applySuggestion();
        });
      });
      this.selectedIndex = -1;
    };
    this.selectNext = () => {
      var _a;
      const len = this.suggestionEl.children.length;
      (_a = this.suggestionEl.children[this.selectedIndex]) == null ? void 0 : _a.classList.remove("is-selected");
      if (this.selectedIndex >= len - 1)
        this.selectedIndex = 0;
      else
        this.selectedIndex++;
      const selectedElem = this.suggestionEl.children[this.selectedIndex];
      selectedElem.classList.add("is-selected");
      selectedElem.scrollIntoView(false);
    };
    this.selectPrev = () => {
      var _a;
      const len = this.suggestionEl.children.length;
      (_a = this.suggestionEl.children[this.selectedIndex]) == null ? void 0 : _a.classList.remove("is-selected");
      if (this.selectedIndex <= 0)
        this.selectedIndex = len - 1;
      else
        this.selectedIndex--;
      const selectedElem = this.suggestionEl.children[this.selectedIndex];
      selectedElem.classList.add("is-selected");
      selectedElem.scrollIntoView(false);
    };
    this.select = (selectIndex) => {
      var _a;
      (_a = this.suggestionEl.children[this.selectedIndex]) == null ? void 0 : _a.classList.remove("is-selected");
      this.selectedIndex = selectIndex;
      const selectedElem = this.suggestionEl.children[this.selectedIndex];
      selectedElem.classList.add("is-selected");
      selectedElem.scrollIntoView(false);
    };
    this.applySuggestion = () => {
      const selectSuggestion = this.fuzzySuggestions[this.selectedIndex];
      const caretPosition = getCaretPosition(this.outerEl);
      const beg2caret = this.outerEl.innerText.slice(0, caretPosition);
      const caret2end = this.outerEl.innerText.slice(caretPosition + 1);
      const afterApply = beg2caret.replace(/\[\[([^\[\]]*)$/, selectSuggestion.replaceString);
      this.outerEl.innerHTML = [afterApply, caret2end].join("");
      setCaretPosition(this.outerEl, afterApply.length);
      this.disable();
      return;
    };
    this.plugin = plugin;
    this.app = plugin.app;
    this.containerEl = createDiv({ cls: "ob-table-enhancer suggestion-container" });
    this.suggestionEl = this.containerEl.createDiv({ cls: "ob-table-enhancer suggestion" });
  }
  disable() {
    if (this.isTriggered) {
      this.isTriggered = false;
      this.containerEl.detach();
    }
  }
  bindOuterEl(outerEl) {
    this.outerEl = outerEl;
    this.trigger();
    this.plugin.registerDomEvent(this.outerEl, "keydown", (e) => {
      if (this.isTriggered) {
        if (e.key == "ArrowUp") {
          e.preventDefault();
          e.stopPropagation();
          this.selectPrev();
          return;
        }
        if (e.key == "ArrowDown") {
          e.preventDefault();
          e.stopPropagation();
          this.selectNext();
          return;
        }
        if (e.key == "Enter") {
          e.preventDefault();
          e.stopPropagation();
          this.applySuggestion();
          return;
        }
      }
    });
  }
};
var ReferenceSuggestionPopper = class extends SuggestionPopper {
  getDisplay(item, queryString, searchResult) {
    let i = 0;
    const result = [];
    result.push('<div class="suggestion-content">');
    result.push('<div class="suggestion-title">');
    for (const [j1, j2] of searchResult.matches) {
      result.push("<span>");
      result.push(queryString.slice(i, j1));
      result.push("</span>");
      result.push('<span class="suggestion-highlight">');
      result.push(queryString.slice(j1, j2));
      result.push("</span>");
      i = j2;
    }
    result.push("<span>");
    result.push(queryString.slice(i));
    result.push("</span>");
    result.push("</div>");
    if (item.parent.path != "") {
      result.push('<div class="suggestion-note">');
      result.push(item.parent.path);
      result.push("</div>");
    }
    result.push('<i class="fas fa-align-left"></i>');
    result.push("</div>");
    return result.join("");
  }
  getQueryString(item) {
    return item.basename;
  }
  getReplaceString(item) {
    const activeFile = this.app.workspace.getActiveFile();
    return this.app.fileManager.generateMarkdownLink(item, activeFile.path);
  }
  trigger() {
    this.plugin.registerDomEvent(this.outerEl, "input", (e) => {
      const caretPosition = getCaretPosition(this.outerEl);
      const text = this.outerEl.innerText.slice(0, caretPosition);
      const matchResult = text.match(/\[\[([^\[\]]*)$/);
      if (matchResult) {
        this.onTrigger(matchResult[1]);
      } else {
        this.containerEl.style.display = "none";
      }
    });
  }
  updateCandidates() {
    this.app.metadataCache.on("resolved", () => {
      this.onUpdateCandidates();
    });
  }
  onUpdateCandidates() {
    this.candidates = this.app.vault.getMarkdownFiles();
  }
  onUnload() {
    this.containerEl.remove();
  }
};

// src/tool-bar.ts
var import_obsidian3 = require("obsidian");
var insertBelowIcon = `
<svg
	t="1661842034318"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="5688"
	width="16"
	height="16"
>
	<path
		d="M904 768H120c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8zM878.7 160H145.3c-18.4 0-33.3 14.3-33.3 32v464c0 17.7 14.9 32 33.3 32h733.3c18.4 0 33.3-14.3 33.3-32V192c0.1-17.7-14.8-32-33.2-32zM360 616H184V456h176v160z m0-224H184V232h176v160z m240 224H424V456h176v160z m0-224H424V232h176v160z m240 224H664V456h176v160z m0-224H664V232h176v160z" 
		p-id="5689"
		fill="currentColor"
	    stroke="currentColor"
	></path>
</svg>`;
var deleteIcon = `
<svg
	t="1661781161180"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="3242"
	width="16"
	height="16"
>
	<path
		d="M512 471.744l207.424-207.36a28.416 28.416 0 1 1 40.256 40.192L552.256 512l207.36 207.424a28.416 28.416 0 1 1-40.192 40.256L512 552.256l-207.424 207.36a28.416 28.416 0 1 1-40.256-40.192L471.744 512l-207.36-207.424a28.416 28.416 0 0 1 40.192-40.256L512 471.744z"
		p-id="3243"
		fill="currentColor"
	    stroke="currentColor"
	>
	</path>
</svg>`;
var insertRightIcon = `
<svg
	t="1661842059940"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="5924"
	width="16"
	height="16"
>
	<path
		d="M856 112h-80c-4.4 0-8 3.6-8 8v784c0 4.4 3.6 8 8 8h80c4.4 0 8-3.6 8-8V120c0-4.4-3.6-8-8-8zM656 112H192c-17.7 0-32 14.9-32 33.3v733.3c0 18.4 14.3 33.3 32 33.3h464c17.7 0 32-14.9 32-33.3V145.3c0-18.4-14.3-33.3-32-33.3zM392 840H232V664h160v176z m0-240H232V424h160v176z m0-240H232V184h160v176z m224 480H456V664h160v176z m0-240H456V424h160v176z m0-240H456V184h160v176z" 
		p-id="5925"
		fill="currentColor"
	    stroke="currentColor"
	></path>
</svg>`;
var centerAlignedIcon = `
<svg 
	t="1661840940089"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="1722"
	width="16"
	height="16"
>
	<path
	d="M170.666667 224h682.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM298.666667 394.666667h426.666666a32 32 0 1 1 0 64H298.666667a32 32 0 1 1 0-64zM170.666667 565.333333h682.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM298.666667 736h426.666666a32 32 0 1 1 0 64H298.666667a32 32 0 1 1 0-64z"
	fill="currentColor"
    stroke="currentColor"
	p-id="1723"
	>
	</path>
</svg>`;
var leftAlignedIcon = `
<svg 
	t="1661841114814"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="4223" width="16" height="16"
>
	<path
		d="M170.666667 224h682.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM170.666667 394.666667h426.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM170.666667 565.333333h682.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM170.666667 736h426.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64z"
		fill="currentColor"
    	stroke="currentColor"
		p-id="4224"
	></path>
</svg>
`;
var rightAlignedIcon = `
<svg
	t="1661841218626"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="4438"
	width="16"
	height="16"
>
	<path
		d="M170.666667 224h682.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM426.666667 394.666667h426.666666a32 32 0 1 1 0 64H426.666667a32 32 0 1 1 0-64zM170.666667 565.333333h682.666666a32 32 0 1 1 0 64H170.666667a32 32 0 1 1 0-64zM426.666667 736h426.666666a32 32 0 1 1 0 64H426.666667a32 32 0 1 1 0-64z"
		fill="currentColor"
    	stroke="currentColor"
		p-id="4439"
	></path>
</svg>
`;
var moveRightIcon = `
<svg
	t="1662187765148"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="9678"
	width="16"
	height="16"
>
	<path
		d="M593.450667 512.128L360.064 278.613333l45.290667-45.226666 278.613333 278.762666L405.333333 790.613333l-45.226666-45.269333z" 
		p-id="9679"
		fill="currentColor"
    	stroke="currentColor"
	></path>
</svg>`;
var moveLeftIcon = `
<svg
	t="1662188090144"
	class="icon"
	viewBox="0 0 1024 1024"
	version="1.1"
	xmlns="http://www.w3.org/2000/svg"
	p-id="6067"
	width="16"
	height="16"
>
	<path
		d="M641.28 278.613333l-45.226667-45.226666-278.634666 278.762666 278.613333 278.485334 45.248-45.269334-233.365333-233.237333z"
		p-id="6068"
		fill="currentColor"
    	stroke="currentColor"
	></path>
</svg>`;
var ToolBar = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.tableEditor = plugin.tableEditor;
    this.activeOpBars = [];
    this.rowOpBarEl = createDiv({
      cls: "ob-table-enhancer-row-bar"
    });
    this.colOpBarEl = createDiv({
      cls: "ob-table-enhancer-col-bar"
    });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = insertBelowIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.insertRowBelow(this.fromCell.tableId, this.fromCell.rowIndex);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = moveLeftIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.swapCols(this.fromCell.tableId, this.fromCell.colIndex, this.fromCell.colIndex - 1);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = insertRightIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.insertColRight(this.fromCell.tableId, this.fromCell.colIndex);
      };
    });
    this.rowOpBarEl.createDiv({
      cls: "ob-table-enhancer-row-bar-button"
    }, (el) => {
      el.innerHTML = deleteIcon;
      el.onclick = async () => {
        if (this.fromCell.rowIndex == 0) {
          new import_obsidian3.Notice("You can't delete header of a table.");
          return;
        }
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.deleteRow(this.fromCell.tableId, this.fromCell.rowIndex);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = moveRightIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.swapCols(this.fromCell.tableId, this.fromCell.colIndex, this.fromCell.colIndex + 1);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = deleteIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.deleteCol(this.fromCell.tableId, this.fromCell.colIndex);
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = centerAlignedIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.setColAligned(this.fromCell.tableId, this.fromCell.colIndex, "center");
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = leftAlignedIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.setColAligned(this.fromCell.tableId, this.fromCell.colIndex, "left");
      };
    });
    this.colOpBarEl.createDiv({
      cls: "ob-table-enhancer-col-bar-button"
    }, (el) => {
      el.innerHTML = rightAlignedIcon;
      el.onclick = async () => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.setColAligned(this.fromCell.tableId, this.fromCell.colIndex, "right");
      };
    });
    plugin.registerDomEvent(activeDocument, "scroll", (e) => {
      this.colOpBarEl.style.opacity = "0";
      this.rowOpBarEl.style.opacity = "0";
      this.activeOpBars = [];
    }, true);
    if (activeDocument) {
      activeDocument.body.appendChild(this.rowOpBarEl);
      activeDocument.body.appendChild(this.colOpBarEl);
    }
  }
  tryShowFor(cell) {
    if (inReadingView())
      return;
    if (this.hideTimeout)
      clearTimeout(this.hideTimeout);
    this.fromCell = cell;
    this.colOpBarEl.style.opacity = "0";
    this.rowOpBarEl.style.opacity = "0";
    this.activeOpBars = [];
    const cellEl2 = cell.cellEl;
    if (cell.rowIndex == 0) {
      this.activeOpBars.push(this.colOpBarEl);
      this.colOpBarEl.style.opacity = "1";
      const cellRect = cellEl2.getBoundingClientRect();
      const toolBarRect = this.colOpBarEl.getBoundingClientRect();
      this.colOpBarEl.style.top = `${cellRect.top - toolBarRect.height}px`;
      this.colOpBarEl.style.left = `${cellRect.left}px`;
      this.colOpBarEl.style.width = `${cellRect.width}px`;
    }
    if (cell.colIndex == 0) {
      this.activeOpBars.push(this.rowOpBarEl);
      this.rowOpBarEl.style.opacity = "1";
      const cellRect = cellEl2.getBoundingClientRect();
      const toolBarRect = this.rowOpBarEl.getBoundingClientRect();
      this.rowOpBarEl.style.top = `${cellRect.top}px`;
      this.rowOpBarEl.style.left = `${cellRect.left - toolBarRect.width}px`;
      this.rowOpBarEl.style.height = `${cellRect.height}px`;
    }
  }
  tryHide(timeout) {
    this.hideTimeout = setTimeout(() => {
      this.colOpBarEl.style.opacity = "0";
      this.rowOpBarEl.style.opacity = "0";
      this.activeOpBars = [];
    }, timeout);
    const stopHideTimeout = (e) => {
      clearTimeout(this.hideTimeout);
      this.activeOpBars.forEach((toolBarEl) => {
        toolBarEl.onmouseout = (e2) => {
          if (e2.relatedTarget instanceof Node && toolBarEl.contains(e2.relatedTarget))
            return;
          this.tryHide(500);
        };
      });
    };
    this.activeOpBars.forEach((toolbar) => {
      toolbar.onmouseenter = stopHideTimeout;
    });
  }
  onUnload() {
    this.colOpBarEl.remove();
    this.rowOpBarEl.remove();
  }
};

// src/setting-tab.ts
var import_obsidian4 = require("obsidian");
var ObTableEnhancerSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Obsidian Table Enhancer Settings" });
    new import_obsidian4.Setting(containerEl).setName("Enable floating toolbar").addToggle((component) => {
      component.setValue(this.plugin.settings.enableFloatingToolBar);
      component.onChange(async (val) => {
        this.plugin.settings.enableFloatingToolBar = val;
        await this.plugin.saveSettings();
      });
    });
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enableFloatingToolBar: false
};
var TableEnhancer = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ObTableEnhancerSettingTab(this.app, this));
    this.tableEditor = new TableEditor(this);
    this.editingCell = null;
    this.hoverCell = null;
    this.app.workspace.onLayoutReady(() => {
      this.suggestPopper = new ReferenceSuggestionPopper(this);
      if (this.settings.enableFloatingToolBar)
        this.toolBar = new ToolBar(this);
      this.registerDomEvent(activeDocument, "keydown", async (e) => {
        if (!this.editingCell)
          return;
        const cell = this.editingCell.cellEl;
        if (!e.repeat && e.key == "Enter" && e.shiftKey && this.editingCell) {
          e.preventDefault();
          const prevCaretPos = getCaretPosition(cell);
          const text1 = cell.innerText.slice(0, prevCaretPos);
          const text2 = cell.innerText.slice(prevCaretPos + 1);
          cell.innerText = [text1, " <br> ", text2].join("");
          setCaretPosition(cell, prevCaretPos + 6);
          return;
        }
        if (!e.repeat && (e.key == "Enter" || e.key == "Escape")) {
          e.preventDefault();
          await this.doneEdit(this.editingCell);
          return;
        }
        if (e.key == "ArrowLeft") {
          e.preventDefault();
          e.stopPropagation();
          const caretPos = getCaretPosition(cell);
          const { tableId: tableId2, rowIndex, colIndex } = this.editingCell;
          if (caretPos == 0) {
            const tableIndex = this.tableEditor.getTableIds().indexOf(tableId2);
            await this.doneEdit(this.editingCell);
            const newTableId = this.tableEditor.getTableIds()[tableIndex];
            const cellLeft = activeDocument.querySelector(`#${newTableId}${rowIndex}${colIndex - 1}`);
            if (cellLeft instanceof HTMLTableCellElement) {
              cellLeft.click();
            }
          } else {
            setCaretPosition(cell, caretPos - 1);
          }
          return;
        }
        if (e.key == "ArrowRight") {
          e.preventDefault();
          e.stopPropagation();
          const caretPos = getCaretPosition(cell);
          const { tableId: tableId2, rowIndex, colIndex } = this.editingCell;
          if (caretPos == cell.innerText.length) {
            const tableIndex = this.tableEditor.getTableIds().indexOf(tableId2);
            await this.doneEdit(this.editingCell);
            const newTableId = this.tableEditor.getTableIds()[tableIndex];
            const cellRight = activeDocument.querySelector(`#${newTableId}${rowIndex}${colIndex + 1}`);
            if (cellRight instanceof HTMLTableCellElement) {
              cellRight.click();
            }
          } else {
            setCaretPosition(cell, caretPos + 1);
          }
          return;
        }
        if (!e.repeat && e.ctrlKey && e.key == "a") {
          e.preventDefault();
          e.stopPropagation();
          const selection = activeWindow.getSelection();
          const range = activeDocument.createRange();
          range.selectNodeContents(cell);
          selection == null ? void 0 : selection.removeAllRanges();
          selection == null ? void 0 : selection.addRange(range);
          return;
        }
        if (e.key == "ArrowUp") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId: tableId2, rowIndex, colIndex } = this.editingCell;
          const tableIndex = this.tableEditor.getTableIds().indexOf(tableId2);
          await this.doneEdit(this.editingCell);
          const newTableId = this.tableEditor.getTableIds()[tableIndex];
          const cellAbove = activeDocument.querySelector(`#${newTableId}${rowIndex - 1}${colIndex}`);
          if (cellAbove instanceof HTMLTableCellElement) {
            cellAbove.click();
          }
          return;
        }
        if (e.key == "ArrowDown") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId: tableId2, rowIndex, colIndex } = this.editingCell;
          const tableIndex = this.tableEditor.getTableIds().indexOf(tableId2);
          await this.doneEdit(this.editingCell);
          const newTableId = this.tableEditor.getTableIds()[tableIndex];
          const cellBelow = activeDocument.querySelector(`#${newTableId}${rowIndex + 1}${colIndex}`);
          if (cellBelow instanceof HTMLTableCellElement) {
            cellBelow.click();
          }
          return;
        }
        if (e.shiftKey && e.key == "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId: tableId2, rowIndex, colIndex } = this.editingCell;
          const tableIndex = this.tableEditor.getTableIds().indexOf(tableId2);
          await this.doneEdit(this.editingCell);
          const newTableId = this.tableEditor.getTableIds()[tableIndex];
          const table2 = this.tableEditor.tables.get(newTableId);
          if (table2) {
            const rowNum = table2.cells.length;
            const colNum = table2.cells[0].length;
            let nextCell;
            if (rowIndex == 0 && colIndex == 0) {
              nextCell = activeDocument.querySelector(`#${newTableId}${rowNum - 1}${colNum - 1}`);
            } else if (colIndex == 0) {
              nextCell = activeDocument.querySelector(`#${newTableId}${rowIndex - 1}${colNum - 1}`);
            } else {
              nextCell = activeDocument.querySelector(`#${newTableId}${rowIndex}${colIndex - 1}`);
            }
            if (nextCell instanceof HTMLTableCellElement)
              nextCell.click();
          }
          return;
        }
        if (e.key == "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const { tableId: tableId2, rowIndex, colIndex } = this.editingCell;
          const tableIndex = this.tableEditor.getTableIds().indexOf(tableId2);
          await this.doneEdit(this.editingCell);
          const newTableId = this.tableEditor.getTableIds()[tableIndex];
          const table2 = this.tableEditor.tables.get(newTableId);
          if (table2) {
            const rowNum = table2.cells.length;
            const colNum = table2.cells[0].length;
            let nextCell;
            if (rowIndex == rowNum - 1 && colIndex == colNum - 1) {
              nextCell = activeDocument.querySelector(`#${newTableId}00`);
            } else if (colIndex == colNum - 1) {
              nextCell = activeDocument.querySelector(`#${newTableId}${rowIndex + 1}0`);
            } else {
              nextCell = activeDocument.querySelector(`#${newTableId}${rowIndex}${colIndex + 1}`);
            }
            if (nextCell instanceof HTMLTableCellElement)
              nextCell.click();
          }
          return;
        }
      });
      this.registerDomEvent(activeDocument, "click", async () => {
        if (this.editingCell && !isSameCell(this.hoverCell, this.editingCell)) {
          await this.doneEdit(this.editingCell);
        }
      });
      this.ctrl = false;
      this.registerDomEvent(activeDocument, "keydown", (e) => {
        if (e.key == "Ctrl")
          this.ctrl = true;
      });
      this.registerDomEvent(activeDocument, "keyup", (e) => {
        if (e.key == "Ctrl")
          this.ctrl = false;
      });
    });
    this.registerMarkdownPostProcessor((element, context) => {
      const tables = element.querySelectorAll("table");
      tables.forEach(async (table) => {
        var _a, _b;
        if (table.classList.contains("dataview"))
          return;
        if (table.parentElement && table.parentElement.classList.contains("admonition-content"))
          return;
        const tableId = this.getIdentifier(table);
        table.classList.add("ob-table-enhancer");
        table.setAttr("id", tableId);
        table.addEventListener("mouseenter", () => {
          this.hoverTableId = tableId;
        });
        table.addEventListener("click", (e) => {
          e.stopPropagation();
        });
        for (let j = 0; j < table.rows.length; j++) {
          const row = table.rows[j];
          for (let k = 0; k < row.cells.length; k++) {
            const cellEl = row.cells[k];
            cellEl.setAttr("id", `${tableId}${j}${k}`);
            if (cellEl.innerText.startsWith(">>>")) {
              await this.tableEditor.parseActiveFile();
              const t = (_b = (_a = this.tableEditor) == null ? void 0 : _a.tables) == null ? void 0 : _b.get(tableId);
              const c = t == null ? void 0 : t.cells.map((row2) => row2[k]).slice(1, -1);
              const nc = t == null ? void 0 : t.cells.map((row2) => row2[k]).slice(1, -1).map((e) => parseFloat(e));
              const sum = (arr) => arr.reduce((a, b) => a + b, 0);
              const avg = (arr) => sum(arr) / arr.length;
              const max = (arr) => Math.max(...arr);
              const min = (arr) => Math.min(...arr);
              try {
                cellEl.innerText = ((str) => eval(str)).call({
                  t,
                  c,
                  nc,
                  sum,
                  avg,
                  min,
                  max
                }, cellEl.innerText.replace(/^>>>/, ""));
              } catch (err) {
                console.error(err);
              }
            }
            cellEl.addEventListener("mouseenter", (e) => {
              var _a2;
              this.hoverCell = {
                tableId,
                rowIndex: j,
                colIndex: k,
                cellEl
              };
              (_a2 = this.toolBar) == null ? void 0 : _a2.tryShowFor(this.hoverCell);
            });
            cellEl.addEventListener("mouseout", (e) => {
              var _a2;
              this.hoverCell = null;
              (_a2 = this.toolBar) == null ? void 0 : _a2.tryHide(200);
            });
            cellEl.addEventListener("click", async (e) => {
              var _a2;
              if (e.targetNode != cellEl)
                return;
              e.preventDefault();
              e.stopPropagation();
              if (this.ctrl || inReadingView())
                return;
              if (cellEl.getAttr("contenteditable") == "true" || !this.hoverTableId)
                return;
              if (this.editingCell && !isSameCell(this.editingCell, this.hoverCell)) {
                const tableIndex = this.tableEditor.getTableIds().indexOf(tableId);
                await this.doneEdit(this.editingCell);
                const newTableId = this.tableEditor.getTableIds()[tableIndex];
                const newCell = activeDocument.querySelector(`#${newTableId}${j}${k}`);
                if (newCell instanceof HTMLTableCellElement)
                  newCell.click();
                return;
              }
              cellEl.focus();
              await this.tableEditor.parseActiveFile();
              cellEl.setAttr("contenteditable", true);
              const text = this.tableEditor.getCell(this.hoverTableId, j, k);
              if (text == "") {
                cellEl.innerText = " ";
                setCaretPosition(cellEl, 0);
              } else {
                cellEl.innerText = text;
                setCaretPosition(cellEl, text.length);
              }
              cellEl.classList.add("is-editing");
              this.editingCell = { tableId: this.hoverTableId, rowIndex: j, colIndex: k, cellEl };
              (_a2 = this.suggestPopper) == null ? void 0 : _a2.bindOuterEl(cellEl);
            });
          }
        }
      });
    });
    this.addCommand({
      id: "insert2x2table",
      name: "Insert 2x2 table",
      editorCallback: async (editor, view) => {
        await this.tableEditor.parseActiveFile();
        await this.tableEditor.createMinimalNewTable();
      }
    });
    this.registerEvent(this.app.workspace.on("editor-menu", (menu, editor, view) => {
      if (this.hoverTableId) {
        menu.addItem((item) => {
          item.setTitle("Copy as HTML");
          item.onClick(async (e) => {
            var _a, _b, _c;
            const tableEl = activeDocument.querySelector(`#${this.hoverTableId}`);
            if (!(tableEl instanceof HTMLTableElement))
              return;
            (_a = activeWindow.getSelection()) == null ? void 0 : _a.removeAllRanges();
            const range = activeDocument.createRange();
            range.selectNode(tableEl);
            (_b = activeWindow.getSelection()) == null ? void 0 : _b.addRange(range);
            activeDocument.execCommand("copy");
            (_c = activeWindow.getSelection()) == null ? void 0 : _c.removeAllRanges();
          });
        });
        menu.addItem(async (item) => {
          item.setTitle("Copy as Markdown");
          item.onClick(async (e) => {
            if (!this.hoverTableId)
              return;
            await this.tableEditor.parseActiveFile();
            const table2 = this.tableEditor.tables.get(this.hoverTableId);
            if (!table2)
              return;
            const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
            if (markdownView instanceof import_obsidian5.MarkdownView) {
              const editor2 = markdownView.editor;
              const tableMd = [];
              let firstRowCells = table2.cells[0];
              firstRowCells = firstRowCells.map((s) => `${s}\u3000`);
              const firstRow = TableEditor.rowCells2rowString(firstRowCells);
              tableMd.push(firstRow);
              for (let i = table2.fromRowIndex + 1; i < table2.toRowIndex; i++)
                tableMd.push(editor2.getLine(i));
              await navigator.clipboard.writeText(tableMd.join("\n"));
            }
          });
        });
        menu.addItem(async (item) => {
          item.setTitle("Delete entire table");
          item.onClick(async () => {
            var _a;
            if (!this.hoverTableId)
              return;
            if (this.editingCell)
              await this.doneEdit(this.editingCell);
            await this.tableEditor.parseActiveFile();
            await ((_a = this.tableEditor) == null ? void 0 : _a.deleteEntireTable(this.hoverTableId));
          });
        });
      }
    }));
  }
  onunload() {
    var _a, _b;
    (_a = this.suggestPopper) == null ? void 0 : _a.onUnload();
    (_b = this.toolBar) == null ? void 0 : _b.onUnload();
  }
  async doneEdit(cell) {
    const { tableId: tableId2, rowIndex, colIndex, cellEl: cellElem } = cell;
    if (!this.hoverTableId)
      return;
    const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!(markdownView instanceof import_obsidian5.MarkdownView))
      return;
    cellElem.setAttr("contenteditable", false);
    const editor = markdownView.editor;
    const cm = editor.cm;
    const scrollDom = cm.scrollDOM;
    const x = scrollDom.scrollLeft;
    const y = scrollDom.scrollTop;
    const resetScroll = () => {
      scrollDom.scrollTo(x, y);
      editor.blur();
    };
    scrollDom.addEventListener("scroll", resetScroll, true);
    await this.tableEditor.update(this.hoverTableId, rowIndex, colIndex, cellElem.innerText.trim());
    scrollDom.removeEventListener("scroll", resetScroll, true);
    editor.blur();
    await this.tableEditor.parseActiveFile();
    cellElem.classList.remove("is-editing");
    if (this.suggestPopper)
      this.suggestPopper.disable();
    this.editingCell = null;
  }
  getIdentifier(table2) {
    const result = [];
    const rowNum = table2.rows.length;
    for (let i2 = 0; i2 < rowNum; i2++) {
      const str2 = table2.rows[i2].cells[0].innerHTML.replace(/&nbsp;/gi, "");
      if (str2 != "" && !str2.match(/[!<>*#\[\]`$&=]/)) {
        result.push(str2.replace(/[\r\n\t\f\v \u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\ufeff]/g, ""));
      }
    }
    let i = table2.rows[0].cells.length;
    while (i--) {
      const str2 = table2.rows[0].cells[i].innerHTML.replace(/&nbsp;/gi, "");
      if (str2 && !str2.match(/[!<>*#\[\]`$&=]/))
        result.push(str2.replace(/[\r\n\t\f\v \u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\ufeff]/g, ""));
    }
    let resultStr = result.join("");
    if (resultStr.length == 0)
      return "\u7A7A\u8868";
    resultStr += table2.rows.length.toString();
    resultStr += table2.rows[0].cells.length.toString();
    return String.fromCharCode(hashCode(resultStr));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    var _a;
    await this.saveData(this.settings);
    if (!this.settings.enableFloatingToolBar) {
      (_a = this.toolBar) == null ? void 0 : _a.onUnload();
      this.toolBar = null;
    } else {
      this.toolBar = new ToolBar(this);
    }
  }
};
