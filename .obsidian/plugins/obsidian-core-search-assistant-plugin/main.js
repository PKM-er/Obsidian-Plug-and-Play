/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => CoreSearchAssistantPlugin
});

// src/Events.ts
var import_obsidian = __toModule(require("obsidian"));
var EVENT_SEARCH_RESULT_ITEM_DETECTED = "search-result-item-detected";
var EVENT_SORT_ORDER_CHANGED = "sort-order-changed";
var CoreSearchAssistantEvents = class extends import_obsidian.Events {
  trigger(name, ...data) {
    super.trigger(name, ...data);
  }
  on(name, callback, ctx) {
    return super.on(name, callback, ctx);
  }
};

// src/Controller.ts
var obsidian = __toModule(require("obsidian"));

// src/components/OptionModal.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/types/Option.ts
var searchOptions = {
  matchingCase: {
    iconId: "uppercase-lowercase-a",
    description: "Toggle matching case"
  },
  explainSearch: {
    iconId: "info",
    description: "Toggle explanation of search term"
  },
  collapseAll: {
    iconId: "bullet-list",
    description: "Toggle collapsing results"
  },
  extraContext: {
    iconId: "expand-vertically",
    description: "Toggle showing more context"
  },
  alphabetical: {
    iconId: "down-arrow-with-tail",
    description: "Sort by file name (A \u2192 Z)"
  },
  alphabeticalReverse: {
    iconId: "up-arrow-with-tail",
    description: "Sort by file name (Z \u2192 A)"
  },
  byModifiedTime: {
    iconId: "down-arrow-with-tail",
    description: "Sort by modified time (new \u2192 old)"
  },
  byModifiedTimeReverse: {
    iconId: "up-arrow-with-tail",
    description: "Sort by modified time (old \u2192 new)"
  },
  byCreatedTime: {
    iconId: "down-arrow-with-tail",
    description: "Sort by created time (new \u2192 old)"
  },
  byCreatedTimeReverse: {
    iconId: "up-arrow-with-tail",
    description: "Sort by created time (old \u2192 new)"
  }
};

// src/components/OptionModal.ts
var OptionModal = class extends import_obsidian2.Modal {
  constructor(app2, plugin2, modeScope) {
    super(app2);
    this.plugin = plugin2;
    this.modeScope = modeScope;
    this.items = [
      {
        id: "matchingCase",
        key: "a",
        onChoose: () => {
          var _a, _b, _c;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleMatchingCase();
          (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
          (_c = this.plugin.controller) == null ? void 0 : _c.reset();
        }
      },
      {
        id: "explainSearch",
        key: "s",
        onChoose: () => {
          var _a;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleExplainSearch();
        }
      },
      {
        id: "collapseAll",
        key: "d",
        onChoose: () => {
          var _a;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleCollapseAll();
        }
      },
      {
        id: "extraContext",
        key: "f",
        onChoose: () => {
          var _a;
          (_a = this.plugin.searchInterface) == null ? void 0 : _a.toggleExtraContext();
        }
      },
      {
        id: "alphabetical",
        key: "g",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("alphabetical");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "alphabeticalReverse",
        key: "h",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("alphabeticalReverse");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byModifiedTime",
        key: "j",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byModifiedTime");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byModifiedTimeReverse",
        key: "k",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byModifiedTimeReverse");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byCreatedTime",
        key: "l",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byCreatedTime");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      },
      {
        id: "byCreatedTimeReverse",
        key: ";",
        onChoose: () => {
          var _a, _b, _c;
          const changed = (_a = this.plugin.searchInterface) == null ? void 0 : _a.setSortOrder("byCreatedTimeReverse");
          if (changed) {
            (_b = this.plugin.searchInterface) == null ? void 0 : _b.renewSortOrderInfo();
            (_c = this.plugin.controller) == null ? void 0 : _c.reset();
          }
        }
      }
    ];
  }
  onOpen() {
    this.modeScope.push();
    this.items.forEach((item) => {
      this.scope.register([], item.key, item.onChoose);
    });
    this.renderOptions();
  }
  onClose() {
    const { containerEl } = this;
    containerEl.empty();
    setTimeout(() => this.modeScope.pop(), 100);
  }
  renderOptions() {
    const { contentEl } = this;
    contentEl.empty();
    this.containerEl.addClass("core-search-assistant_option-modal");
    this.items.forEach((item) => {
      const entryEl = contentEl.createEl("div", {
        cls: "suggestion-item"
      });
      const iconEl = entryEl.createEl("span", {
        cls: "suggestion-icon"
      });
      (0, import_obsidian2.setIcon)(iconEl, searchOptions[item.id].iconId);
      entryEl.createEl("span", {
        text: searchOptions[item.id].description,
        cls: "suggestion-content"
      });
      entryEl.createEl("kbd", {
        text: item.key.toUpperCase(),
        cls: "suggestion-hotkey"
      });
    });
  }
};

// src/Setting.ts
var import_obsidian7 = __toModule(require("obsidian"));

// src/ui/HotkeySetter.ts
var import_obsidian6 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store2, ...callbacks) {
  if (store2 == null) {
    return noop;
  }
  const unsub = store2.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store2, callback) {
  component.$$.on_destroy.push(subscribe(store2, callback));
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, false, detail);
  return e;
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance8, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance8 ? instance8(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/ui/HotkeyEntry.svelte
var import_obsidian5 = __toModule(require("obsidian"));

// src/ui/HotkeySetting.svelte
var import_obsidian4 = __toModule(require("obsidian"));

// src/utils/Keymap.ts
var import_obsidian3 = __toModule(require("obsidian"));
var CODE_KEY_MAP = {
  Semicolon: ";",
  Quote: "'",
  Comma: ",",
  Period: ".",
  Slash: "/",
  BracketLeft: "[",
  BracketRight: "]",
  BackSlash: "\\",
  Backquote: "`",
  Space: " ",
  Minus: "-",
  Equal: "="
};
for (let i = 0; i < 10; i++) {
  CODE_KEY_MAP[`Digit${i}`] = i.toString();
}
for (let i = 65; i < 91; i++) {
  const char = String.fromCharCode(i);
  const upChar = char.toUpperCase();
  CODE_KEY_MAP[`Key${upChar}`] = char;
}
function convertCodeToKey(code) {
  var _a;
  return (_a = CODE_KEY_MAP[code]) != null ? _a : code;
}
function convertKeyToText(key) {
  switch (key) {
    case "ArrowLeft":
      return "\u2190";
    case "ArrowRight":
      return "\u2192";
    case "ArrowUp":
      return "\u2191";
    case "ArrowDown":
      return "\u2193";
    case "Mod":
      return import_obsidian3.Platform.isMacOS ? "\u2318" : "Ctrl";
    case "Ctrl":
      return import_obsidian3.Platform.isMacOS ? "\u2303" : "Ctrl";
    case "Meta":
      return import_obsidian3.Platform.isMacOS ? "\u2318" : "Win";
    case "Alt":
      return import_obsidian3.Platform.isMacOS ? "\u2325" : "Alt";
    case "Shift":
      return import_obsidian3.Platform.isMacOS ? "\u21E7" : "Shift";
    case " ":
      return "Space";
    case "Enter":
      return "\u21B5";
    default:
      return key.charAt(0).toUpperCase() + key.slice(1);
  }
}
function convertHotkeyToText(hotkey) {
  const parts = [];
  hotkey.modifiers.forEach((mod) => {
    parts.push(convertKeyToText(mod));
  });
  const modifierPart = parts.join(" ");
  const keyPart = convertKeyToText(hotkey.key);
  return ` ${modifierPart} ${keyPart} `;
}
function compileModifiers(modifiers) {
  return modifiers.map((modifier) => {
    return modifier === "Mod" ? import_obsidian3.Platform.isMacOS ? "Meta" : "Ctrl" : modifier;
  }).sort().join(",");
}
function decompileModifiers(modifiersId) {
  const modifiers = [];
  const parts = modifiersId.split(",");
  parts.forEach((s) => {
    if (import_obsidian3.Platform.isMacOS && s === "Meta" || !import_obsidian3.Platform.isMacOS && s === "Ctrl") {
      modifiers.push("Mod");
      return;
    }
    if (s === "Alt" || s === "Shift" || s === "Meta" || s === "Ctrl") {
      modifiers.push(s);
      return;
    }
  });
  return modifiers;
}
function getModifiers(evt) {
  const modifiers = [];
  evt.ctrlKey && modifiers.push("Ctrl");
  evt.metaKey && modifiers.push("Meta");
  evt.altKey && modifiers.push("Alt");
  evt.shiftKey && modifiers.push("Shift");
  return compileModifiers(modifiers);
}
function getHotkey(evt) {
  const modifiers = decompileModifiers(getModifiers(evt));
  const key = convertCodeToKey(evt.code);
  return {
    modifiers,
    key
  };
}
function contain(hotkeys, hotkey) {
  const hotkeyId = convertHotkeyToText(hotkey);
  return hotkeys.some((key) => {
    return hotkeyId === convertHotkeyToText(key);
  });
}

// src/ui/HotkeySetting.svelte
function add_css(target) {
  append_styles(target, "svelte-2wacg2", ".icon-container.svelte-2wacg2{display:inline-block;cursor:pointer;width:16px;height:16px;border-radius:10px;line-height:16px;text-align:center}.icon-container.svelte-2wacg2:hover{background-color:var(--background-modifier-error);color:var(--text-on-accent)}.setting-hotkey.svelte-2wacg2{font-size:12px;background-color:var(--background-secondary-alt);border-radius:4px;padding:0 10px;min-height:24px;align-self:flex-end;position:relative}");
}
function create_fragment(ctx) {
  let span1;
  let t0_value = convertHotkeyToText(ctx[0]) + "";
  let t0;
  let t1;
  let span0;
  let mounted;
  let dispose;
  return {
    c() {
      span1 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span0 = element("span");
      attr(span0, "class", "icon-container svelte-2wacg2");
      attr(span1, "class", "setting-hotkey svelte-2wacg2");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t0);
      append(span1, t1);
      append(span1, span0);
      ctx[3](span0);
      if (!mounted) {
        dispose = listen(span0, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t0_value !== (t0_value = convertHotkeyToText(ctx2[0]) + ""))
        set_data(t0, t0_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span1);
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { hotkey } = $$props;
  let iconContainerEl;
  const dispatcher = createEventDispatcher();
  onMount(() => {
    if (iconContainerEl instanceof HTMLSpanElement) {
      (0, import_obsidian4.setIcon)(iconContainerEl, "cross", 8);
    }
  });
  function onIconClicked() {
    dispatcher("removed");
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconContainerEl = $$value;
      $$invalidate(1, iconContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
  };
  return [hotkey, iconContainerEl, onIconClicked, span0_binding];
}
var HotkeySetting = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { hotkey: 0 }, add_css);
  }
};
var HotkeySetting_default = HotkeySetting;

// src/ui/HotkeyEntry.svelte
function add_css2(target) {
  append_styles(target, "svelte-1my40ui", ".item-container.svelte-1my40ui{display:flex;align-items:center;padding:18px 0 18px 0;border-top:1px solid var(--background-modifier-border)}.info-container.svelte-1my40ui{flex:1 1 auto;flex-grow:1;margin-right:20px}.control-container.svelte-1my40ui{flex:1 1 auto;text-align:right;display:flex;justify-content:flex-end;align-items:center}.hotkeys-container.svelte-1my40ui{display:flex;flex-direction:column;margin-right:6px}.setting-hotkey.svelte-1my40ui{font-size:12px;background-color:var(--interactive-accent);border-radius:4px;padding:0 10px;min-height:24px;align-self:flex-end;position:relative;color:var(--text-on-accent)}.icon-container.svelte-1my40ui{padding:4px 6px;border-radius:4px;color:var(--text-faint);cursor:pointer;height:26px}.icon-container.svelte-1my40ui:hover{background-color:var(--background-secondary-alt);color:var(--text-normal)}.icon-container.svelte-1my40ui .clickable-icon{color:unset;cursor:unset;margin:unset}.icon-container.svelte-1my40ui .setting-editor-extra-setting-button{line-height:0}.icon-container.svelte-1my40ui .clickable-icon svg{position:relative;bottom:2px}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let hotkeysetting;
  let current;
  function removed_handler() {
    return ctx[8](ctx[13]);
  }
  hotkeysetting = new HotkeySetting_default({ props: { hotkey: ctx[13] } });
  hotkeysetting.$on("removed", removed_handler);
  return {
    c() {
      create_component(hotkeysetting.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkeysetting, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hotkeysetting_changes = {};
      if (dirty & 16)
        hotkeysetting_changes.hotkey = ctx[13];
      hotkeysetting.$set(hotkeysetting_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkeysetting.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkeysetting.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkeysetting, detaching);
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Press hotkey...";
      attr(div, "class", "setting-hotkey svelte-1my40ui");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment2(ctx) {
  var _a;
  let div3;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let t3;
  let span0;
  let t4;
  let span1;
  let current;
  let mounted;
  let dispose;
  let each_value = (_a = ctx[4]) != null ? _a : [];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = ctx[3] && create_if_block(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      span0 = element("span");
      t4 = space();
      span1 = element("span");
      attr(div0, "class", "info-container svelte-1my40ui");
      attr(div1, "class", "hotkeys-container svelte-1my40ui");
      attr(span0, "class", "icon-container svelte-1my40ui");
      attr(span1, "class", "icon-container svelte-1my40ui");
      attr(div2, "class", "control-container svelte-1my40ui");
      attr(div3, "class", "item-container svelte-1my40ui");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, t0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      append(div2, t3);
      append(div2, span0);
      ctx[9](span0);
      append(div2, t4);
      append(div2, span1);
      ctx[11](span1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[10]),
          listen(span1, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 48) {
        each_value = (_a2 = ctx2[4]) != null ? _a2 : [];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, t2);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      ctx[9](null);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var ICON_SIZE = 22;
function instance2($$self, $$props, $$invalidate) {
  let _hotkeys;
  let _listening;
  let { actionName } = $$props;
  let { hotkeys } = $$props;
  let { listening = false } = $$props;
  let restoreButtonEl;
  let addHotkeyButtonEl;
  const dispatcher = createEventDispatcher();
  onMount(() => {
    if (restoreButtonEl) {
      const component = new import_obsidian5.ExtraButtonComponent(restoreButtonEl).setTooltip("Restore default");
      (0, import_obsidian5.setIcon)(component.extraSettingsEl, "reset", ICON_SIZE);
    }
    if (addHotkeyButtonEl) {
      const component = new import_obsidian5.ExtraButtonComponent(addHotkeyButtonEl).setTooltip("Customize this action");
      (0, import_obsidian5.setIcon)(component.extraSettingsEl, "any-key", ICON_SIZE);
    }
  });
  const removed_handler = (hotkey) => {
    dispatcher("removed", { removed: hotkey });
  };
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      restoreButtonEl = $$value;
      $$invalidate(1, restoreButtonEl);
    });
  }
  const click_handler = () => {
    dispatcher("restored");
  };
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      addHotkeyButtonEl = $$value;
      $$invalidate(2, addHotkeyButtonEl);
    });
  }
  const click_handler_1 = () => {
    dispatcher("start-listening-keys");
  };
  $$self.$$set = ($$props2) => {
    if ("actionName" in $$props2)
      $$invalidate(0, actionName = $$props2.actionName);
    if ("hotkeys" in $$props2)
      $$invalidate(6, hotkeys = $$props2.hotkeys);
    if ("listening" in $$props2)
      $$invalidate(7, listening = $$props2.listening);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        $$invalidate(4, _hotkeys = [...hotkeys !== null && hotkeys !== void 0 ? hotkeys : []]);
    }
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, _listening = listening);
    }
  };
  return [
    actionName,
    restoreButtonEl,
    addHotkeyButtonEl,
    _listening,
    _hotkeys,
    dispatcher,
    hotkeys,
    listening,
    removed_handler,
    span0_binding,
    click_handler,
    span1_binding,
    click_handler_1
  ];
}
var HotkeyEntry = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { actionName: 0, hotkeys: 6, listening: 7 }, add_css2);
  }
};
var HotkeyEntry_default = HotkeyEntry;

// src/ui/HotkeySetter.ts
var HotkeySetter = class {
  constructor(app2, containerEl, text2, currentHotkeys, defaultHotkeys) {
    this.shouldReflect = (_) => true;
    this.onRestored = () => {
      const { component } = this;
      if (!component)
        return;
      const renewed = [...this.defaultHotkeys];
      if (this.shouldReflect(renewed)) {
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
      }
    };
    this.onRemoved = (evt) => {
      const { component } = this;
      if (!component)
        return;
      if (!(evt instanceof CustomEvent))
        return;
      const removed = evt.detail.removed;
      const renewed = [...this.currentHotkeys];
      renewed.remove(removed);
      if (this.shouldReflect(renewed)) {
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
      }
    };
    this.onStartListening = () => {
      const { component } = this;
      if (!component)
        return;
      component.$set({
        listening: true
      });
      this.scope = new import_obsidian6.Scope();
      this.app.keymap.pushScope(this.scope);
      this.scope.register(null, null, (evt) => {
        evt.preventDefault();
        if (evt.key === "Escape") {
          component.$set({
            listening: false
          });
          if (this.scope)
            this.app.keymap.popScope(this.scope);
          return;
        }
        const hotkey = getHotkey(evt);
        const collision = contain(this.currentHotkeys, hotkey);
        if (collision)
          return;
        const renewed = [...this.currentHotkeys];
        renewed.push(hotkey);
        if (!this.shouldReflect(renewed, hotkey))
          return;
        this.currentHotkeys = renewed;
        component.$set({
          hotkeys: renewed
        });
        component.$set({
          listening: false
        });
        if (this.scope)
          this.app.keymap.popScope(this.scope);
      });
    };
    this.app = app2;
    this.containerEl = containerEl;
    this.text = text2;
    this.currentHotkeys = [...currentHotkeys];
    this.defaultHotkeys = [...defaultHotkeys];
    this.component = this.attachComponent();
  }
  unload() {
    this.onunload();
  }
  onChanged(cb) {
    this.shouldReflect = cb;
    return this;
  }
  attachComponent() {
    const component = new HotkeyEntry_default({
      target: this.containerEl,
      props: {
        actionName: this.text,
        hotkeys: this.currentHotkeys
      }
    });
    component.$on("removed", this.onRemoved);
    component.$on("restored", this.onRestored);
    component.$on("start-listening-keys", this.onStartListening);
    return component;
  }
  onunload() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
    if (this.scope) {
      this.app.keymap.popScope(this.scope);
    }
  }
};

// src/Setting.ts
var AVAILABLE_OUTLINE_WIDTHS = [0, 3, 5, 7, 10];
var AUTO_PREVIEW_MODE_IDS = ["none", "singleView", "cardView"];
var autoPreviewModeInfos = {
  none: "none",
  singleView: "single view",
  cardView: "card view"
};
var AVAILABLE_CARD_LAYOUT = ["2x2", "2x3", "3x2", "3x3"];
var DEFAULT_SETTINGS = {
  keepSelectedItemsCentered: false,
  outlineWidth: 5,
  autoPreviewMode: "cardView",
  cardViewLayout: "2x3",
  splitDirection: "horizontal",
  autoToggleSidebar: false,
  renderCardsManually: false,
  searchModeHotkeys: {
    selectNext: [
      { modifiers: ["Ctrl"], key: "n" },
      { modifiers: [], key: "ArrowDown" }
    ],
    selectPrevious: [
      { modifiers: ["Ctrl"], key: "p" },
      { modifiers: [], key: "ArrowUp" }
    ],
    previewModal: [{ modifiers: ["Ctrl"], key: " " }],
    open: [{ modifiers: ["Ctrl"], key: "Enter" }],
    openInNewPane: [{ modifiers: ["Ctrl", "Shift"], key: "Enter" }],
    showOptions: [{ modifiers: ["Shift"], key: " " }],
    nextPage: [{ modifiers: ["Ctrl"], key: "]" }],
    previousPage: [{ modifiers: ["Ctrl"], key: "[" }],
    copyLink: [{ modifiers: ["Ctrl"], key: "i" }]
  },
  previewModalHotkeys: {
    scrollDown: [
      { modifiers: ["Ctrl"], key: "n" },
      { modifiers: [], key: "ArrowDown" }
    ],
    scrollUp: [
      { modifiers: ["Ctrl"], key: "p" },
      { modifiers: [], key: "ArrowUp" }
    ],
    bigScrollDown: [{ modifiers: [], key: " " }],
    bigScrollUp: [{ modifiers: ["Shift"], key: " " }],
    open: [{ modifiers: ["Ctrl"], key: "Enter" }],
    openInNewPage: [{ modifiers: ["Ctrl", "Shift"], key: "Enter" }],
    closeModal: [{ modifiers: ["Ctrl"], key: " " }],
    focusNext: [{ modifiers: [], key: "Tab" }],
    focusPrevious: [{ modifiers: ["Shift"], key: "Tab" }],
    togglePreviewMode: [{ modifiers: ["Ctrl"], key: "e" }],
    copyLink: [{ modifiers: ["Ctrl"], key: "i" }]
  }
};
var CoreSearchAssistantSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app2, plugin2) {
    super(app2, plugin2);
    this.plugin = plugin2;
    this.hotkeySetters = [];
  }
  display() {
    this.hide();
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian7.Setting(containerEl).setName("Keep selected item centered").addToggle((component) => {
      var _a, _b;
      component.setValue((_b = (_a = this.plugin.settings) == null ? void 0 : _a.keepSelectedItemsCentered) != null ? _b : DEFAULT_SETTINGS.keepSelectedItemsCentered).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        this.plugin.settings.keepSelectedItemsCentered = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Outline width (px)").setDesc("An outline appears when you enter search mode.").addDropdown((component) => {
      var _a;
      AVAILABLE_OUTLINE_WIDTHS.forEach((width) => {
        const text2 = width.toString();
        component.addOption(text2, text2);
      });
      component.setValue(validOutlineWidth((_a = this.plugin.settings) == null ? void 0 : _a.outlineWidth).toString()).onChange((value) => {
        const width = Number.parseInt(value);
        if (!this.plugin.settings) {
          return;
        }
        if (!AVAILABLE_OUTLINE_WIDTHS.includes(width)) {
          return;
        }
        this.plugin.settings.outlineWidth = width;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Auto preview mode").addDropdown((component) => {
      var _a, _b;
      component.addOptions(autoPreviewModeInfos).setValue((_b = (_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) != null ? _b : "cardView").onChange((id) => {
        if (!this.plugin.settings) {
          return;
        }
        if (!AUTO_PREVIEW_MODE_IDS.includes(id)) {
          return;
        }
        this.plugin.settings.autoPreviewMode = id;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Default layout of card view").addDropdown((component) => {
      var _a, _b;
      AVAILABLE_CARD_LAYOUT.forEach((layout) => {
        component.addOption(layout, layout);
      });
      component.setValue((_b = (_a = this.plugin.settings) == null ? void 0 : _a.cardViewLayout) != null ? _b : DEFAULT_SETTINGS.cardViewLayout).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        if (!AVAILABLE_CARD_LAYOUT.includes(value)) {
          return;
        }
        this.plugin.settings.cardViewLayout = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Default split direction").setDesc("This applies when you open a file in a new pane").addDropdown((component) => {
      if (!this.plugin.settings) {
        return;
      }
      component.addOptions({
        horizontal: "horizontal",
        vertical: "vertical"
      }).setValue(this.plugin.settings.splitDirection).onChange((direction) => __async(this, null, function* () {
        if (!this.plugin.settings) {
          return;
        }
        if (direction == "horizontal" || direction == "vertical") {
          this.plugin.settings.splitDirection = direction;
          yield this.plugin.saveSettings();
        }
      }));
    });
    new import_obsidian7.Setting(containerEl).setName("Toggle sidebars automatically").setDesc("Automatically collapse the other sidebar when entering the search mode and the search panel when exiting the search mode").addToggle((component) => {
      if (!this.plugin.settings) {
        return;
      }
      component.setValue(this.plugin.settings.autoToggleSidebar).onChange((value) => {
        if (!this.plugin.settings) {
          return;
        }
        this.plugin.settings.autoToggleSidebar = value;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian7.Setting(containerEl).setName("Render cards manually").setDesc("If enabled, you must hit the enter key to render cards.").addToggle((component) => {
      if (!this.plugin.settings)
        return;
      component.setValue(this.plugin.settings.renderCardsManually).onChange((value) => {
        if (!this.plugin.settings)
          return;
        this.plugin.settings.renderCardsManually = value;
        this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h2", { text: "Hotkeys" });
    const { settings } = this.plugin;
    containerEl.createEl("h3", { text: "Search mode" });
    if (!settings)
      return;
    SEARCH_MODE_HOTKEY_ACTION_IDS.forEach((actionId) => {
      const hotkeys = settings.searchModeHotkeys[actionId];
      const defaultHotkeys = DEFAULT_SETTINGS.searchModeHotkeys[actionId];
      const description = SEARCH_MODE_HOTKEY_ACTION_INFO[actionId];
      const hotkeySetter = new HotkeySetter(this.app, containerEl, description, hotkeys, defaultHotkeys).onChanged((renewed, added) => {
        if (added) {
          if (added.modifiers.length === 0)
            return false;
          const collision = SEARCH_MODE_HOTKEY_ACTION_IDS.some((actionId2) => {
            const hotkeys2 = settings.searchModeHotkeys[actionId2];
            return contain(hotkeys2, added);
          });
          if (collision) {
            new import_obsidian7.Notice("Hotkeys are conflicting!");
            return false;
          }
        }
        settings.searchModeHotkeys[actionId] = renewed;
        this.plugin.saveSettings();
        return true;
      });
      this.hotkeySetters.push(hotkeySetter);
    });
    containerEl.createEl("h3", { text: "Preview Modal" });
    PREVIEW_MODAL_HOTKEY_ACTION_IDS.forEach((actionId) => {
      const hotkeys = settings.previewModalHotkeys[actionId];
      const defaultHotkeys = DEFAULT_SETTINGS.previewModalHotkeys[actionId];
      const description = PREVIEW_MODAL_HOTKEY_ACTION_INFO[actionId];
      DEFAULT_SETTINGS.previewModalHotkeys[actionId];
      const hotkeySetter = new HotkeySetter(this.app, containerEl, description, hotkeys, defaultHotkeys).onChanged((renewed, added) => {
        if (added) {
          const collision = PREVIEW_MODAL_HOTKEY_ACTION_IDS.some((actionId2) => {
            const hotkeys2 = settings.previewModalHotkeys[actionId2];
            return contain(hotkeys2, added);
          });
          if (collision) {
            new import_obsidian7.Notice("Hotkeys are conflicting!");
            return false;
          }
        }
        settings.previewModalHotkeys[actionId] = renewed;
        this.plugin.saveSettings();
        return true;
      });
      this.hotkeySetters.push(hotkeySetter);
    });
  }
  hide() {
    super.hide();
    this.hotkeySetters.forEach((s) => s.unload());
    this.hotkeySetters = [];
  }
};
function validOutlineWidth(width) {
  if (typeof width !== "number") {
    return DEFAULT_SETTINGS.outlineWidth;
  }
  if (!Number.isInteger(width)) {
    return DEFAULT_SETTINGS.outlineWidth;
  }
  if (!AVAILABLE_OUTLINE_WIDTHS.includes(width)) {
    return DEFAULT_SETTINGS.outlineWidth;
  }
  return width;
}
function parseCardLayout(layout) {
  const [row, column] = layout.split("x");
  return [Number.parseInt(row != null ? row : "0"), Number.parseInt(column != null ? column : "0")];
}
var SEARCH_MODE_HOTKEY_ACTION_IDS = [
  "selectNext",
  "selectPrevious",
  "previewModal",
  "open",
  "openInNewPane",
  "showOptions",
  "nextPage",
  "previousPage",
  "copyLink"
];
var SEARCH_MODE_HOTKEY_ACTION_INFO = {
  selectNext: "Select the next item",
  selectPrevious: "Select the previous item",
  previewModal: "Preview the selected item",
  open: "Open the selected item",
  openInNewPane: "Open the selected item in a new pane",
  showOptions: "Set search options",
  nextPage: "Move to the next set of cards",
  previousPage: "Move to the previous set of cards",
  copyLink: "Copy wiki link of the selected item"
};
var PREVIEW_MODAL_HOTKEY_ACTION_IDS = [
  "scrollDown",
  "scrollUp",
  "bigScrollDown",
  "bigScrollUp",
  "open",
  "openInNewPage",
  "closeModal",
  "focusNext",
  "focusPrevious",
  "togglePreviewMode",
  "copyLink"
];
var PREVIEW_MODAL_HOTKEY_ACTION_INFO = {
  scrollDown: "Scroll down a bit",
  scrollUp: "Scroll up a bit",
  bigScrollDown: "Scroll down a lot",
  bigScrollUp: "Scroll up a lot",
  open: "Open the selected item",
  openInNewPage: "Open the selected item in a new pane",
  closeModal: "Close the modal",
  focusNext: "Focus on the next match",
  focusPrevious: "Focus on the previous match",
  togglePreviewMode: "Toggle preview mode",
  copyLink: "Copy wiki link of the selected item"
};

// src/components/PreviewModal.ts
var import_obsidian13 = __toModule(require("obsidian"));

// src/utils/Util.ts
function delay(millisecond) {
  return __async(this, null, function* () {
    yield new Promise((resolve) => setTimeout(resolve, millisecond));
  });
}
function scrollIteration(editor) {
  const line = lineCount(editor);
  if (line === void 0) {
    return void 0;
  }
  return Math.max(Math.floor(line / 1e3), 1);
}
function lineCount(editor) {
  var _a, _b, _c;
  const line = (_c = (_b = (_a = editor == null ? void 0 : editor["cm"]) == null ? void 0 : _a["state"]) == null ? void 0 : _b["doc"]) == null ? void 0 : _c.length;
  return typeof line === "number" ? line : void 0;
}
function retry(cb, interval, trials, check = (got) => got !== void 0) {
  return __async(this, null, function* () {
    for (let i = 0; i < trials; i++) {
      const got = cb();
      if (check(got)) {
        return got;
      }
      yield delay(interval);
    }
    return void 0;
  });
}
function shallowClone(obj) {
  return Object.assign({}, obj);
}
function deepClone(obj) {
  if (obj === null)
    return obj;
  if (typeof obj !== "object")
    return obj;
  if (obj instanceof Array) {
    const clone2 = new Array(obj.length);
    obj.forEach((value, id) => {
      clone2[id] = deepClone(value);
    });
    return clone2;
  }
  const clone = shallowClone(obj);
  for (const key in clone) {
    const value = clone[key];
    clone[key] = deepClone(value);
  }
  return clone;
}
function deepMerge(a, b) {
  if (b === void 0) {
    return deepClone(a);
  } else if (a === void 0) {
    return deepClone(b);
  }
  if (typeof a !== typeof b) {
    throw new Error(`failed to deepMerge ${a} and ${b}`);
  }
  if (typeof b !== "object")
    return deepClone(b);
  if (b === null) {
    return deepClone(a);
  } else if (a === null) {
    return deepClone(b);
  }
  if (b instanceof Array) {
    if (a instanceof Array) {
      return deepClone(b);
    } else {
      throw new Error(`failed to deepMerge ${a} and ${b}`);
    }
  } else if (a instanceof Array) {
    throw new Error(`failed to deepMerge ${a} and ${b}`);
  }
  const clone = shallowClone(a);
  for (const key in a) {
    clone[key] = deepMerge(a[key], b[key]);
  }
  for (const key in b) {
    clone[key] = deepMerge(a[key], b[key]);
  }
  return clone;
}

// src/utils/Link.ts
function generateInternalLinkFrom(app2, file) {
  const text2 = getDisplayText(app2.metadataCache, file);
  return app2.fileManager.generateMarkdownLink(file, "", void 0, text2);
}
function getDisplayText(metadataCache, file) {
  const cache = metadataCache.getFileCache(file);
  if (!cache)
    return void 0;
  const title = getTitle(cache.frontmatter);
  if (title !== void 0) {
    return title;
  }
  const h1 = getFirstH1(cache.headings);
  if (h1 !== void 0) {
    return h1;
  }
  return void 0;
}
function getTitle(frontmatter) {
  return frontmatter == null ? void 0 : frontmatter["title"];
}
function getFirstH1(headings) {
  if (!headings)
    return void 0;
  for (const heading of headings) {
    if (heading.level !== 1)
      continue;
    return heading.heading;
  }
  return void 0;
}

// node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// src/interfaces/ViewGenerator.ts
var import_obsidian8 = __toModule(require("obsidian"));
var ViewGenerator = class {
  constructor(app2, containerEl, file) {
    this.extensions = [];
    this.app = app2;
    this.containerEl = containerEl;
    this.leaf = new import_obsidian8.WorkspaceLeaf(this.app);
    this.file = file;
  }
  load(mode) {
    return __async(this, null, function* () {
      yield this.onload(mode);
      return this;
    });
  }
  unload() {
    return __async(this, null, function* () {
      this.onunload();
    });
  }
  toggleViewMode() {
    return __async(this, null, function* () {
      for (const ext of this.extensions) {
        if (!(yield ext.isMine(this.leaf)))
          continue;
        yield ext.toggleViewMode(this.leaf);
        return;
      }
    });
  }
  onload(mode) {
    return __async(this, null, function* () {
      const fileType = fileTypeMap[this.file.extension];
      if (!fileType)
        return;
      this.containerEl.appendChild(this.leaf.containerEl);
      yield this.openFile();
      for (const ext of this.extensions) {
        if (!(yield ext.isMine(this.leaf)))
          continue;
        yield ext.setViewMode(this.leaf, mode != null ? mode : "preview");
        return;
      }
    });
  }
  onunload() {
    this.leaf.detach();
  }
  openFile() {
    return __async(this, null, function* () {
      const { leaf, file } = this;
      yield leaf.openFile(file);
    });
  }
  highlightMatches(matches, cls) {
    const view = this.leaf.view;
    if (!(view instanceof import_obsidian8.MarkdownView)) {
      return;
    }
    const editor = view.editor;
    const ranges = [];
    matches.forEach((match) => {
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      ranges.push(range);
    });
    editor.addHighlights(ranges, cls);
  }
  scrollIntoView(match, center) {
    return __async(this, null, function* () {
      const view = this.leaf.view;
      if (!(view instanceof import_obsidian8.MarkdownView)) {
        return;
      }
      if (view.getMode() !== "source") {
        return;
      }
      const editor = view.editor;
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      const iter = scrollIteration(editor);
      if (iter === void 0) {
        return;
      }
      for (let i = 0; i < iter; i++) {
        editor.scrollIntoView(range, center);
        yield delay(1);
      }
    });
  }
  focusOn(match, cls, center) {
    return __async(this, null, function* () {
      const view = this.leaf.view;
      if (!(view instanceof import_obsidian8.MarkdownView)) {
        return;
      }
      if (view.getMode() !== "source") {
        return;
      }
      yield this.scrollIntoView(match, center);
      const { editor } = view;
      editor.removeHighlights(cls);
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      editor.addHighlights([range], cls);
    });
  }
  registerExtension(ext) {
    this.extensions.push(ext);
    return this;
  }
};
var fileTypeMap = {
  md: "md",
  png: "image",
  jpg: "image",
  jpeg: "image",
  gif: "image",
  bmp: "image",
  svg: "image",
  webp: "image",
  mp3: "audio",
  webm: "audio",
  wav: "audio",
  m4a: "audio",
  ogg: "audio",
  "3gp": "audio",
  flac: "audio",
  mp4: "movie",
  ogv: "movie",
  pdf: "pdf"
};

// src/interfaces/viewGeneratorExtensions/Excalidraw.ts
var import_obsidian9 = __toModule(require("obsidian"));
var excalidrawPluginId = "obsidian-excalidraw-plugin";
var excalidrawViewType = "excalidraw";
var ExcalidrawViewGeneratorExtension = class {
  constructor(app2) {
    this.app = app2;
    const excalidraw = this.app.plugins.plugins[excalidrawPluginId];
    if (!isExcalidrawPlugin(excalidraw)) {
      this.excalidraw = void 0;
    } else {
      this.excalidraw = excalidraw;
    }
  }
  isMine(leaf) {
    return leaf.view.getViewType() === excalidrawViewType;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      const { excalidraw } = this;
      if (!excalidraw)
        return;
      excalidraw.excalidrawFileModes[leaf.id] = "markdown";
      yield excalidraw.setMarkdownView(leaf);
      if (!(leaf.view instanceof import_obsidian9.MarkdownView))
        return;
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode
      }), {});
      leaf.view.editor.blur();
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      const { excalidraw } = this;
      if (!excalidraw)
        return;
      excalidraw.excalidrawFileModes[leaf.id] = "markdown";
      yield excalidraw.setMarkdownView(leaf);
      if (!(leaf.view instanceof import_obsidian9.MarkdownView))
        return;
      const mode = leaf.view.getMode();
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode: mode === "preview" ? "source" : "preview"
      }), {});
      leaf.view.editor.blur();
    });
  }
};
function isExcalidrawPlugin(plugin2) {
  if (!(plugin2 instanceof import_obsidian9.Plugin))
    return false;
  const { excalidrawFileModes, setMarkdownView } = plugin2;
  if (typeof excalidrawFileModes !== "object")
    return false;
  if (typeof setMarkdownView !== "function")
    return false;
  return true;
}

// src/interfaces/viewGeneratorExtensions/Kanban.ts
var import_obsidian10 = __toModule(require("obsidian"));
var kanbanPluginId = "obsidian-kanban";
var frontMatterKey = "kanban-plugin";
var kanbanViewType = "kanban";
var KanbanViewGeneratorExtension = class {
  constructor(app2) {
    this.app = app2;
    const kanban = this.app.plugins.plugins[kanbanPluginId];
    if (IsKanbanPlugin(kanban)) {
      this.kanban = kanban;
    }
    if (kanban === void 0) {
      this.kanban = void 0;
    }
  }
  isMine(leaf) {
    const { view } = leaf;
    if (view.getViewType() == kanbanViewType)
      return true;
    if (!(view instanceof import_obsidian10.TextFileView))
      return false;
    const fileCache = this.app.metadataCache.getFileCache(view.file);
    const fileIsKanban = !!(fileCache == null ? void 0 : fileCache.frontmatter) && !!fileCache.frontmatter[frontMatterKey];
    return fileIsKanban;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      const { kanban } = this;
      if (!kanban)
        return;
      if (mode === "source") {
        kanban.kanbanFileModes[leaf.id] = "markdown";
        yield kanban.setMarkdownView(leaf);
        yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
          mode: "source"
        }), {});
        if (leaf.view instanceof import_obsidian10.MarkdownView) {
          leaf.view.editor.blur();
        }
      } else {
        kanban.kanbanFileModes[leaf.id] = kanbanViewType;
        yield kanban.setKanbanView(leaf);
      }
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      const { kanban } = this;
      if (!kanban)
        return;
      const mode = kanban.kanbanFileModes[leaf.id];
      yield this.setViewMode(leaf, mode === "markdown" ? "preview" : "source");
    });
  }
};
function IsKanbanPlugin(plugin2) {
  if (!(plugin2 instanceof import_obsidian10.Plugin))
    return false;
  const { kanbanFileModes, setKanbanView, setMarkdownView } = plugin2;
  if (typeof kanbanFileModes !== "object")
    return false;
  if (typeof setMarkdownView !== "function")
    return false;
  if (typeof setKanbanView !== "function")
    return false;
  return true;
}

// src/interfaces/viewGeneratorExtensions/Markdown.ts
var import_obsidian11 = __toModule(require("obsidian"));
var MarkdownViewGeneratorExtension = class {
  isMine(leaf) {
    return leaf.view instanceof import_obsidian11.MarkdownView;
  }
  setViewMode(leaf, mode) {
    return __async(this, null, function* () {
      yield leaf.view.setState(__spreadProps(__spreadValues({}, leaf.view.getState()), {
        mode
      }), {});
    });
  }
  toggleViewMode(leaf) {
    return __async(this, null, function* () {
      if (!(leaf.view instanceof import_obsidian11.MarkdownView))
        return;
      yield this.setViewMode(leaf, leaf.view.getMode() === "preview" ? "source" : "preview");
    });
  }
};

// src/interfaces/viewGeneratorExtensions/NonMarkdown.ts
var import_obsidian12 = __toModule(require("obsidian"));
var NON_MARKDOWN_FILE_TYPES = ["image", "audio", "pdf", "video"];
var NonMarkdownViewGeneratorExtension = class {
  isMine(leaf) {
    if (!(leaf.view instanceof import_obsidian12.FileView))
      return false;
    return NON_MARKDOWN_FILE_TYPES.includes(leaf.view.getViewType());
  }
  setViewMode(_leaf, _mode) {
    return;
  }
  toggleViewMode(_) {
    return;
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/ui/store.ts
var app = writable();
var plugin = writable();

// src/ui/PreviewModalContent.svelte
function add_css3(target) {
  append_styles(target, "svelte-6cqu2r", ".core-search-assistant_preview-modal_view-container.svelte-6cqu2r{min-width:700px}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .highlight-search-match{color:var(--highlight-search-match);background-color:var(--highlight-search-match-bg)}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .focus-search-match{background-color:var(--focus-search-match-bg)}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .workspace-leaf{contain:initial !important}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .view-content{overflow:unset}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .markdown-preview-view{overflow:unset}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .workspace-leaf-content{overflow:unset}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .workspace-leaf-resize-handle{display:none}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .view-header{display:none}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .markdown-preview-view{padding:0}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .markdown-source-view{pointer-events:none}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .workspace-leaf-content[data-type='pdf']{height:990px}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .markdown-source-view.mod-cm6 .cm-editor{flex:initial;display:initial}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .markdown-source-view.mod-cm6{display:initial}.core-search-assistant_preview-modal_view-container.svelte-6cqu2r .markdown-source-view.mod-cm6 .cm-scroller{padding:0}");
}
function create_fragment3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "core-search-assistant_preview-modal_view-container svelte-6cqu2r");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[5](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[5](null);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(7, $app = $$value));
  let { file } = $$props;
  let { matches } = $$props;
  let contentContainerEl;
  let renderer;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    if (!file) {
      return;
    }
    if (!contentContainerEl) {
      return;
    }
    const fileType = fileTypeMap[file.extension];
    if (fileType !== void 0) {
      contentContainerEl.empty();
      renderer = yield new ViewGenerator($app, contentContainerEl, file).registerExtension(new ExcalidrawViewGeneratorExtension($app)).registerExtension(new KanbanViewGeneratorExtension($app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("source");
      highlightMatches();
    }
  }));
  onDestroy(() => {
    setTimeout(() => renderer === null || renderer === void 0 ? void 0 : renderer.unload(), 1e3);
  });
  function toggleViewMode() {
    return __awaiter(this, void 0, void 0, function* () {
      yield renderer === null || renderer === void 0 ? void 0 : renderer.toggleViewMode();
    });
  }
  function focusOn(matchId, center) {
    if (!matches)
      return;
    const match = matches[matchId];
    if (match === void 0) {
      return;
    }
    renderer === null || renderer === void 0 ? void 0 : renderer.focusOn(match, "focus-search-match", center);
  }
  function highlightMatches() {
    renderer === null || renderer === void 0 ? void 0 : renderer.highlightMatches(matches !== null && matches !== void 0 ? matches : [], "highlight-search-match");
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentContainerEl = $$value;
      $$invalidate(0, contentContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("matches" in $$props2)
      $$invalidate(2, matches = $$props2.matches);
  };
  return [contentContainerEl, file, matches, toggleViewMode, focusOn, div_binding];
}
var PreviewModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      file: 1,
      matches: 2,
      toggleViewMode: 3,
      focusOn: 4
    }, add_css3);
  }
  get toggleViewMode() {
    return this.$$.ctx[3];
  }
  get focusOn() {
    return this.$$.ctx[4];
  }
};
var PreviewModalContent_default = PreviewModalContent;

// src/components/PreviewModal.ts
var SCROLL_AMOUNT = 70;
var PreviewModal = class extends import_obsidian13.Modal {
  constructor(app2, plugin2, modeScope, item) {
    super(app2);
    this.plugin = plugin2;
    this.modeScope = modeScope;
    this.item = item;
    this.currentFocus = -1;
  }
  onOpen() {
    return __async(this, null, function* () {
      var _a;
      yield this.renderView();
      this.modeScope.push();
      const hotkeyMap = (_a = this.plugin.settings) == null ? void 0 : _a.previewModalHotkeys;
      if (!hotkeyMap)
        return;
      hotkeyMap.closeModal.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.shouldRestoreSelection = true;
          this.close();
        });
      });
      hotkeyMap.open.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          var _a2;
          this.openAndFocus(this.currentFocus);
          (_a2 = this.plugin.controller) == null ? void 0 : _a2.exit();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.openInNewPage.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          var _a2, _b;
          this.openAndFocus(this.currentFocus, (_a2 = this.plugin.settings) == null ? void 0 : _a2.splitDirection);
          (_b = this.plugin.controller) == null ? void 0 : _b.exit();
          this.shouldRestoreSelection = false;
          this.close();
        });
      });
      hotkeyMap.bigScrollDown.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("down");
        });
      });
      hotkeyMap.bigScrollUp.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("up");
        });
      });
      hotkeyMap.scrollDown.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("down", SCROLL_AMOUNT);
        });
      });
      hotkeyMap.scrollUp.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          this.scroll("up", SCROLL_AMOUNT);
        });
      });
      hotkeyMap.focusNext.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          var _a2;
          evt.preventDefault();
          const numMatches = this.countMatches();
          if (numMatches === void 0 || numMatches === 0) {
            return;
          }
          this.currentFocus = cyclicId(++this.currentFocus, numMatches);
          (_a2 = this.previewContent) == null ? void 0 : _a2.focusOn(this.currentFocus, true);
        });
      });
      hotkeyMap.focusPrevious.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          var _a2;
          evt.preventDefault();
          const numMatches = this.countMatches();
          if (numMatches === void 0 || numMatches === 0) {
            return;
          }
          this.currentFocus = cyclicId(--this.currentFocus, numMatches);
          (_a2 = this.previewContent) == null ? void 0 : _a2.focusOn(this.currentFocus, true);
        });
      });
      hotkeyMap.togglePreviewMode.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, (evt) => {
          (() => __async(this, null, function* () {
            var _a2;
            evt.preventDefault();
            yield (_a2 = this.previewContent) == null ? void 0 : _a2.toggleViewMode();
          }))();
        });
      });
      hotkeyMap.copyLink.forEach((hotkey) => {
        this.scope.register(hotkey.modifiers, hotkey.key, () => {
          const { file } = this.item;
          const internalLink = generateInternalLinkFrom(this.app, file);
          navigator.clipboard.writeText(internalLink);
          new import_obsidian13.Notice("Copy wiki link!");
        });
      });
    });
  }
  onClose() {
    var _a;
    (_a = this.previewContent) == null ? void 0 : _a.$destroy();
    setTimeout(() => {
      if (this.modeScope.depth > 1) {
        this.modeScope.pop();
      }
    }, 100);
  }
  renderView() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      contentEl.hide();
      this.previewContent = new PreviewModalContent_default({
        target: contentEl,
        props: {
          file: this.item.file,
          matches: this.item.result.content
        }
      });
      contentEl.show();
    });
  }
  countMatches() {
    var _a;
    return (_a = this.item.result.content) == null ? void 0 : _a.length;
  }
  scroll(direction, px) {
    const { containerEl, contentEl } = this;
    const move = (px != null ? px : containerEl.clientHeight / 2) * (direction === "up" ? -1 : 1);
    contentEl.scrollBy({
      top: move,
      behavior: "smooth"
    });
  }
  openAndFocus(matchId, direction) {
    return __async(this, null, function* () {
      var _a, _b;
      const { item } = this;
      const leaf = direction === void 0 ? this.app.workspace.getMostRecentLeaf() : this.app.workspace.splitActiveLeaf(direction);
      yield leaf.openFile(item.file);
      this.app.workspace.setActiveLeaf(leaf, true, true);
      const match = (_b = (_a = item == null ? void 0 : item.result) == null ? void 0 : _a.content) == null ? void 0 : _b[matchId];
      if (!match) {
        return;
      }
      const { view } = leaf;
      if (!(view instanceof import_obsidian13.MarkdownView)) {
        return;
      }
      const editor = view.editor;
      const range = {
        from: editor.offsetToPos(match[0]),
        to: editor.offsetToPos(match[1])
      };
      editor.addHighlights([range], "obsidian-search-match-highlight");
      const iter = scrollIteration(editor);
      if (iter === void 0) {
        return;
      }
      for (let i = 0; i < iter; i++) {
        editor.scrollIntoView(range, true);
      }
      editor.setCursor(range.from);
    });
  }
};
function cyclicId(id, total) {
  return (id % total + total) % total;
}

// src/ModeScope.ts
var ModeScope = class {
  constructor() {
    this._depth = 0;
  }
  get inSearchMode() {
    return this._depth > 0;
  }
  get depth() {
    return this._depth;
  }
  push() {
    this._depth++;
  }
  pop() {
    this._depth--;
    if (this.depth < 0) {
      throw "[ERROR in Core Search Assistant] ModeScope.depth < 0";
    }
  }
  reset() {
    this._depth = 0;
  }
};

// src/Controller.ts
var import_obsidian14 = __toModule(require("obsidian"));

// src/ui/CardContainer.svelte
function add_css4(target) {
  append_styles(target, "svelte-1g7kfgn", ".core-search-assistant_card-container.svelte-1g7kfgn.svelte-1g7kfgn{overflow:hidden;display:flex;flex-direction:column;height:100%;position:relative;box-shadow:0 2px 5px rgba(0, 0, 0, 0.2);border-radius:10px;cursor:pointer;background-color:var(--background-primary);box-sizing:content-box}.core-search-assistant_card-container.svelte-1g7kfgn.svelte-1g7kfgn:hover{border:5px solid var(--interactive-accent);margin:-5px}.core-search-assistant_card-container.is-selected.svelte-1g7kfgn.svelte-1g7kfgn{border:5px solid var(--interactive-accent);margin:-5px}.card-container-header.svelte-1g7kfgn.svelte-1g7kfgn{padding:5px 10px;background-color:var(--background-secondary);display:flex;color:var(--text-muted)}.file-name-container.svelte-1g7kfgn.svelte-1g7kfgn{font-size:1rem;line-height:1.2rem;overflow-wrap:break-word;min-width:0;flex:1}.file-name-container.svelte-1g7kfgn span.matched-in-path{color:var(--text-normal);font-weight:bold}.content-container-wrapper.svelte-1g7kfgn.svelte-1g7kfgn{padding:5px;flex:1;height:100%;min-height:0}.content-container.svelte-1g7kfgn.svelte-1g7kfgn{overflow:hidden;height:100%;font-size:0.8rem;line-height:1.2}.content-container.svelte-1g7kfgn div.content-not-supported-file-format.svelte-1g7kfgn{font-size:1rem;color:var(--text-muted)}.content-container.svelte-1g7kfgn p{font-size:0.8rem;line-height:1.2}.content-container.svelte-1g7kfgn code{font-size:0.8rem;line-height:1.2}.content-container.svelte-1g7kfgn div{font-size:0.8rem}.content-container.svelte-1g7kfgn li{font-size:0.8rem;line-height:1.2}.content-container.svelte-1g7kfgn h1{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-1g7kfgn h2{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-1g7kfgn h3{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-1g7kfgn h4{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-1g7kfgn h5{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-1g7kfgn h6{font-size:1rem;line-height:1.2;margin:5px}.content-container.svelte-1g7kfgn a{pointer-events:none}.content-container.svelte-1g7kfgn .workspace-leaf{contain:initial !important;height:100%}.content-container.svelte-1g7kfgn .workspace-leaf-resize-handle{display:none}.content-container.svelte-1g7kfgn .view-header{display:none}.content-container.svelte-1g7kfgn .view-content{flex:1;overflow:hidden}.content-container.svelte-1g7kfgn .markdown-preview-view{padding:0;overflow:hidden}.content-container.svelte-1g7kfgn .modal-content{margin:0}");
}
function create_fragment4(ctx) {
  let div5;
  let div1;
  let div0;
  let t0;
  let div4;
  let div3;
  let div2;
  let t1_value = `${ctx[1].extension.toUpperCase()} file`;
  let t1;
  let div5_data_path_value;
  let mounted;
  let dispose;
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      t1 = text(t1_value);
      attr(div0, "class", "file-name-container svelte-1g7kfgn");
      attr(div1, "class", "card-container-header svelte-1g7kfgn");
      attr(div2, "class", "content-not-supported-file-format svelte-1g7kfgn");
      attr(div3, "class", "content-container svelte-1g7kfgn");
      attr(div4, "class", "content-container-wrapper svelte-1g7kfgn");
      attr(div5, "class", "core-search-assistant_card-container svelte-1g7kfgn");
      attr(div5, "data-id", ctx[0]);
      attr(div5, "data-path", div5_data_path_value = ctx[1].path);
      toggle_class(div5, "is-selected", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, div0);
      ctx[8](div0);
      append(div5, t0);
      append(div5, div4);
      append(div4, div3);
      append(div3, div2);
      append(div2, t1);
      ctx[9](div3);
      if (!mounted) {
        dispose = listen(div5, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && t1_value !== (t1_value = `${ctx2[1].extension.toUpperCase()} file`))
        set_data(t1, t1_value);
      if (dirty & 1) {
        attr(div5, "data-id", ctx2[0]);
      }
      if (dirty & 2 && div5_data_path_value !== (div5_data_path_value = ctx2[1].path)) {
        attr(div5, "data-path", div5_data_path_value);
      }
      if (dirty & 4) {
        toggle_class(div5, "is-selected", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div5);
      ctx[8](null);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
}
function renderFileName(fileName, containerEl) {
  containerEl.appendText(fileName);
}
function instance4($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(11, $app = $$value));
  let { id } = $$props;
  let { file } = $$props;
  let { selected } = $$props;
  let { focusEl } = $$props;
  let contentContainerEl;
  let fileNameContainerEl;
  let renderer;
  const dispatch = createEventDispatcher();
  function path() {
    return file.path;
  }
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    if (!fileNameContainerEl) {
      return;
    }
    renderFileName(file.name, fileNameContainerEl);
    if (!contentContainerEl) {
      return;
    }
    const fileType = fileTypeMap[file.extension];
    if (fileType !== void 0) {
      contentContainerEl.empty();
      renderer = yield new ViewGenerator($app, contentContainerEl, file).registerExtension(new ExcalidrawViewGeneratorExtension($app)).registerExtension(new KanbanViewGeneratorExtension($app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("preview");
    }
    focusEl === null || focusEl === void 0 ? void 0 : focusEl.focus();
  }));
  onDestroy(() => {
    setTimeout(() => renderer === null || renderer === void 0 ? void 0 : renderer.unload(), 1e3);
  });
  function onClicked() {
    return __awaiter(this, void 0, void 0, function* () {
      yield openFile();
      dispatch("click");
    });
  }
  function openFile() {
    return __awaiter(this, void 0, void 0, function* () {
      const leaf = $app.workspace.getMostRecentLeaf();
      yield leaf.openFile(file);
      $app.workspace.setActiveLeaf(leaf, true, true);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileNameContainerEl = $$value;
      $$invalidate(4, fileNameContainerEl);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentContainerEl = $$value;
      $$invalidate(3, contentContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("selected" in $$props2)
      $$invalidate(2, selected = $$props2.selected);
    if ("focusEl" in $$props2)
      $$invalidate(6, focusEl = $$props2.focusEl);
  };
  return [
    id,
    file,
    selected,
    contentContainerEl,
    fileNameContainerEl,
    onClicked,
    focusEl,
    path,
    div0_binding,
    div3_binding
  ];
}
var CardContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      id: 0,
      file: 1,
      selected: 2,
      focusEl: 6,
      path: 7
    }, add_css4);
  }
  get path() {
    return this.$$.ctx[7];
  }
};
var CardContainer_default = CardContainer;

// src/ui/CardViewComponent.svelte
function add_css5(target) {
  append_styles(target, "svelte-pwex1j", ".card-view-container.svelte-pwex1j{position:absolute;top:0;left:0;width:100%;height:100%;z-index:var(--layer-modal);padding:20px 30px;display:flex;justify-content:center}.card-view-background.svelte-pwex1j{position:absolute;top:0;left:0;width:100%;height:100%;background-color:var(--background-modifier-cover)}.cards-container.svelte-pwex1j{display:grid;grid-gap:20px;height:100%;width:100%;min-height:0}");
}
function create_fragment5(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      attr(div0, "class", "card-view-background svelte-pwex1j");
      attr(div1, "class", "cards-container svelte-pwex1j");
      attr(div2, "class", "card-view-container svelte-pwex1j");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t);
      append(div2, div1);
      ctx[10](div1);
      if (!mounted) {
        dispose = listen(div0, "click", ctx[9]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function cardsPerPage(layout) {
  if (!checkLayout(layout))
    return 0;
  return layout[0] * layout[1];
}
function setLayout(contentEl, layout) {
  if (!contentEl)
    return;
  if (!checkLayout(layout))
    return;
  contentEl.style.gridTemplateColumns = `repeat(${layout[1]}, minmax(0, 1fr))`;
  contentEl.style.gridTemplateRows = `repeat(${layout[0]}, 1fr)`;
}
function checkLayout(layout) {
  const check = (x) => Number.isInteger(x) && x > 0;
  return check(layout[0]) && check(layout[1]);
}
function instance5($$self, $$props, $$invalidate) {
  let { layout } = $$props;
  let { focusEl } = $$props;
  let contentEl;
  let cards = [];
  const dispatcher = createEventDispatcher();
  function addCard(file) {
    if (!contentEl)
      return;
    if (!focusEl)
      return;
    if (cards.length >= cardsPerPage(layout))
      return;
    const card = new CardContainer_default({
      target: contentEl,
      props: {
        file,
        id: cards.length,
        selected: false,
        focusEl
      }
    });
    cards.push(card);
  }
  function renderPage(files) {
    files.forEach((file) => {
      addCard(file);
    });
  }
  function focusOn(id) {
    const pos = id % cardsPerPage(layout);
    [-1, 0, 1].forEach((i) => {
      const card = cards[pos + i];
      if (!card)
        return;
      if (i == 0) {
        card.$set({ selected: true });
      } else {
        card.$set({ selected: false });
      }
    });
  }
  function detachCards() {
    cards.forEach((card) => {
      card.$destroy();
    });
    cards = [];
  }
  function checkCardsRenderedCorrectly(files) {
    if (!checkLayout(layout))
      return false;
    for (let i = 0; i < cardsPerPage(layout); i++) {
      const file = files[i];
      const card = cards[i];
      if ((file === null || file === void 0 ? void 0 : file.path) !== (card === null || card === void 0 ? void 0 : card.path())) {
        return false;
      }
    }
    return true;
  }
  onMount(() => {
    setLayout(contentEl, layout);
  });
  onDestroy(() => {
    detachCards();
  });
  const click_handler = () => {
    dispatcher("should-destroy");
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(0, contentEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("layout" in $$props2)
      $$invalidate(2, layout = $$props2.layout);
    if ("focusEl" in $$props2)
      $$invalidate(3, focusEl = $$props2.focusEl);
  };
  return [
    contentEl,
    dispatcher,
    layout,
    focusEl,
    addCard,
    renderPage,
    focusOn,
    detachCards,
    checkCardsRenderedCorrectly,
    click_handler,
    div1_binding
  ];
}
var CardViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      layout: 2,
      focusEl: 3,
      addCard: 4,
      renderPage: 5,
      focusOn: 6,
      detachCards: 7,
      checkCardsRenderedCorrectly: 8
    }, add_css5);
  }
  get addCard() {
    return this.$$.ctx[4];
  }
  get renderPage() {
    return this.$$.ctx[5];
  }
  get focusOn() {
    return this.$$.ctx[6];
  }
  get detachCards() {
    return this.$$.ctx[7];
  }
  get checkCardsRenderedCorrectly() {
    return this.$$.ctx[8];
  }
};
var CardViewComponent_default = CardViewComponent;

// src/ui/WorkspacePreview.svelte
function add_css6(target) {
  append_styles(target, "svelte-1fata0e", ".core-search-assistant_workspace-preview_container.svelte-1fata0e{position:absolute;top:0;left:0;width:100%;height:100%;z-index:var(--layer-modal);background-color:var(--background-primary);padding:20px 30px;overflow:auto}.core-search-assistant_workspace-preview_container.svelte-1fata0e .highlight-search-match{color:var(--highlight-search-match);background-color:var(--highlight-search-match-bg)}.core-search-assistant_workspace-preview_container.svelte-1fata0e .focus-search-match{background-color:var(--focus-search-match-bg)}.core-search-assistant_workspace-preview_container.svelte-1fata0e .workspace-leaf{contain:initial !important;height:100%}.core-search-assistant_workspace-preview_container.svelte-1fata0e .workspace-leaf-resize-handle{display:none}.core-search-assistant_workspace-preview_container.svelte-1fata0e .view-header{display:none}.core-search-assistant_workspace-preview_container.svelte-1fata0e .view-content{overflow:hidden}.core-search-assistant_workspace-preview_container.svelte-1fata0e .markdown-preview-view{padding:0}.core-search-assistant_workspace-preview_container.svelte-1fata0e .modal-content{margin:0}.core-search-assistant_workspace-preview_container.svelte-1fata0e .markdown-source-view.mod-cm6 .cm-editor{flex:initial;display:initial}.core-search-assistant_workspace-preview_container.svelte-1fata0e .markdown-source-view.mod-cm6{display:initial}.core-search-assistant_workspace-preview_container.svelte-1fata0e .markdown-source-view{pointer-events:none}.core-search-assistant_workspace-preview_container.svelte-1fata0e .markdown-source-view.mod-cm6 .cm-scroller{padding:0}");
}
function create_fragment6(ctx) {
  let div1;
  let div0;
  let t_value = `${ctx[0].extension.toUpperCase()} file`;
  let t;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      attr(div0, "class", "content-not-supported-file-format");
      attr(div1, "class", "core-search-assistant_workspace-preview_container svelte-1fata0e");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t);
      ctx[4](div1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t_value !== (t_value = `${ctx2[0].extension.toUpperCase()} file`))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[4](null);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(6, $app = $$value));
  let { file } = $$props;
  let { matches } = $$props;
  let { focusEl } = $$props;
  let containerEl;
  let renderer;
  onMount(() => __awaiter(void 0, void 0, void 0, function* () {
    if (!containerEl)
      return;
    const fileType = fileTypeMap[file.extension];
    if (fileType !== void 0) {
      containerEl.empty();
      renderer = yield new ViewGenerator($app, containerEl, file).registerExtension(new ExcalidrawViewGeneratorExtension($app)).registerExtension(new KanbanViewGeneratorExtension($app)).registerExtension(new MarkdownViewGeneratorExtension()).registerExtension(new NonMarkdownViewGeneratorExtension()).load("source");
      highlightMatches();
    }
    focusEl === null || focusEl === void 0 ? void 0 : focusEl.focus();
  }));
  onDestroy(() => {
    setTimeout(() => renderer === null || renderer === void 0 ? void 0 : renderer.unload(), 1e3);
  });
  function highlightMatches() {
    renderer === null || renderer === void 0 ? void 0 : renderer.highlightMatches(matches !== null && matches !== void 0 ? matches : [], "highlight-search-match");
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(1, containerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(0, file = $$props2.file);
    if ("matches" in $$props2)
      $$invalidate(2, matches = $$props2.matches);
    if ("focusEl" in $$props2)
      $$invalidate(3, focusEl = $$props2.focusEl);
  };
  return [file, containerEl, matches, focusEl, div1_binding];
}
var WorkspacePreview = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { file: 0, matches: 2, focusEl: 3 }, add_css6);
  }
};
var WorkspacePreview_default = WorkspacePreview;

// src/ui/Outline.svelte
function add_css7(target) {
  append_styles(target, "svelte-f5i2qg", ".outline-container.svelte-f5i2qg{position:absolute;top:0;left:0;width:100%;height:100%;z-index:var(--layer-modal);pointer-events:none}");
}
function create_fragment7(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "outline-container svelte-f5i2qg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[2](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[2](null);
    }
  };
}
var STYLE_VAR_COLOR_SEARCH_MODE_OUTLINE = "--search-mode-outline";
function instance7($$self, $$props, $$invalidate) {
  let { lineWidth } = $$props;
  let el;
  onMount(() => {
    if (!el)
      return;
    $$invalidate(0, el.style.outline = `${lineWidth}px solid var(${STYLE_VAR_COLOR_SEARCH_MODE_OUTLINE})`, el);
    $$invalidate(0, el.style.outlineOffset = `-${lineWidth}px`, el);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("lineWidth" in $$props2)
      $$invalidate(1, lineWidth = $$props2.lineWidth);
  };
  return [el, lineWidth, div_binding];
}
var Outline = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { lineWidth: 1 }, add_css7);
  }
};
var Outline_default = Outline;

// src/Controller.ts
var DELAY_TO_RELOAD_IN_MILLISECOND = 1e3;
var RETRY_INTERVAL = 1;
var RETRY_TRIALS = 1e3;
var DELAY_TO_RENDER_CARD_VIEW_ON_ENTRY_IN_MILLISECOND = 100;
var Controller = class extends obsidian.Component {
  constructor(app2, plugin2, events, searchInterface) {
    super();
    this.app = app2;
    this.plugin = plugin2;
    this.events = events;
    this.searchInterface = searchInterface;
    this.modeScope = new ModeScope();
    this.cardViewCheckDebouncer = (0, import_obsidian14.debounce)(this.onCheckCardView, DELAY_TO_RELOAD_IN_MILLISECOND, true);
    this.countSearchItemDetected = 0;
  }
  onunload() {
    this.exit();
  }
  onload() {
    this.saveLayout();
    this.setSearchModeTriggers();
  }
  enter() {
    return __async(this, null, function* () {
      var _a, _b;
      if (this.modeScope.inSearchMode) {
        return;
      }
      this.setHotkeys();
      this.addChildren();
      if ((_a = this.plugin.settings) == null ? void 0 : _a.autoToggleSidebar) {
        this.collapseOppositeSidedock();
      }
      const shouldDetectSearchItems = ((_b = this.plugin.settings) == null ? void 0 : _b.autoPreviewMode) === "cardView" && this.plugin.settings.renderCardsManually === false;
      if (shouldDetectSearchItems) {
        this.searchInterface.startWatching(this.events);
        yield delay(DELAY_TO_RENDER_CARD_VIEW_ON_ENTRY_IN_MILLISECOND);
        this.renewCardViewPage();
        this.cardViewCheckDebouncer();
      }
      this.modeScope.push();
    });
  }
  reset() {
    var _a;
    if (!this.modeScope.inSearchMode) {
      return;
    }
    this.forget();
    this.unfocus();
    (_a = this.cardViewComponent) == null ? void 0 : _a.detachCards();
    this.countSearchItemDetected = 0;
  }
  exit(reason) {
    var _a;
    if (!this.modeScope.inSearchMode) {
      return;
    }
    this.reset();
    this.detachHotkeys();
    this.removeChildren();
    if (this.shouldCollapseSidedock(reason)) {
      this.collapseSidedock();
    }
    if ((_a = this.plugin.settings) == null ? void 0 : _a.autoToggleSidebar) {
      this.restoreOppositeSidedock();
    }
    this.countSearchItemDetected = 0;
    this.searchInterface.stopWatching();
    this.unfocus();
    this.modeScope.reset();
  }
  focus() {
    var _a;
    if (this.currentFocusId === void 0) {
      return;
    }
    this.searchInterface.focusOn(this.currentFocusId);
    (_a = this.cardViewComponent) == null ? void 0 : _a.focusOn(this.currentFocusId);
  }
  open(direction) {
    if (this.currentFocusId === void 0) {
      return;
    }
    this.searchInterface.open(this.currentFocusId, direction);
  }
  renewCardViewPage() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) !== "cardView")
        return;
      (_b = this.cardViewComponent) == null ? void 0 : _b.detachCards();
      (_c = this.cardViewComponent) == null ? void 0 : _c.renderPage(this.filesToBeRendered());
      if (this.currentFocusId !== void 0) {
        (_e = this.cardViewComponent) == null ? void 0 : _e.focusOn((_d = this.currentFocusId) != null ? _d : 0);
      }
    });
  }
  filesToBeRendered() {
    var _a, _b;
    const cardsPerPage2 = this.cardsPerPage();
    if (cardsPerPage2 === void 0) {
      return [];
    }
    const pageId = Math.floor(((_a = this.currentFocusId) != null ? _a : 0) / cardsPerPage2);
    const items = (_b = this.plugin.searchInterface) == null ? void 0 : _b.resultItems;
    if (!items)
      return [];
    return items.slice(pageId * cardsPerPage2).map((item) => item.file);
  }
  collapseSidedock() {
    var _a;
    (_a = this.plugin.searchInterface) == null ? void 0 : _a.collapseSidedock();
  }
  collapseOppositeSidedock() {
    var _a, _b, _c;
    const collapsed = (_b = (_a = this.plugin.searchInterface) == null ? void 0 : _a.oppositeSidedock) == null ? void 0 : _b.collapsed;
    (_c = this.plugin.searchInterface) == null ? void 0 : _c.collapseOppositeSidedock();
    this._restoreOppositeSidedock = () => {
      var _a2;
      if (collapsed === false) {
        (_a2 = this.plugin.searchInterface) == null ? void 0 : _a2.expandOppositeSidedock();
      }
    };
  }
  restoreOppositeSidedock() {
    const restoreOppositeSidedock = this._restoreOppositeSidedock;
    if (restoreOppositeSidedock === void 0) {
      return void 0;
    }
    return restoreOppositeSidedock();
  }
  addChildren() {
    this.removeChildren();
    const { settings } = this.plugin;
    if (settings === void 0) {
      throw "[ERROR in Core Search Assistant] failed to addChildren: failed to read setting";
    }
    this.outline = new Outline_default({
      target: document.body,
      props: {
        lineWidth: settings.outlineWidth
      }
    });
    if (settings.autoPreviewMode === "cardView") {
      this.renewCardViewComponent();
    }
  }
  removeChildren() {
    var _a, _b, _c;
    (_a = this.outline) == null ? void 0 : _a.$destroy();
    this.outline = void 0;
    (_b = this.cardViewComponent) == null ? void 0 : _b.$destroy();
    this.cardViewComponent = void 0;
    (_c = this.workspacePreviewComponent) == null ? void 0 : _c.$destroy();
    this.workspacePreviewComponent = void 0;
  }
  forget() {
    this.currentFocusId = void 0;
    this.countSearchItemDetected = 0;
  }
  navigateForward() {
    var _a;
    let updated = true;
    const numResults = (_a = this.searchInterface.count()) != null ? _a : 0;
    if (this.currentFocusId === void 0) {
      this.currentFocusId = 0;
    } else {
      this.currentFocusId++;
      if (this.currentFocusId >= numResults) {
        this.currentFocusId = numResults - 1;
        updated = false;
      }
    }
    if (!updated)
      return;
    const { settings } = this.plugin;
    if (!settings)
      return;
    if (settings.autoPreviewMode === "cardView" && this.shouldTransitNextPageInCardView()) {
      this.renewCardViewPage();
    } else if (settings.autoPreviewMode === "singleView") {
      this.renewWorkspacePreviewComponent();
    }
    this.focus();
  }
  navigateBack() {
    if (this.currentFocusId === void 0) {
      return;
    }
    let updated = true;
    this.currentFocusId--;
    if (this.currentFocusId < 0) {
      this.currentFocusId = 0;
      updated = false;
    }
    if (!updated)
      return;
    const { settings } = this.plugin;
    if (!settings)
      return;
    if (settings.autoPreviewMode === "cardView" && this.shouldTransitPreviousPageInCardView()) {
      this.renewCardViewPage();
    } else if (settings.autoPreviewMode === "singleView") {
      this.renewWorkspacePreviewComponent();
    }
    this.focus();
  }
  moveToNextPage() {
    const pageId = this.pageId;
    if (pageId === void 0)
      return;
    const pageCount = this.pageCount;
    if (pageCount === void 0)
      return;
    if (pageId >= pageCount - 1)
      return;
    const cardsPerPage2 = this.cardsPerPage();
    if (cardsPerPage2 === void 0)
      return;
    this.currentFocusId = cardsPerPage2 * (pageId + 1);
    this.renewCardViewPage();
    this.focus();
  }
  moveToPreviousPage() {
    const pageId = this.pageId;
    if (pageId === void 0)
      return;
    const pageCount = this.pageCount;
    if (pageCount === void 0)
      return;
    if (pageId <= 0)
      return;
    const cardsPerPage2 = this.cardsPerPage();
    if (cardsPerPage2 === void 0)
      return;
    this.currentFocusId = cardsPerPage2 * (pageId - 1);
    this.renewCardViewPage();
    this.focus();
  }
  unfocus() {
    this.searchInterface.unfocus();
  }
  openPreviewModal() {
    const { currentFocusId } = this;
    if (currentFocusId === void 0) {
      return;
    }
    const item = this.searchInterface.getResultItemAt(currentFocusId);
    if (!item) {
      return;
    }
    new PreviewModal(this.app, this.plugin, this.modeScope, item).open();
  }
  shouldTransitNextPageInCardView() {
    if (this.currentFocusId === void 0 || this.currentFocusId === 0) {
      return false;
    }
    if (!this.plugin.settings) {
      return false;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    const cardsPerPage2 = row * column;
    return this.currentFocusId % cardsPerPage2 === 0;
  }
  shouldTransitPreviousPageInCardView() {
    if (!this.plugin.settings) {
      return false;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    const cardsPerPage2 = row * column;
    if (this.currentFocusId === void 0) {
      return false;
    }
    return (this.currentFocusId + 1) % cardsPerPage2 === 0;
  }
  get pageId() {
    if (this.currentFocusId === void 0)
      return void 0;
    const cardsPerPage2 = this.cardsPerPage();
    if (cardsPerPage2 === void 0)
      return void 0;
    const pageId = Math.floor(this.currentFocusId / cardsPerPage2);
    return pageId;
  }
  get pageCount() {
    var _a;
    const numResults = (_a = this.plugin.searchInterface) == null ? void 0 : _a.count();
    const cardsPerPage2 = this.cardsPerPage();
    if (cardsPerPage2 === void 0)
      return void 0;
    const pageCount = Math.ceil((numResults != null ? numResults : 0) / cardsPerPage2);
    return pageCount;
  }
  cardsPerPage() {
    if (!this.plugin.settings) {
      return void 0;
    }
    const [row, column] = parseCardLayout(this.plugin.settings.cardViewLayout);
    return row * column;
  }
  saveLayout() {
    this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
      const inputEl = yield retry(() => this.searchInterface.searchInputEl, RETRY_INTERVAL, RETRY_TRIALS);
      this._layoutChanged = () => __async(this, null, function* () {
        return inputEl !== (yield retry(() => this.searchInterface.searchInputEl, RETRY_INTERVAL, RETRY_TRIALS));
      });
    }));
  }
  layoutChanged() {
    return __async(this, null, function* () {
      var _a;
      const shouldRenewController = yield (_a = this._layoutChanged) == null ? void 0 : _a.call(this);
      if (shouldRenewController === void 0) {
        throw "[ERROR in Core Search Assistant] failed to renewRequired: saveLayout was not called.";
      }
      return shouldRenewController;
    });
  }
  setSearchModeTriggers() {
    this.registerEvent(this.events.on(EVENT_SEARCH_RESULT_ITEM_DETECTED, this.onSearchResultItemDetected));
    this.registerEvent(this.events.on(EVENT_SORT_ORDER_CHANGED, this.onSortOrderChanged));
    this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
      const appContainerEl = yield retry(() => this.app.dom.appContainerEl, RETRY_INTERVAL, RETRY_TRIALS);
      if (appContainerEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the app container element";
      }
      const inputEl = yield retry(() => {
        var _a;
        return (_a = this.plugin.searchInterface) == null ? void 0 : _a.searchInputEl;
      }, RETRY_INTERVAL, RETRY_TRIALS);
      if (inputEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the search input form.";
      }
      const matchingCaseButtonEl = yield retry(() => {
        var _a;
        return (_a = this.plugin.searchInterface) == null ? void 0 : _a.matchingCaseButtonEl;
      }, RETRY_INTERVAL, RETRY_TRIALS);
      if (matchingCaseButtonEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the matching case button.";
      }
      this.registerDomEvent(appContainerEl, "click", (evt) => {
        var _a, _b, _c, _d, _e;
        const targetEl = evt.target;
        if (!(targetEl instanceof HTMLElement)) {
          return;
        }
        if ((_b = (_a = this.plugin.searchInterface) == null ? void 0 : _a.searchLeaf) == null ? void 0 : _b.containerEl.contains(targetEl)) {
          if (!this.plugin.searchInterface.isBuiltInElementToOpenFile(targetEl))
            return;
        }
        if ((_d = (_c = this.plugin.searchInterface) == null ? void 0 : _c.tabHeaderEl) == null ? void 0 : _d.contains(targetEl)) {
          return;
        }
        if ((_e = this.plugin.searchInterface) == null ? void 0 : _e.isShowMoreContextButton(targetEl)) {
          return;
        }
        if (this.modeScope.depth === 1) {
          this.exit({ id: "mouse", event: evt });
        }
      });
      this.registerDomEvent(matchingCaseButtonEl, "click", () => {
        if (this.modeScope.inSearchMode) {
          this.reset();
        }
      });
      this.registerDomEvent(inputEl, "input", () => {
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
        this.reset();
      });
      this.registerDomEvent(inputEl, "keypress", (evt) => {
        if (evt.key !== "Enter") {
          return;
        }
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
        this.reset();
      });
      this.registerDomEvent(inputEl, "focus", () => {
        if (!this.modeScope.inSearchMode) {
          this.enter();
        }
      });
    }));
  }
  setHotkeys() {
    var _a;
    const hotkeyMap = (_a = this.plugin.settings) == null ? void 0 : _a.searchModeHotkeys;
    if (!hotkeyMap)
      return;
    const scope = new obsidian.Scope();
    this.app.keymap.pushScope(scope);
    hotkeyMap.selectNext.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        evt.preventDefault();
        this.navigateForward();
      });
    });
    hotkeyMap.selectPrevious.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        evt.preventDefault();
        this.navigateBack();
      });
    });
    hotkeyMap.open.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        evt.preventDefault();
        this.open();
        this.exit();
      });
    });
    hotkeyMap.openInNewPane.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, (evt) => {
        var _a2;
        evt.preventDefault();
        this.open((_a2 = this.plugin.settings) == null ? void 0 : _a2.splitDirection);
        this.exit();
      });
    });
    hotkeyMap.previewModal.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        if (this.app.vault.config.legacyEditor) {
          return;
        }
        this.openPreviewModal();
      });
    });
    hotkeyMap.showOptions.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        new OptionModal(this.app, this.plugin, this.modeScope).open();
      });
    });
    hotkeyMap.nextPage.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        var _a2;
        if (((_a2 = this.plugin.settings) == null ? void 0 : _a2.autoPreviewMode) === "cardView") {
          this.moveToNextPage();
        }
      });
    });
    hotkeyMap.previousPage.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        var _a2;
        if (((_a2 = this.plugin.settings) == null ? void 0 : _a2.autoPreviewMode) === "cardView") {
          this.moveToPreviousPage();
        }
      });
    });
    hotkeyMap.copyLink.forEach((hotkey) => {
      scope.register(hotkey.modifiers, hotkey.key, () => {
        var _a2;
        const item = this.searchInterface.getResultItemAt((_a2 = this.currentFocusId) != null ? _a2 : 0);
        if (!item)
          return;
        const { file } = item;
        const internalLink = generateInternalLinkFrom(this.app, file);
        navigator.clipboard.writeText(internalLink);
        new import_obsidian14.Notice("Copy wiki link!");
      });
    });
    scope.register([], "Escape", (evt) => {
      evt.preventDefault();
      this.exit();
    });
    scope.register([], "Enter", (evt) => {
      var _a2;
      setTimeout(this.focusOnInput, 100);
      const shouldRenderCardsManually = ((_a2 = this.plugin.settings) == null ? void 0 : _a2.autoPreviewMode) === "cardView" && this.plugin.settings.renderCardsManually;
      if (shouldRenderCardsManually) {
        evt.preventDefault();
        this.reset();
        this.renewCardViewPage();
      }
    });
    this._detachHotkeys = () => {
      this.app.keymap.popScope(scope);
    };
  }
  detachHotkeys() {
    const detachHotkeys = this._detachHotkeys;
    if (detachHotkeys === void 0) {
      return;
    }
    detachHotkeys();
  }
  get onSearchResultItemDetected() {
    return () => {
      var _a, _b, _c;
      if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) !== "cardView") {
        return;
      }
      if (this.currentFocusId !== void 0) {
        return;
      }
      if (this.countSearchItemDetected === 0) {
        (_b = this.cardViewComponent) == null ? void 0 : _b.detachCards();
      }
      const item = this.searchInterface.getResultItemAt(this.countSearchItemDetected);
      if (!item)
        return;
      (_c = this.cardViewComponent) == null ? void 0 : _c.addCard(item.file);
      this.cardViewCheckDebouncer();
      this.countSearchItemDetected++;
    };
  }
  renewCardViewComponent() {
    var _a;
    (_a = this.cardViewComponent) == null ? void 0 : _a.$destroy();
    const { settings } = this.plugin;
    if (!settings)
      return;
    const focusEl = this.searchInterface.searchInputEl;
    if (!focusEl)
      return;
    const layout = parseCardLayout(settings.cardViewLayout);
    this.app.workspace.onLayoutReady(() => {
      const containerEl = this.app.workspace.rootSplit.containerEl;
      const cardViewComponent = new CardViewComponent_default({
        target: containerEl,
        props: {
          layout,
          focusEl
        }
      });
      this.cardViewComponent = cardViewComponent;
    });
  }
  renewWorkspacePreviewComponent() {
    var _a;
    (_a = this.workspacePreviewComponent) == null ? void 0 : _a.$destroy();
    if (this.currentFocusId === void 0)
      return;
    const focusEl = this.searchInterface.searchInputEl;
    if (!focusEl)
      return;
    const item = this.searchInterface.getResultItemAt(this.currentFocusId);
    if (!item)
      return;
    this.app.workspace.onLayoutReady(() => {
      var _a2;
      const containerEl = this.app.workspace.rootSplit.containerEl;
      const workspacePreviewComponent = new WorkspacePreview_default({
        target: containerEl,
        props: {
          file: item.file,
          matches: (_a2 = item.result.content) != null ? _a2 : [],
          focusEl
        }
      });
      this.workspacePreviewComponent = workspacePreviewComponent;
    });
  }
  get focusOnInput() {
    return () => __async(this, null, function* () {
      const inputEl = yield retry(() => {
        var _a;
        return (_a = this.plugin.searchInterface) == null ? void 0 : _a.searchInputEl;
      }, RETRY_INTERVAL, RETRY_TRIALS);
      if (inputEl === void 0) {
        throw "[ERROR in Core Search Assistant] failed to find the search input form.";
      }
      inputEl.focus();
    });
  }
  get onSortOrderChanged() {
    return () => {
      var _a;
      this.reset();
      if (((_a = this.plugin.settings) == null ? void 0 : _a.autoPreviewMode) === "cardView") {
        this.renewCardViewPage();
      }
    };
  }
  shouldCollapseSidedock(reason) {
    var _a, _b;
    if (!((_a = this.plugin.settings) == null ? void 0 : _a.autoToggleSidebar)) {
      return false;
    }
    if (reason === void 0) {
      return true;
    }
    if (reason.id !== "mouse") {
      return true;
    }
    const targetEl = reason.event.target;
    if (!(targetEl instanceof HTMLElement)) {
      return true;
    }
    return !((_b = this.searchInterface.sideDock) == null ? void 0 : _b.containerEl.contains(targetEl));
  }
  get onCheckCardView() {
    return () => {
      const { cardViewComponent } = this;
      if (!cardViewComponent)
        return;
      const ok = cardViewComponent.checkCardsRenderedCorrectly(this.filesToBeRendered());
      if (!ok) {
        this.reset();
        this.renewCardViewPage();
      }
    };
  }
};

// src/interfaces/SearchComponentInterface.ts
var import_obsidian16 = __toModule(require("obsidian"));

// src/types/Guards.ts
var import_obsidian15 = __toModule(require("obsidian"));
var SORT_ORDER_IN_SEARCH = [
  "alphabeticalReverse",
  "alphabetical",
  "byModifiedTime",
  "byModifiedTimeReverse",
  "byCreatedTime",
  "byCreatedTimeReverse"
];
function isSearchView(view) {
  if (typeof view !== "object") {
    return false;
  }
  if (view === null) {
    return false;
  }
  const {
    matchingCase,
    explainSearch,
    dom,
    setCollapseAll,
    setExplainSearch,
    setExtraContext,
    setMatchingCase,
    setSortOrder,
    searchInfoEl,
    searchComponent,
    headerDom
  } = view;
  if (typeof matchingCase !== "boolean") {
    return false;
  }
  if (typeof explainSearch !== "boolean") {
    return false;
  }
  if (!isSearchDom(dom)) {
    return false;
  }
  if (typeof searchComponent !== "object") {
    return false;
  }
  if (typeof searchInfoEl !== "object") {
    return false;
  }
  if (!(searchInfoEl instanceof HTMLDivElement)) {
    return false;
  }
  if (!isSearchHeaderDom(headerDom)) {
    return false;
  }
  if (!(setCollapseAll instanceof Function)) {
    return false;
  }
  if (!(setExplainSearch instanceof Function)) {
    return false;
  }
  if (!(setExtraContext instanceof Function)) {
    return false;
  }
  if (!(setMatchingCase instanceof Function)) {
    return false;
  }
  if (!(setSortOrder instanceof Function)) {
    return false;
  }
  return true;
}
function isSearchDom(obj) {
  if (typeof obj !== "object") {
    return false;
  }
  if (obj === null) {
    return false;
  }
  const { extraContext, collapseAll, sortOrder, vChildren, childrenEl } = obj;
  if (typeof extraContext !== "boolean") {
    return false;
  }
  if (typeof collapseAll !== "boolean") {
    return false;
  }
  if (typeof sortOrder !== "string") {
    return false;
  }
  if (!SORT_ORDER_IN_SEARCH.includes(sortOrder)) {
    return false;
  }
  if (!isSearchResultItemGroup(vChildren)) {
    return false;
  }
  if (typeof childrenEl !== "object") {
    return false;
  }
  if (!(childrenEl instanceof HTMLElement)) {
    return false;
  }
  return true;
}
function isSearchResultItemGroup(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const { _children: children2 } = obj;
  if (typeof children2 !== "object") {
    return false;
  }
  if (!(children2 instanceof Array)) {
    return false;
  }
  for (const child of children2) {
    if (!isSearchResultItem(child)) {
      return false;
    }
  }
  return true;
}
function isSearchResultItem(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const { file, containerEl } = obj;
  if (!(file instanceof import_obsidian15.TFile)) {
    return false;
  }
  if (!(containerEl instanceof HTMLElement)) {
    return false;
  }
  return true;
}
function isSearchHeaderDom(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  const { navButtonsEl } = obj;
  if (typeof navButtonsEl !== "object") {
    return false;
  }
  if (!(navButtonsEl instanceof HTMLDivElement)) {
    return false;
  }
  return true;
}

// src/utils/LinkedList.ts
var LinkedList = class {
  constructor(events, eventId) {
    this.unlinkedPool = new Map();
    this.events = events;
    this.eventId = eventId;
  }
  structure(cur, pre) {
    let linked = false;
    if (pre === void 0) {
      this.setRoot(cur);
      linked = true;
      this.signal();
    } else if (this.tail !== void 0 && pre === this.tail.entity) {
      this.link(cur);
      linked = true;
      this.unlinkedPool.delete(cur);
      this.signal();
    }
    if (linked) {
      if (!this.unlinkedPool.has(cur)) {
        return;
      }
      const next = this.unlinkedPool.get(cur);
      if (next === void 0) {
        return;
      }
      this.structure(next, cur);
    } else {
      if (pre) {
        this.unlinkedPool.set(pre, cur);
      }
    }
  }
  setRoot(entity) {
    const rootNode = {
      entity,
      pre: void 0,
      next: void 0
    };
    this.head = rootNode;
    this.tail = rootNode;
  }
  link(cur) {
    if (!this.tail) {
      return;
    }
    const currentTail = this.tail;
    currentTail.next = {
      entity: cur,
      pre: currentTail,
      next: void 0
    };
    this.tail = currentTail.next;
  }
  clean() {
    this.head = void 0;
    this.tail = void 0;
    this.unlinkedPool = new Map();
  }
  signal() {
    this.events.trigger(this.eventId);
  }
};

// src/interfaces/SearchComponentInterface.ts
var SearchComponentInterface = class extends import_obsidian16.Component {
  constructor(app2, plugin2, events) {
    super();
    this.observationConfig = {
      childList: true
    };
    this.onObservedCallback = (mutations, _observer) => __async(this, null, function* () {
      for (const mutation of mutations) {
        if (mutation.addedNodes.length === 0) {
          continue;
        }
        const pre = mutation.previousSibling;
        if (!(pre instanceof HTMLElement)) {
          continue;
        }
        for (const node of Array.from(mutation.addedNodes)) {
          if (!(node instanceof HTMLElement)) {
            continue;
          }
          const isSearchResultItem2 = node.tagName === "DIV" && node.hasClass("tree-item") && node.hasClass("search-result");
          if (!isSearchResultItem2) {
            continue;
          }
          if (!this.linkedList) {
            return;
          }
          this.linkedList.structure(node, this.isRootSearchResult(pre) ? void 0 : pre);
        }
      }
    });
    this.app = app2;
    this.plugin = plugin2;
    this.events = events;
    this.observer = new MutationObserver(this.onObservedCallback.bind(this));
  }
  onload() {
    this.app.workspace.onLayoutReady(() => {
      this.renewSortOrderInfo();
      this.registerDomEvent(document, "click", () => {
        this.renewSortOrderInfo(this.events);
      });
    });
  }
  onunload() {
    var _a, _b;
    (_a = this.sortOrderContainerEl) == null ? void 0 : _a.empty();
    (_b = this.sortOrderContainerEl) == null ? void 0 : _b.remove();
    this.observer.disconnect();
  }
  toggleMatchingCase() {
    const view = this.searchView;
    view == null ? void 0 : view.setMatchingCase(!view.matchingCase);
  }
  toggleExplainSearch() {
    const view = this.searchView;
    view == null ? void 0 : view.setExplainSearch(!view.explainSearch);
  }
  toggleCollapseAll() {
    const view = this.searchView;
    view == null ? void 0 : view.setCollapseAll(!view.dom.collapseAll);
  }
  toggleExtraContext() {
    const view = this.searchView;
    view == null ? void 0 : view.setExtraContext(!view.dom.extraContext);
  }
  setSortOrder(sortOrder) {
    const view = this.searchView;
    const originalOrder = view == null ? void 0 : view.dom.sortOrder;
    view == null ? void 0 : view.setSortOrder(sortOrder);
    return sortOrder !== originalOrder;
  }
  focusOn(pos) {
    var _a;
    this.unfocus();
    const item = this.getResultItemAt(pos);
    if (!item) {
      return;
    }
    item.containerEl.addClass("core-search-assistant_search-result-items-focus");
    item.containerEl.scrollIntoView(((_a = this.plugin.settings) == null ? void 0 : _a.keepSelectedItemsCentered) ? { block: "center" } : { block: "nearest" });
  }
  unfocus() {
    const items = this.resultItems;
    items.forEach((item) => {
      item.containerEl.removeClass("core-search-assistant_search-result-items-focus");
    });
  }
  open(pos, direction) {
    return __async(this, null, function* () {
      const item = this.getResultItemAt(pos);
      if (!item) {
        return;
      }
      const { file } = item;
      const leaf = direction === void 0 ? this.app.workspace.getMostRecentLeaf() : this.app.workspace.splitActiveLeaf(direction);
      yield leaf.openFile(file);
      this.app.workspace.setActiveLeaf(leaf, true, true);
    });
  }
  renewSortOrderInfo(events) {
    if (!this.sortOrderContainerEl) {
      this.createSortOrderEls();
    }
    const view = this.searchView;
    if (!view) {
      return;
    }
    const sortOrder = view.dom.sortOrder;
    if (!this.sortOrderContentEl) {
      return;
    }
    const originalContent = this.sortOrderContentEl.textContent;
    this.sortOrderContentEl.textContent = searchOptions[sortOrder].description;
    if (events !== void 0 && originalContent !== this.sortOrderContentEl.textContent) {
      events.trigger(EVENT_SORT_ORDER_CHANGED);
    }
  }
  count() {
    var _a;
    const results = (_a = this.searchView) == null ? void 0 : _a.dom.vChildren._children;
    if (!results) {
      return 0;
    }
    return results.length;
  }
  get resultItems() {
    var _a, _b;
    return (_b = (_a = this.searchView) == null ? void 0 : _a.dom.vChildren._children) != null ? _b : [];
  }
  getResultItemAt(pos) {
    var _a;
    return (_a = this.searchView) == null ? void 0 : _a.dom.vChildren._children[pos];
  }
  get searchInputEl() {
    var _a;
    return (_a = this.searchView) == null ? void 0 : _a.searchComponent.inputEl;
  }
  startWatching(events) {
    var _a;
    this.linkedList = new LinkedList(events, EVENT_SEARCH_RESULT_ITEM_DETECTED);
    const childrenContainerEl = (_a = this.searchView) == null ? void 0 : _a.dom.childrenEl;
    if (!(childrenContainerEl instanceof HTMLElement)) {
      throw "[ERROR in Core Search Assistant] failed to SearchComponentInterface#startWatching: childrenContainerEl is not an instance of HTMLElement";
    }
    this.observer.observe(childrenContainerEl, this.observationConfig);
  }
  stopWatching() {
    this.observer.disconnect();
  }
  collapseOppositeSidedock() {
    const sideDock = this.oppositeSidedock;
    if (sideDock === void 0) {
      throw "[ERROR in Core Search Assistant] failed to collapseOppositeSidedock: failed to fetch the opposite sidedock";
    }
    sideDock.collapse();
  }
  expandOppositeSidedock() {
    const sideDock = this.oppositeSidedock;
    if (sideDock === void 0) {
      throw "[ERROR in Core Search Assistant] failed to expandOppositeSidedock: failed to fetch the opposite sidedock";
    }
    sideDock.expand();
  }
  collapseSidedock() {
    const sideDock = this.sideDock;
    if (sideDock === void 0) {
      throw "[ERROR in Core Search Assistant] failed to collapseSidedock: failed to fetch the sidedock";
    }
    sideDock.collapse();
  }
  get sideDock() {
    const leaf = this.searchLeaf;
    if (leaf === void 0) {
      return void 0;
    }
    const parent = leaf.getRoot();
    if (parent instanceof import_obsidian16.WorkspaceSidedock) {
      return parent;
    } else {
      return void 0;
    }
  }
  get oppositeSidedock() {
    const leaf = this.searchLeaf;
    if (leaf === void 0) {
      return void 0;
    }
    const parent = leaf.getRoot();
    if (parent === this.app.workspace.leftSplit) {
      const opposite = this.app.workspace.rightSplit;
      return opposite instanceof import_obsidian16.WorkspaceSidedock ? opposite : void 0;
    } else if (parent === this.app.workspace.rightSplit) {
      const opposite = this.app.workspace.leftSplit;
      return opposite instanceof import_obsidian16.WorkspaceSidedock ? opposite : void 0;
    } else {
      return void 0;
    }
  }
  createSortOrderEls() {
    this.sortOrderContainerEl = createEl("div", {
      cls: "search-info-container"
    });
    this.sortOrderContentEl = this.sortOrderContainerEl.createEl("div");
    const view = this.searchView;
    if (!view) {
      return void 0;
    }
    this.sortOrderContainerEl.insertAfter(view.searchInfoEl);
  }
  get matchingCaseButtonEl() {
    var _a;
    return (_a = this.searchView) == null ? void 0 : _a.matchingCaseButtonEl;
  }
  get tabHeaderEl() {
    var _a;
    return (_a = this.searchLeaf) == null ? void 0 : _a.tabHeaderEl;
  }
  isBuiltInElementToOpenFile(el) {
    const isFileNameContainerEl = el.tagName === "DIV" && el.hasClass("tree-item-inner");
    const isMatchCountContainerEl = el.tagName === "DIV" && el.hasClass("tree-item-flair-outer");
    const isMatchContainerEl = el.tagName === "DIV" && el.hasClass("search-result-file-match");
    if (isFileNameContainerEl || isMatchContainerEl || isMatchCountContainerEl) {
      return true;
    }
    const parentEl = el.parentElement;
    if (parentEl === null) {
      return false;
    } else {
      return this.isBuiltInElementToOpenFile(parentEl);
    }
  }
  isShowMoreContextButton(el) {
    return el.tagName === "DIV" && el.hasClass("search-result-hover-button");
  }
  get searchView() {
    const leaf = this.searchLeaf;
    if (!leaf) {
      return void 0;
    }
    const view = leaf.view;
    return isSearchView(view) ? view : void 0;
  }
  get searchLeaf() {
    return this.app.workspace.getLeavesOfType("search")[0];
  }
  isRootSearchResult(el) {
    return el.tagName === "DIV" && !el.hasClass("tree-item") && !el.hasClass("search-result");
  }
};

// src/main.ts
var import_obsidian17 = __toModule(require("obsidian"));
var CoreSearchAssistantPlugin = class extends import_obsidian17.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.events = new CoreSearchAssistantEvents();
      this.searchInterface = this.addChild(new SearchComponentInterface(this.app, this, this.events));
      this.controller = this.addChild(new Controller(this.app, this, this.events, this.searchInterface));
      this.watchLayoutChange();
      this.setSvelteStoreValues();
      this.addSettingTab(new CoreSearchAssistantSettingTab(this.app, this));
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = deepMerge(DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  renewController() {
    if (this.controller) {
      this.removeChild(this.controller);
    }
    if (this.events === void 0) {
      throw "[ERROR in Core Search Interface] failed to renewController: plugin.events = undefined";
    }
    if (this.searchInterface === void 0) {
      throw "[ERROR in Core Search Interface] failed to renewController: plugin.searchInterface = undefined";
    }
    this.controller = this.addChild(new Controller(this.app, this, this.events, this.searchInterface));
  }
  watchLayoutChange() {
    this.app.workspace.onLayoutReady(() => {
      this.app.workspace.on("layout-change", () => __async(this, null, function* () {
        var _a;
        if (yield (_a = this.controller) == null ? void 0 : _a.layoutChanged()) {
          this.renewController();
        }
      }));
    });
  }
  setSvelteStoreValues() {
    plugin.set(this);
    app.set(this.app);
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
