/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => NovelWordCountPlugin
});

// logic/debug.ts
var DebugHelper = class {
  constructor() {
    this.debugMode = false;
  }
  setDebugMode(debug) {
    this.debugMode = debug;
  }
  debug(...args) {
    if (!this.debugMode) {
      return;
    }
    console.log("novel-word-count:", ...args);
  }
  debugStart(name) {
    if (!this.debugMode) {
      return () => {
      };
    }
    var qualifiedName = `novel-word-count|${name}`;
    console.time(qualifiedName);
    return () => console.timeEnd(qualifiedName);
  }
};

// logic/file.ts
var import_obsidian = __toModule(require("obsidian"));

// logic/settings.ts
var CountType;
(function(CountType2) {
  CountType2["None"] = "none";
  CountType2["Word"] = "word";
  CountType2["Page"] = "page";
  CountType2["Note"] = "note";
  CountType2["Character"] = "character";
  CountType2["Created"] = "created";
  CountType2["Modified"] = "modified";
})(CountType || (CountType = {}));
var countTypeDisplayStrings = {
  [CountType.None]: "None",
  [CountType.Word]: "Word Count",
  [CountType.Page]: "Page Count",
  [CountType.Note]: "Note Count",
  [CountType.Character]: "Character Count",
  [CountType.Created]: "Created Date",
  [CountType.Modified]: "Last Updated Date"
};
var countTypes = [
  CountType.None,
  CountType.Word,
  CountType.Page,
  CountType.Note,
  CountType.Character,
  CountType.Created,
  CountType.Modified
];
var AlignmentType;
(function(AlignmentType2) {
  AlignmentType2["Inline"] = "inline";
  AlignmentType2["Right"] = "right";
  AlignmentType2["Below"] = "below";
})(AlignmentType || (AlignmentType = {}));
var alignmentTypes = [
  AlignmentType.Inline,
  AlignmentType.Right,
  AlignmentType.Below
];
var PageCountType;
(function(PageCountType2) {
  PageCountType2["ByWords"] = "ByWords";
  PageCountType2["ByChars"] = "ByChars";
})(PageCountType || (PageCountType = {}));
var DEFAULT_SETTINGS = {
  countType: CountType.Word,
  countType2: CountType.None,
  countType3: CountType.None,
  abbreviateDescriptions: false,
  alignment: AlignmentType.Inline,
  debugMode: false,
  wordsPerPage: 300,
  charsPerPage: 1500,
  pageCountType: PageCountType.ByWords
};

// logic/file.ts
var FileHelper = class {
  constructor(vault, plugin) {
    this.vault = vault;
    this.plugin = plugin;
    this.debugHelper = new DebugHelper();
  }
  get settings() {
    return this.plugin.settings;
  }
  getAllFileCounts() {
    return __async(this, null, function* () {
      const debugEnd = this.debugHelper.debugStart("getAllFileCounts");
      const files = this.vault.getMarkdownFiles();
      const counts = {};
      for (const file of files) {
        const contents = yield this.vault.cachedRead(file);
        this.setCounts(counts, file, contents);
      }
      debugEnd();
      return counts;
    });
  }
  getCountDataForPath(counts, path) {
    if (counts.hasOwnProperty(path)) {
      return counts[path];
    }
    const childPaths = Object.keys(counts).filter((countPath) => path === "/" || countPath.startsWith(path + "/"));
    return childPaths.reduce((total, childPath) => {
      const childCount = this.getCountDataForPath(counts, childPath);
      total.noteCount += childCount.noteCount;
      total.wordCount += childCount.wordCount;
      total.pageCount += childCount.pageCount;
      total.characterCount += childCount.characterCount;
      total.nonWhitespaceCharacterCount += childCount.nonWhitespaceCharacterCount;
      total.createdDate = total.createdDate === 0 ? childCount.createdDate : Math.min(total.createdDate, childCount.createdDate);
      total.modifiedDate = Math.max(total.modifiedDate, childCount.modifiedDate);
      return total;
    }, {
      noteCount: 0,
      wordCount: 0,
      pageCount: 0,
      characterCount: 0,
      nonWhitespaceCharacterCount: 0,
      createdDate: 0,
      modifiedDate: 0
    });
  }
  setDebugMode(debug) {
    this.debugHelper.setDebugMode(debug);
  }
  updateFileCounts(abstractFile, counts) {
    return __async(this, null, function* () {
      if (abstractFile instanceof import_obsidian.TFolder) {
        this.debugHelper.debug("updateFileCounts called on instance of TFolder");
        Object.assign(counts, this.getAllFileCounts());
        return;
      }
      if (abstractFile instanceof import_obsidian.TFile) {
        const contents = yield this.vault.cachedRead(abstractFile);
        this.setCounts(counts, abstractFile, contents);
      }
    });
  }
  countWords(content) {
    return (content.match(/[^\s]+/g) || []).length;
  }
  countNonWhitespaceCharacters(content) {
    return (content.replace(/\s+/g, "") || []).length;
  }
  setCounts(counts, file, content) {
    const wordCount = this.countWords(content);
    const nonWhitespaceCharacterCount = this.countNonWhitespaceCharacters(content);
    let pageCount = 0;
    if (this.settings.pageCountType === PageCountType.ByWords) {
      const wordsPerPage = Number(this.settings.wordsPerPage);
      const wordsPerPageValid = !isNaN(wordsPerPage) && wordsPerPage > 0;
      pageCount = wordCount / (wordsPerPageValid ? wordsPerPage : 300);
    } else if (this.settings.pageCountType === PageCountType.ByChars) {
      const charsPerPage = Number(this.settings.charsPerPage);
      const charsPerPageValid = !isNaN(charsPerPage) && charsPerPage > 0;
      pageCount = nonWhitespaceCharacterCount / (charsPerPageValid ? charsPerPage : 1500);
    }
    counts[file.path] = {
      noteCount: 1,
      wordCount,
      pageCount,
      characterCount: content.length,
      nonWhitespaceCharacterCount,
      createdDate: file.stat.ctime,
      modifiedDate: file.stat.mtime
    };
  }
};

// main.ts
var import_obsidian2 = __toModule(require("obsidian"));
var NovelWordCountPlugin = class extends import_obsidian2.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.debugHelper = new DebugHelper();
    this.fileHelper = new FileHelper(this.app.vault, this);
  }
  get settings() {
    return this.savedData.settings;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.fileHelper.setDebugMode(this.savedData.settings.debugMode);
      this.debugHelper.setDebugMode(this.savedData.settings.debugMode);
      this.debugHelper.debug("onload lifecycle hook");
      this.addSettingTab(new NovelWordCountSettingTab(this.app, this));
      this.addCommand({
        id: "recount-vault",
        name: "Reanalyze (recount) all documents in vault",
        callback: () => __async(this, null, function* () {
          this.debugHelper.debug("[Reanalyze] command triggered");
          yield this.initialize();
        })
      });
      this.addCommand({
        id: "cycle-count-type",
        name: "Show next data type (1st position)",
        callback: () => __async(this, null, function* () {
          this.debugHelper.debug("[Cycle next data type] command triggered");
          this.settings.countType = countTypes[(countTypes.indexOf(this.settings.countType) + 1) % countTypes.length];
          yield this.saveSettings();
          this.updateDisplayedCounts();
        })
      });
      this.addCommand({
        id: "toggle-abbreviate",
        name: "Toggle abbreviation",
        callback: () => __async(this, null, function* () {
          this.debugHelper.debug("[Toggle abbrevation] command triggered");
          this.settings.abbreviateDescriptions = !this.settings.abbreviateDescriptions;
          yield this.saveSettings();
          this.updateDisplayedCounts();
        })
      });
      for (const countType of countTypes) {
        this.addCommand({
          id: `set-count-type-${countType}`,
          name: `Show ${countTypeDisplayStrings[countType]} (1st position)`,
          callback: () => __async(this, null, function* () {
            this.debugHelper.debug(`[Set count type to ${countType}] command triggered`);
            this.settings.countType = countType;
            yield this.saveSettings();
            this.updateDisplayedCounts();
          })
        });
      }
      this.handleEvents();
      this.initialize();
    });
  }
  onunload() {
    return __async(this, null, function* () {
      this.saveSettings();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      const loaded = yield this.loadData();
      if (loaded && loaded.settings && loaded.settings.countType && !countTypes.includes(loaded.settings.countType)) {
        loaded.settings.countType = CountType.Word;
      }
      this.savedData = Object.assign({}, loaded);
      this.savedData.settings = Object.assign({}, DEFAULT_SETTINGS, this.savedData.settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.savedData);
    });
  }
  initialize(refreshAllCounts = true) {
    return __async(this, null, function* () {
      this.debugHelper.debug("initialize");
      if (refreshAllCounts) {
        yield this.refreshAllCounts();
      }
      try {
        yield this.updateDisplayedCounts();
      } catch (err) {
        setTimeout(() => {
          this.initialize(false);
        }, 1e3);
      }
    });
  }
  updateDisplayedCounts(file = null) {
    return __async(this, null, function* () {
      const debugEnd = this.debugHelper.debugStart("updateDisplayedCounts");
      if (!Object.keys(this.savedData.cachedCounts).length) {
        this.debugHelper.debug("No cached data found; refreshing all counts.");
        yield this.refreshAllCounts();
      }
      const fileExplorerLeaf = yield this.getFileExplorerLeaf();
      this.setContainerClass(fileExplorerLeaf);
      const fileItems = fileExplorerLeaf.view.fileItems;
      if (file) {
        const relevantItems = Object.keys(fileItems).filter((path) => file.path.includes(path));
        this.debugHelper.debug("Setting display counts for", relevantItems.length, "fileItems matching path", file.path);
      } else {
        this.debugHelper.debug(`Setting display counts for ${Object.keys(fileItems).length} fileItems`);
      }
      for (const path in fileItems) {
        if (file && !file.path.includes(path)) {
          continue;
        }
        const counts = this.fileHelper.getCountDataForPath(this.savedData.cachedCounts, path);
        const item = fileItems[path];
        item.titleEl.setAttribute("data-novel-word-count-plugin", this.getNodeLabel(counts));
      }
      debugEnd();
    });
  }
  getFileExplorerLeaf() {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        let foundLeaf = null;
        this.app.workspace.iterateAllLeaves((leaf) => {
          if (foundLeaf) {
            return;
          }
          const view = leaf.view;
          if (!view || !view.fileItems) {
            return;
          }
          foundLeaf = leaf;
          resolve(foundLeaf);
        });
        if (!foundLeaf) {
          reject(Error("Could not find file explorer leaf."));
        }
      });
    });
  }
  getDataTypeLabel(counts, countType, abbreviateDescriptions) {
    if (!counts || typeof counts.wordCount !== "number") {
      return "";
    }
    const getPluralizedCount = function(noun, count) {
      const roundedCount = Math.ceil(count);
      return `${roundedCount.toLocaleString()} ${noun}${roundedCount == 1 ? "" : "s"}`;
    };
    switch (countType) {
      case CountType.None:
        return "";
      case CountType.Word:
        return abbreviateDescriptions ? `${Math.ceil(counts.wordCount).toLocaleString()}w` : getPluralizedCount("word", counts.wordCount);
      case CountType.Page:
        return abbreviateDescriptions ? `${Math.ceil(counts.pageCount).toLocaleString()}p` : getPluralizedCount("page", counts.pageCount);
      case CountType.Note:
        return abbreviateDescriptions ? `${counts.noteCount.toLocaleString()}n` : getPluralizedCount("note", counts.noteCount);
      case CountType.Character:
        return abbreviateDescriptions ? `${counts.characterCount.toLocaleString()}ch` : getPluralizedCount("character", counts.characterCount);
      case CountType.Created:
        if (counts.createdDate === 0) {
          return "";
        }
        return abbreviateDescriptions ? `${new Date(counts.createdDate).toLocaleDateString()}/c` : `Created ${new Date(counts.createdDate).toLocaleDateString()}`;
      case CountType.Modified:
        if (counts.modifiedDate === 0) {
          return "";
        }
        return abbreviateDescriptions ? `${new Date(counts.modifiedDate).toLocaleDateString()}/u` : `Updated ${new Date(counts.modifiedDate).toLocaleDateString()}`;
    }
    return "";
  }
  getNodeLabel(counts) {
    return [
      this.settings.countType,
      this.settings.countType2,
      this.settings.countType3
    ].filter((ct) => ct !== CountType.None).map((ct) => this.getDataTypeLabel(counts, ct, this.settings.abbreviateDescriptions)).join(" | ");
  }
  handleEvents() {
    return __async(this, null, function* () {
      this.registerEvent(this.app.vault.on("modify", (file) => __async(this, null, function* () {
        this.debugHelper.debug("[modify] vault hook fired, recounting file", file.path);
        yield this.fileHelper.updateFileCounts(file, this.savedData.cachedCounts);
        yield this.updateDisplayedCounts(file);
      })));
      const recalculateAll = (hookName, file) => __async(this, null, function* () {
        if (file) {
          this.debugHelper.debug(`[${hookName}] vault hook fired by file`, file.path, "recounting all files");
        } else {
          this.debugHelper.debug(`[${hookName}] hook fired`, "recounting all files");
        }
        yield this.refreshAllCounts();
        yield this.updateDisplayedCounts();
      });
      this.registerEvent(this.app.vault.on("rename", (0, import_obsidian2.debounce)(recalculateAll.bind(this, "rename"), 1e3)));
      this.registerEvent(this.app.vault.on("create", (0, import_obsidian2.debounce)(recalculateAll.bind(this, "create"), 1e3)));
      this.registerEvent(this.app.vault.on("delete", (0, import_obsidian2.debounce)(recalculateAll.bind(this, "delete"), 1e3)));
      const reshowCountsIfNeeded = (hookName) => __async(this, null, function* () {
        this.debugHelper.debug(`[${hookName}] hook fired`);
        const fileExplorerLeaf = yield this.getFileExplorerLeaf();
        if (this.isContainerTouched(fileExplorerLeaf)) {
          this.debugHelper.debug("container already touched, skipping display update");
          return;
        }
        this.debugHelper.debug("container is clean, updating display");
        yield this.updateDisplayedCounts();
      });
      this.registerEvent(this.app.workspace.on("layout-change", (0, import_obsidian2.debounce)(reshowCountsIfNeeded.bind(this, "layout-change"), 1e3)));
    });
  }
  isContainerTouched(leaf) {
    const container = leaf.view.containerEl;
    return container.className.includes("novel-word-count--");
  }
  refreshAllCounts() {
    return __async(this, null, function* () {
      this.debugHelper.debug("refreshAllCounts");
      this.savedData.cachedCounts = yield this.fileHelper.getAllFileCounts();
      yield this.saveSettings();
    });
  }
  setContainerClass(leaf) {
    const container = leaf.view.containerEl;
    const prefix = `novel-word-count--`;
    const alignmentClasses = alignmentTypes.map((at) => prefix + at);
    for (const ac of alignmentClasses) {
      container.toggleClass(ac, false);
    }
    container.toggleClass(prefix + this.settings.alignment, true);
  }
};
var NovelWordCountSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const mainHeader = containerEl.createEl("div", {
      cls: [
        "setting-item",
        "setting-item-heading",
        "novel-word-count-settings-header"
      ]
    });
    mainHeader.createEl("div", { text: "General" });
    mainHeader.createEl("div", {
      text: "You can display up to three data types side by side.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("1st data type to show").setDesc("Ex: 10,000 words").addDropdown((drop) => {
      for (const countType of countTypes) {
        drop.addOption(countType, countTypeDisplayStrings[countType]);
      }
      drop.setValue(this.plugin.settings.countType).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.countType = value;
        yield this.plugin.saveSettings();
        yield this.plugin.updateDisplayedCounts();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName("2nd data type to show").setDesc("Ex: 10,000 words | 33 pages").addDropdown((drop) => {
      for (const countType of countTypes) {
        drop.addOption(countType, countTypeDisplayStrings[countType]);
      }
      drop.setValue(this.plugin.settings.countType2).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.countType2 = value;
        yield this.plugin.saveSettings();
        yield this.plugin.updateDisplayedCounts();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName("3rd data type to show").setDesc("Ex: 10,000 words | 33 pages | Created 10/27/2022").addDropdown((drop) => {
      for (const countType of countTypes) {
        drop.addOption(countType, countTypeDisplayStrings[countType]);
      }
      drop.setValue(this.plugin.settings.countType3).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.countType3 = value;
        yield this.plugin.saveSettings();
        yield this.plugin.updateDisplayedCounts();
      }));
    });
    new import_obsidian2.Setting(containerEl).setName("Abbreviate descriptions").setDesc("E.g. show '120w' instead of '120 words'").addToggle((toggle) => toggle.setValue(this.plugin.settings.abbreviateDescriptions).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.abbreviateDescriptions = value;
      yield this.plugin.saveSettings();
      yield this.plugin.updateDisplayedCounts();
    })));
    new import_obsidian2.Setting(containerEl).setName("Alignment").setDesc("Show data inline with file/folder names, right-aligned, or underneath").addDropdown((drop) => {
      drop.addOption(AlignmentType.Inline, "Inline").addOption(AlignmentType.Right, "Right-aligned").addOption(AlignmentType.Below, "Below").setValue(this.plugin.settings.alignment).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.alignment = value;
        yield this.plugin.saveSettings();
        yield this.plugin.updateDisplayedCounts();
      }));
    });
    containerEl.createEl("div", { text: "Advanced" }).addClasses(["setting-item", "setting-item-heading"]);
    new import_obsidian2.Setting(containerEl).setName("Page count method").setDesc("For language compatibility").addDropdown((drop) => {
      drop.addOption(PageCountType.ByWords, "Words per page").addOption(PageCountType.ByChars, "Characters per page").setValue(this.plugin.settings.pageCountType).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.pageCountType = value;
        yield this.plugin.saveSettings();
        yield this.plugin.updateDisplayedCounts();
        this.display();
      }));
    });
    if (this.plugin.settings.pageCountType === PageCountType.ByWords) {
      const wordsPerPageChanged = (txt, value) => __async(this, null, function* () {
        const asNumber = Number(value);
        const isValid = !isNaN(asNumber) && asNumber > 0;
        txt.inputEl.style.borderColor = isValid ? null : "red";
        this.plugin.settings.wordsPerPage = isValid ? Number(value) : 300;
        yield this.plugin.saveSettings();
        yield this.plugin.initialize();
      });
      new import_obsidian2.Setting(containerEl).setName("Words per page").setDesc("Used for page count. 300 is standard in English language publishing.").addText((txt) => {
        txt.setPlaceholder("300").setValue(this.plugin.settings.wordsPerPage.toString()).onChange((0, import_obsidian2.debounce)(wordsPerPageChanged.bind(this, txt), 1e3));
      });
    }
    if (this.plugin.settings.pageCountType === PageCountType.ByChars) {
      const charsPerPageChanged = (txt, value) => __async(this, null, function* () {
        const asNumber = Number(value);
        const isValid = !isNaN(asNumber) && asNumber > 0;
        txt.inputEl.style.borderColor = isValid ? null : "red";
        this.plugin.settings.charsPerPage = isValid ? Number(value) : 1500;
        yield this.plugin.saveSettings();
        yield this.plugin.initialize();
      });
      new import_obsidian2.Setting(containerEl).setName("Characters per page (not counting whitespace)").setDesc("Used for page count. 1500 is common in German (Normseite).").addText((txt) => {
        txt.setPlaceholder("1500").setValue(this.plugin.settings.charsPerPage.toString()).onChange((0, import_obsidian2.debounce)(charsPerPageChanged.bind(this, txt), 1e3));
      });
    }
    new import_obsidian2.Setting(containerEl).setName("Reanalyze all documents").setDesc("If changes have occurred outside of Obsidian, you may need to trigger a manual analysis").addButton((button) => button.setButtonText("Reanalyze").setCta().onClick(() => __async(this, null, function* () {
      button.disabled = true;
      yield this.plugin.initialize();
      button.setButtonText("Done");
      button.removeCta();
      setTimeout(() => {
        button.setButtonText("Reanalyze");
        button.setCta();
        button.disabled = false;
      }, 1e3);
    })));
    new import_obsidian2.Setting(containerEl).setName("Debug mode").setDesc("Log debugging information to the developer console").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.debugMode = value;
      this.plugin.debugHelper.setDebugMode(value);
      this.plugin.fileHelper.setDebugMode(value);
      yield this.plugin.saveSettings();
    })));
  }
};
