/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var getAPI2 = (app2) => {
      var _a;
      if (app2)
        return (_a = app2.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled3 = (app2) => app2.plugins.enabledPlugins.has("dataview");
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled3;
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t3, e) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = e() : typeof define == "function" && define.amd ? define(e) : (t3 = typeof globalThis != "undefined" ? globalThis : t3 || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t3 = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", $ = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t4, e2, n3) {
        var r3 = String(t4);
        return !r3 || r3.length >= e2 ? t4 : "" + Array(e2 + 1 - r3.length).join(n3) + t4;
      }, g2 = { s: m, z: function(t4) {
        var e2 = -t4.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i3, 2, "0");
      }, m: function t4(e2, n3) {
        if (e2.date() < n3.date())
          return -t4(n3, e2);
        var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s3 ? -1 : 1), f2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t4) {
        return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
      }, p: function(t4) {
        return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: h2 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t4) {
        return t4 === void 0;
      } }, v2 = "en", D2 = {};
      D2[v2] = M2;
      var p2 = function(t4) {
        return t4 instanceof _24;
      }, S2 = function t4(e2, n3, r3) {
        var i3;
        if (!e2)
          return v2;
        if (typeof e2 == "string") {
          var s3 = e2.toLowerCase();
          D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
          var u3 = e2.split("-");
          if (!i3 && u3.length > 1)
            return t4(u3[0]);
        } else {
          var a3 = e2.name;
          D2[a3] = e2, i3 = a3;
        }
        return !r3 && i3 && (v2 = i3), i3 || !r3 && v2;
      }, w2 = function(t4, e2) {
        if (p2(t4))
          return t4.clone();
        var n3 = typeof e2 == "object" ? e2 : {};
        return n3.date = t4, n3.args = arguments, new _24(n3);
      }, O2 = g2;
      O2.l = S2, O2.i = p2, O2.w = function(t4, e2) {
        return w2(t4, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _24 = function() {
        function M3(t4) {
          this.$L = S2(t4.locale, null, true), this.parse(t4);
        }
        var m2 = M3.prototype;
        return m2.parse = function(t4) {
          this.$d = function(t5) {
            var e2 = t5.date, n3 = t5.utc;
            if (e2 === null)
              return new Date(NaN);
            if (O2.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if (typeof e2 == "string" && !/Z$/i.test(e2)) {
              var r3 = e2.match(l2);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e2);
          }(t4), this.$x = t4.x || {}, this.init();
        }, m2.init = function() {
          var t4 = this.$d;
          this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
        }, m2.$utils = function() {
          return O2;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t4, e2) {
          var n3 = w2(t4);
          return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
        }, m2.isAfter = function(t4, e2) {
          return w2(t4) < this.startOf(e2);
        }, m2.isBefore = function(t4, e2) {
          return this.endOf(e2) < w2(t4);
        }, m2.$g = function(t4, e2, n3) {
          return O2.u(t4) ? this[e2] : this.set(n3, t4);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t4, e2) {
          var n3 = this, r3 = !!O2.u(e2) || e2, h3 = O2.p(t4), $2 = function(t5, e3) {
            var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e3, t5) : new Date(n3.$y, e3, t5), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, l3 = function(t5, e3) {
            return O2.w(n3.toDate()[t5].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n3);
          }, y3 = this.$W, M4 = this.$M, m3 = this.$D, g3 = "set" + (this.$u ? "UTC" : "");
          switch (h3) {
            case c2:
              return r3 ? $2(1, 0) : $2(31, 11);
            case f2:
              return r3 ? $2(1, M4) : $2(0, M4 + 1);
            case o2:
              var v3 = this.$locale().weekStart || 0, D3 = (y3 < v3 ? y3 + 7 : y3) - v3;
              return $2(r3 ? m3 - D3 : m3 + (6 - D3), M4);
            case a2:
            case d2:
              return l3(g3 + "Hours", 0);
            case u2:
              return l3(g3 + "Minutes", 1);
            case s2:
              return l3(g3 + "Seconds", 2);
            case i2:
              return l3(g3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t4) {
          return this.startOf(t4, false);
        }, m2.$set = function(t4, e2) {
          var n3, o3 = O2.p(t4), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], l3 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o3 === f2 || o3 === c2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[$2](l3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l3);
          return this.init(), this;
        }, m2.set = function(t4, e2) {
          return this.clone().$set(t4, e2);
        }, m2.get = function(t4) {
          return this[O2.p(t4)]();
        }, m2.add = function(r3, h3) {
          var d3, $2 = this;
          r3 = Number(r3);
          var l3 = O2.p(h3), y3 = function(t4) {
            var e2 = w2($2);
            return O2.w(e2.date(e2.date() + Math.round(t4 * r3)), $2);
          };
          if (l3 === f2)
            return this.set(f2, this.$M + r3);
          if (l3 === c2)
            return this.set(c2, this.$y + r3);
          if (l3 === a2)
            return y3(1);
          if (l3 === o2)
            return y3(7);
          var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n2, d3[i2] = t3, d3)[l3] || 1, m3 = this.$d.getTime() + r3 * M4;
          return O2.w(m3, this);
        }, m2.subtract = function(t4, e2) {
          return this.add(-1 * t4, e2);
        }, m2.format = function(t4) {
          var e2 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || $;
          var r3 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t5, n4, i4, s4) {
            return t5 && (t5[n4] || t5(e2, r3)) || i4[n4].slice(0, s4);
          }, c3 = function(t5) {
            return O2.s(s3 % 12 || 12, t5, "0");
          }, d3 = n3.meridiem || function(t5, e3, n4) {
            var r4 = t5 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
          return r3.replace(y2, function(t5, e3) {
            return e3 || l3[t5] || i3.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r3, d3, $2) {
          var l3, y3 = O2.p(d3), M4 = w2(r3), m3 = (M4.utcOffset() - this.utcOffset()) * e, g3 = this - M4, v3 = O2.m(this, M4);
          return v3 = (l3 = {}, l3[c2] = v3 / 12, l3[f2] = v3, l3[h2] = v3 / 3, l3[o2] = (g3 - m3) / 6048e5, l3[a2] = (g3 - m3) / 864e5, l3[u2] = g3 / n2, l3[s2] = g3 / e, l3[i2] = g3 / t3, l3)[y3] || g3, $2 ? v3 : O2.a(v3);
        }, m2.daysInMonth = function() {
          return this.endOf(f2).$D;
        }, m2.$locale = function() {
          return D2[this.$L];
        }, m2.locale = function(t4, e2) {
          if (!t4)
            return this.$L;
          var n3 = this.clone(), r3 = S2(t4, e2, true);
          return r3 && (n3.$L = r3), n3;
        }, m2.clone = function() {
          return O2.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), T = _24.prototype;
      return w2.prototype = T, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t4) {
        T[t4[1]] = function(e2) {
          return this.$g(e2, t4[0], t4[1]);
        };
      }), w2.extend = function(t4, e2) {
        return t4.$i || (t4(e2, _24, w2), t4.$i = true), w2;
      }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t4) {
        return w2(1e3 * t4);
      }, w2.en = D2[v2], w2.Ls = D2, w2.p = {}, w2;
    });
  }
});

// node_modules/dayjs/plugin/isoWeek.js
var require_isoWeek = __commonJS({
  "node_modules/dayjs/plugin/isoWeek.js"(exports, module2) {
    !function(e, t3) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = t3() : typeof define == "function" && define.amd ? define(t3) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_isoWeek = t3();
    }(exports, function() {
      "use strict";
      var e = "day";
      return function(t3, i2, s2) {
        var a2 = function(t4) {
          return t4.add(4 - t4.isoWeekday(), e);
        }, d2 = i2.prototype;
        d2.isoWeekYear = function() {
          return a2(this).year();
        }, d2.isoWeek = function(t4) {
          if (!this.$utils().u(t4))
            return this.add(7 * (t4 - this.isoWeek()), e);
          var i3, d3, n3, o2, r2 = a2(this), u2 = (i3 = this.isoWeekYear(), d3 = this.$u, n3 = (d3 ? s2.utc : s2)().year(i3).startOf("year"), o2 = 4 - n3.isoWeekday(), n3.isoWeekday() > 4 && (o2 += 7), n3.add(o2, e));
          return r2.diff(u2, "week") + 1;
        }, d2.isoWeekday = function(e2) {
          return this.$utils().u(e2) ? this.day() || 7 : this.day(this.day() % 7 ? e2 : e2 - 7);
        };
        var n2 = d2.startOf;
        d2.startOf = function(e2, t4) {
          var i3 = this.$utils(), s3 = !!i3.u(t4) || t4;
          return i3.p(e2) === "isoweek" ? s3 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n2.bind(this)(e2, t4);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/localizedFormat.js
var require_localizedFormat = __commonJS({
  "node_modules/dayjs/plugin/localizedFormat.js"(exports, module2) {
    !function(e, t3) {
      typeof exports == "object" && typeof module2 != "undefined" ? module2.exports = t3() : typeof define == "function" && define.amd ? define(t3) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_localizedFormat = t3();
    }(exports, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(t3, o2, n2) {
        var r2 = o2.prototype, i2 = r2.format;
        n2.en.formats = e, r2.format = function(t4) {
          t4 === void 0 && (t4 = "YYYY-MM-DDTHH:mm:ssZ");
          var o3 = this.$locale().formats, n3 = function(t5, o4) {
            return t5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n4, r3) {
              var i3 = r3 && r3.toUpperCase();
              return n4 || o4[r3] || e[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t7, o5) {
                return t7 || o5.slice(1);
              });
            });
          }(t4, o3 === void 0 ? {} : o3);
          return i2.call(this, n3);
        };
      };
    });
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d2[p2] = b2[p2];
      };
      __extends2 = function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign2 = Object.assign || function(t3) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t3[p2] = s2[p2];
        }
        return t3;
      };
      __rest2 = function(s2, e) {
        var t3 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
            t3[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t3[p2[i2]] = s2[p2[i2]];
          }
        return t3;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _24 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f2, y2, t3, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_24)
            try {
              if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
                return t3;
              if (y2 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _24.label++;
                  return { value: op[1], done: false };
                case 5:
                  _24.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _24.ops.pop();
                  _24.trys.pop();
                  continue;
                default:
                  if (!(t3 = _24.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _24 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _24.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _24.label < t3[1]) {
                    _24.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _24.label < t3[2]) {
                    _24.label = t3[2];
                    _24.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _24.ops.pop();
                  _24.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _24);
            } catch (e) {
              op = [6, e];
              y2 = 0;
            } finally {
              f2 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o2) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
            __createBinding2(o2, m, p2);
      };
      __createBinding2 = Object.create ? function(o2, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o2, k22, { enumerable: true, get: function() {
          return m[k2];
        } });
      } : function(o2, m, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m[k2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i2 = 0;
        if (m)
          return m.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o2, n2) {
        var m = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m)
          return o2;
        var i2 = m.call(o2), r2, ar = [], e;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar.push(r2.value);
        } catch (error2) {
          e = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m = i2["return"]))
              m.call(i2);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read2(arguments[i2]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v2) {
        return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e) {
            settle(q2[0][3], e);
          }
        }
        function step(r2) {
          r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator2 = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues2 = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o2[Symbol.asyncIterator], i2;
        return m ? m.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding2(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a2, b2) {
        return Object.prototype.hasOwnProperty.call(a2, b2);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k2;
          for (k2 in obj) {
            if (hasOwnProp(obj, k2)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn3) {
        var res = [], i2, arrLen = arr.length;
        for (i2 = 0; i2 < arrLen; ++i2) {
          res.push(fn3(arr[i2], i2));
        }
        return res;
      }
      function extend2(a2, b2) {
        for (var i2 in b2) {
          if (hasOwnProp(b2, i2)) {
            a2[i2] = b2[i2];
          }
        }
        if (hasOwnProp(b2, "toString")) {
          a2.toString = b2.toString;
        }
        if (hasOwnProp(b2, "valueOf")) {
          a2.valueOf = b2.valueOf;
        }
        return a2;
      }
      function createUTC(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t3 = Object(this), len = t3.length >>> 0, i2;
          for (i2 = 0; i2 < len; i2++) {
            if (i2 in t3 && fun.call(this, t3[i2], i2, t3)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i2) {
            return i2 != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend2(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i2, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i2 = 0; i2 < momentPropertiesLen; i2++) {
            prop = momentProperties[i2];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn3) {
        var firstTime = true;
        return extend2(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i2, key, argLen = arguments.length;
            for (i2 = 0; i2 < argLen; i2++) {
              arg = "";
              if (typeof arguments[i2] === "object") {
                arg += "\n[" + i2 + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i2];
              }
              args.push(arg);
            }
            warn2(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn3.apply(this, arguments);
        }, fn3);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i2;
        for (i2 in config) {
          if (hasOwnProp(config, i2)) {
            prop = config[i2];
            if (isFunction(prop)) {
              this[i2] = prop;
            } else {
              this["_" + i2] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend2({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend2(res[prop], parentConfig[prop]);
              extend2(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend2({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i2, res = [];
          for (i2 in obj) {
            if (hasOwnProp(obj, i2)) {
              res.push(i2);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output2 = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output2) ? output2.call(mom, now2) : output2;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func7 = callback;
        if (typeof callback === "string") {
          func7 = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func7;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func7.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(func7.apply(this, arguments), token2);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format3) {
        var array = format3.match(formattingTokens), i2, length;
        for (i2 = 0, length = array.length; i2 < length; i2++) {
          if (formatTokenFunctions[array[i2]]) {
            array[i2] = formatTokenFunctions[array[i2]];
          } else {
            array[i2] = removeFormattingTokens(array[i2]);
          }
        }
        return function(mom) {
          var output2 = "", i3;
          for (i3 = 0; i3 < length; i3++) {
            output2 += isFunction(array[i3]) ? array[i3].call(mom, format3) : array[i3];
          }
          return output2;
        };
      }
      function formatMoment(m, format3) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format3 = expandFormat(format3, m.localeData());
        formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
        return formatFunctions[format3](m);
      }
      function expandFormat(format3, locale2) {
        var i2 = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i2 >= 0 && localFormattingTokens.test(format3)) {
          format3 = format3.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i2 -= 1;
        }
        return format3;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format3 || !formatUpper) {
          return format3;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output2 = this._relativeTime[string];
        return isFunction(output2) ? output2(number, withoutSuffix, string, isFuture) : output2.replace(/%d/i, number);
      }
      function pastFuture(diff2, output2) {
        var format3 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format3) ? format3(output2) : format3.replace(/%s/i, output2);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u2;
        for (u2 in unitsObj) {
          if (hasOwnProp(unitsObj, u2)) {
            units.push({ unit: u2, priority: priorities[u2] });
          }
        }
        units.sort(function(a2, b2) {
          return a2.priority - b2.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get2(this, unit);
          }
        };
      }
      function get2(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
          for (i2 = 0; i2 < prioritizedLen; i2++) {
            this[prioritized[i2].unit](units[prioritized[i2].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape2(s2.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape2(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i2, func7 = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func7 = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          tokens[token2[i2]] = func7;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n2, x2) {
        return (n2 % x2 + x2) % x2;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o2) {
          var i2;
          for (i2 = 0; i2 < this.length; ++i2) {
            if (this[i2] === o2) {
              return i2;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format3) {
        return this.localeData().monthsShort(this, format3);
      });
      addFormatToken("MMMM", 0, 0, function(format3) {
        return this.localeData().months(this, format3);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format3) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format3) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format3, strict) {
        var i2, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i2 = 0; i2 < 12; ++i2) {
            mom = createUTC([2e3, i2]);
            this._shortMonthsParse[i2] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format3, strict) {
        var i2, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format3, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          if (strict && !this._longMonthsParse[i2]) {
            this._longMonthsParse[i2] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i2] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i2]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (strict && format3 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
            return i2;
          } else if (!strict && this._monthsParse[i2].test(monthName)) {
            return i2;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get2(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
        for (i2 = 0; i2 < 12; i2++) {
          mom = createUTC([2e3, i2]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i2 = 0; i2 < 12; i2++) {
          shortPieces[i2] = regexEscape2(shortPieces[i2]);
          longPieces[i2] = regexEscape2(longPieces[i2]);
        }
        for (i2 = 0; i2 < 24; i2++) {
          mixedPieces[i2] = regexEscape2(mixedPieces[i2]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      addFormatToken("Y", 0, 0, function() {
        var y2 = this.year();
        return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y2, m, d2, h2, M2, s2, ms) {
        var date;
        if (y2 < 100 && y2 >= 0) {
          date = new Date(y2 + 400, m, d2, h2, M2, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y2);
          }
        } else {
          date = new Date(y2, m, d2, h2, M2, s2, ms);
        }
        return date;
      }
      function createUTCDate(y2) {
        var date, args;
        if (y2 < 100 && y2 >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y2 + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y2);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format3) {
        return this.localeData().weekdaysMin(this, format3);
      });
      addFormatToken("ddd", 0, 0, function(format3) {
        return this.localeData().weekdaysShort(this, format3);
      });
      addFormatToken("dddd", 0, 0, function(format3) {
        return this.localeData().weekdays(this, format3);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n2) {
        return ws.slice(n2, 7).concat(ws.slice(0, n2));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format3) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format3, strict) {
        var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i2 = 0; i2 < 7; ++i2) {
            mom = createUTC([2e3, 1]).day(i2);
            this._minWeekdaysParse[i2] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i2] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format3 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format3 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format3, strict) {
        var i2, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format3, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          if (strict && !this._fullWeekdaysParse[i2]) {
            this._fullWeekdaysParse[i2] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i2] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i2] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i2]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format3 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (strict && format3 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
            return i2;
          } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
            return i2;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a2, b2) {
          return b2.length - a2.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
        for (i2 = 0; i2 < 7; i2++) {
          mom = createUTC([2e3, 1]).day(i2);
          minp = regexEscape2(this.weekdaysMin(mom, ""));
          shortp = regexEscape2(this.weekdaysShort(mom, ""));
          longp = regexEscape2(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i2, minl = Math.min(arr1.length, arr2.length);
        for (i2 = 0; i2 < minl; i2 += 1) {
          if (arr1[i2] !== arr2[i2]) {
            return i2;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i2 = 0, j2, next, locale2, split;
        while (i2 < names.length) {
          split = normalizeLocale(names[i2]).split("-");
          j2 = split.length;
          next = normalizeLocale(names[i2 + 1]);
          next = next ? next.split("-") : null;
          while (j2 > 0) {
            locale2 = loadLocale(split.slice(0, j2).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
              break;
            }
            j2--;
          }
          i2++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x2) {
              defineLocale(x2.name, x2.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a2 = m._a;
        if (a2 && getParsingFlags(m).overflow === -2) {
          overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i2, l2, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
            if (isoDates[i2][1].exec(match[1])) {
              dateFormat = isoDates[i2][0];
              allowTime = isoDates[i2][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
              if (isoTimes[i2][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i2][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
          return h2 * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function defaults2(a2, b2, c2) {
        if (a2 != null) {
          return a2;
        }
        if (b2 != null) {
          return b2;
        }
        return c2;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
          config._a[i2] = input[i2] = currentDate[i2];
        }
        for (; i2 < 7; i2++) {
          config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w2 = config._w;
        if (w2.GG != null || w2.W != null || w2.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults2(w2.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults2(w2.W, 1);
          weekday = defaults2(w2.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults2(w2.gg, config._a[YEAR], curWeek.year);
          week = defaults2(w2.w, curWeek.week);
          if (w2.d != null) {
            weekday = w2.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w2.e != null) {
            weekday = w2.e + dow;
            if (w2.e < 0 || w2.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i2 = 0; i2 < tokenLen; i2++) {
          token2 = tokens2[i2];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i2 = 0; i2 < configfLen; i2++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i2];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend2(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
        config._a = map([i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format3 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format3 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config._d = input;
        } else if (isArray(format3)) {
          configFromStringAndArray(config);
        } else if (format3) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
        var c2 = {};
        if (format3 === true || format3 === false) {
          strict = format3;
          format3 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c2._isAMomentObject = true;
        c2._useUTC = c2._isUTC = isUTC;
        c2._l = locale2;
        c2._i = input;
        c2._f = format3;
        c2._strict = strict;
        return createFromConfig(c2);
      }
      function createLocal(input, format3, locale2, strict) {
        return createLocalOrUTC(input, format3, locale2, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn3, moments) {
        var res, i2;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i2 = 1; i2 < moments.length; ++i2) {
          if (!moments[i2].isValid() || moments[i2][fn3](res)) {
            res = moments[i2];
          }
        }
        return res;
      }
      function min2() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max2() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i2, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i2 = 0; i2 < orderLen; ++i2) {
          if (m[ordering[i2]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset2(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset3 = this.utcOffset(), sign2 = "+";
          if (offset3 < 0) {
            offset3 = -offset3;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
        });
      }
      offset2("Z", ":");
      offset2("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches2 = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches2 === null) {
          return null;
        }
        chunk = matches2[matches2.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset3 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset3 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset3, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset3 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c2 = {}, other;
        copyConfig(c2, this);
        c2 = prepareConfig(c2);
        if (c2._a) {
          other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
          this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get2(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get2(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i2, property, propertyLen = properties.length;
        for (i2 = 0; i2 < propertyLen; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i2, property;
        for (i2 = 0; i2 < properties.length; i2 += 1) {
          property = properties[i2];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output2 = formats && (isFunction(formats[format3]) ? formats[format3].call(this, now2) : formats[format3]);
        return this.format(output2 || this.localeData().calendar(format3, this, createLocal(now2)));
      }
      function clone2() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output2;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output2 = monthDiff(this, that) / 12;
            break;
          case "month":
            output2 = monthDiff(this, that);
            break;
          case "quarter":
            output2 = monthDiff(this, that) / 3;
            break;
          case "second":
            output2 = (this - that) / 1e3;
            break;
          case "minute":
            output2 = (this - that) / 6e4;
            break;
          case "hour":
            output2 = (this - that) / 36e5;
            break;
          case "day":
            output2 = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output2 = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output2 = this - that;
        }
        return asFloat ? output2 : absFloor(output2);
      }
      function monthDiff(a2, b2) {
        if (a2.date() < b2.date()) {
          return -monthDiff(b2, a2);
        }
        var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b2 - anchor < 0) {
          anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b2 - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b2 - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func7 = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func7 = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func7 + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format2(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output2 = formatMoment(this, inputString);
        return this.localeData().postformat(output2);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y2, m, d2) {
        if (y2 < 100 && y2 >= 0) {
          return new Date(y2 + 400, m, d2) - MS_PER_400_YEARS;
        } else {
          return new Date(y2, m, d2).valueOf();
        }
      }
      function utcStartOfDate(y2, m, d2) {
        if (y2 < 100 && y2 >= 0) {
          return Date.UTC(y2 + 400, m, d2) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y2, m, d2);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend2({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format3) {
        var i2, l2, date, eras = this._eras || getLocale("en")._eras;
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          switch (typeof eras[i2].since) {
            case "string":
              date = hooks(eras[i2].since).startOf("day");
              eras[i2].since = date.valueOf();
              break;
          }
          switch (typeof eras[i2].until) {
            case "undefined":
              eras[i2].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i2].until).startOf("day").valueOf();
              eras[i2].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format3, strict) {
        var i2, l2, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          name = eras[i2].name.toUpperCase();
          abbr = eras[i2].abbr.toUpperCase();
          narrow = eras[i2].narrow.toUpperCase();
          if (strict) {
            switch (format3) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i2];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i2];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i2];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].name;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].narrow;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i2, l2, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until) {
            return eras[i2].abbr;
          }
          if (eras[i2].until <= val && val <= eras[i2].since) {
            return eras[i2].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i2, l2, dir, val, eras = this.localeData().eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          dir = eras[i2].since <= eras[i2].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
            return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
        for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
          namePieces.push(regexEscape2(eras[i2].name));
          abbrPieces.push(regexEscape2(eras[i2].abbr));
          narrowPieces.push(regexEscape2(eras[i2].narrow));
          mixedPieces.push(regexEscape2(eras[i2].name));
          mixedPieces.push(regexEscape2(eras[i2].abbr));
          mixedPieces.push(regexEscape2(eras[i2].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone2;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format2;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format3, index2, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index2);
        return locale2[field](utc, format3);
      }
      function listMonthsImpl(format3, index2, field) {
        if (isNumber2(format3)) {
          index2 = format3;
          format3 = void 0;
        }
        format3 = format3 || "";
        if (index2 != null) {
          return get$1(format3, index2, field, "month");
        }
        var i2, out = [];
        for (i2 = 0; i2 < 12; i2++) {
          out[i2] = get$1(format3, i2, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format3, index2, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format3)) {
            index2 = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        } else {
          format3 = localeSorted;
          index2 = format3;
          localeSorted = false;
          if (isNumber2(format3)) {
            index2 = format3;
            format3 = void 0;
          }
          format3 = format3 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
        if (index2 != null) {
          return get$1(format3, (index2 + shift) % 7, field, "day");
        }
        for (i2 = 0; i2 < 7; i2++) {
          out[i2] = get$1(format3, (i2 + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format3, index2) {
        return listMonthsImpl(format3, index2, "months");
      }
      function listMonthsShort(format3, index2) {
        return listMonthsImpl(format3, index2, "monthsShort");
      }
      function listWeekdays(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format3, index2) {
        return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b2 = number % 10, output2 = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
          return number + output2;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble2() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round2 = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a2[2] = withoutSuffix;
        a2[3] = +posNegDuration > 0;
        a2[4] = locale2;
        return substituteTimeAgo.apply(null, a2);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round2;
        }
        if (typeof roundingFunction === "function") {
          round2 = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output2;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output2 = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output2 = locale2.pastFuture(+this, output2);
        }
        return locale2.postformat(output2);
      }
      var abs$1 = Math.abs;
      function sign(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble2;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min2;
      hooks.max = max2;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }
});

// node_modules/svelte/internal/index.js
var require_internal = __commonJS({
  "node_modules/svelte/internal/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function noop3() {
    }
    var identity = (x2) => x2;
    function assign2(tar, src) {
      for (const k2 in src)
        tar[k2] = src[k2];
      return tar;
    }
    function is_promise2(value) {
      return value && typeof value === "object" && typeof value.then === "function";
    }
    function add_location(element3, file, line, column, char) {
      element3.__svelte_meta = {
        loc: { file, line, column, char }
      };
    }
    function run2(fn3) {
      return fn3();
    }
    function blank_object2() {
      return Object.create(null);
    }
    function run_all2(fns) {
      fns.forEach(run2);
    }
    function is_function2(thing) {
      return typeof thing === "function";
    }
    function safe_not_equal2(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
    }
    var src_url_equal_anchor2;
    function src_url_equal2(element_src, url) {
      if (!src_url_equal_anchor2) {
        src_url_equal_anchor2 = document.createElement("a");
      }
      src_url_equal_anchor2.href = url;
      return element_src === src_url_equal_anchor2.href;
    }
    function not_equal2(a2, b2) {
      return a2 != a2 ? b2 == b2 : a2 !== b2;
    }
    function is_empty2(obj) {
      return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== "function") {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }
    function subscribe2(store, ...callbacks) {
      if (store == null) {
        return noop3;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value2(store) {
      let value;
      subscribe2(store, (_24) => value = _24)();
      return value;
    }
    function component_subscribe2(component, store, callback) {
      component.$$.on_destroy.push(subscribe2(store, callback));
    }
    function create_slot2(definition, ctx, $$scope, fn3) {
      if (definition) {
        const slot_ctx = get_slot_context2(definition, ctx, $$scope, fn3);
        return definition[0](slot_ctx);
      }
    }
    function get_slot_context2(definition, ctx, $$scope, fn3) {
      return definition[1] && fn3 ? assign2($$scope.ctx.slice(), definition[1](fn3(ctx))) : $$scope.ctx;
    }
    function get_slot_changes2(definition, $$scope, dirty, fn3) {
      if (definition[2] && fn3) {
        const lets = definition[2](fn3(dirty));
        if ($$scope.dirty === void 0) {
          return lets;
        }
        if (typeof lets === "object") {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);
          for (let i2 = 0; i2 < len; i2 += 1) {
            merged[i2] = $$scope.dirty[i2] | lets[i2];
          }
          return merged;
        }
        return $$scope.dirty | lets;
      }
      return $$scope.dirty;
    }
    function update_slot_base2(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
      if (slot_changes) {
        const slot_context = get_slot_context2(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes2(slot_definition, $$scope, dirty, get_slot_changes_fn);
      update_slot_base2(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
    }
    function get_all_dirty_from_scope2($$scope) {
      if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i2 = 0; i2 < length; i2++) {
          dirty[i2] = -1;
        }
        return dirty;
      }
      return -1;
    }
    function exclude_internal_props(props) {
      const result = {};
      for (const k2 in props)
        if (k2[0] !== "$")
          result[k2] = props[k2];
      return result;
    }
    function compute_rest_props(props, keys) {
      const rest = {};
      keys = new Set(keys);
      for (const k2 in props)
        if (!keys.has(k2) && k2[0] !== "$")
          rest[k2] = props[k2];
      return rest;
    }
    function compute_slots2(slots) {
      const result = {};
      for (const key in slots) {
        result[key] = true;
      }
      return result;
    }
    function once(fn3) {
      let ran = false;
      return function(...args) {
        if (ran)
          return;
        ran = true;
        fn3.call(this, ...args);
      };
    }
    function null_to_empty2(value) {
      return value == null ? "" : value;
    }
    function set_store_value(store, ret, value) {
      store.set(value);
      return ret;
    }
    var has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    function action_destroyer2(action_result) {
      return action_result && is_function2(action_result.destroy) ? action_result.destroy : noop3;
    }
    var is_client = typeof window !== "undefined";
    exports.now = is_client ? () => window.performance.now() : () => Date.now();
    exports.raf = is_client ? (cb) => requestAnimationFrame(cb) : noop3;
    function set_now(fn3) {
      exports.now = fn3;
    }
    function set_raf(fn3) {
      exports.raf = fn3;
    }
    var tasks2 = new Set();
    function run_tasks(now) {
      tasks2.forEach((task) => {
        if (!task.c(now)) {
          tasks2.delete(task);
          task.f();
        }
      });
      if (tasks2.size !== 0)
        exports.raf(run_tasks);
    }
    function clear_loops() {
      tasks2.clear();
    }
    function loop(callback) {
      let task;
      if (tasks2.size === 0)
        exports.raf(run_tasks);
      return {
        promise: new Promise((fulfill) => {
          tasks2.add(task = { c: callback, f: fulfill });
        }),
        abort() {
          tasks2.delete(task);
        }
      };
    }
    var is_hydrating2 = false;
    function start_hydrating2() {
      is_hydrating2 = true;
    }
    function end_hydrating2() {
      is_hydrating2 = false;
    }
    function upper_bound(low, high, key, value) {
      while (low < high) {
        const mid = low + (high - low >> 1);
        if (key(mid) <= value) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    }
    function init_hydrate(target) {
      if (target.hydrate_init)
        return;
      target.hydrate_init = true;
      let children3 = target.childNodes;
      if (target.nodeName === "HEAD") {
        const myChildren = [];
        for (let i2 = 0; i2 < children3.length; i2++) {
          const node = children3[i2];
          if (node.claim_order !== void 0) {
            myChildren.push(node);
          }
        }
        children3 = myChildren;
      }
      const m = new Int32Array(children3.length + 1);
      const p2 = new Int32Array(children3.length);
      m[0] = -1;
      let longest = 0;
      for (let i2 = 0; i2 < children3.length; i2++) {
        const current = children3[i2].claim_order;
        const seqLen = (longest > 0 && children3[m[longest]].claim_order <= current ? longest + 1 : upper_bound(1, longest, (idx) => children3[m[idx]].claim_order, current)) - 1;
        p2[i2] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        m[newLen] = i2;
        longest = Math.max(newLen, longest);
      }
      const lis = [];
      const toMove = [];
      let last = children3.length - 1;
      for (let cur = m[longest] + 1; cur != 0; cur = p2[cur - 1]) {
        lis.push(children3[cur - 1]);
        for (; last >= cur; last--) {
          toMove.push(children3[last]);
        }
        last--;
      }
      for (; last >= 0; last--) {
        toMove.push(children3[last]);
      }
      lis.reverse();
      toMove.sort((a2, b2) => a2.claim_order - b2.claim_order);
      for (let i2 = 0, j2 = 0; i2 < toMove.length; i2++) {
        while (j2 < lis.length && toMove[i2].claim_order >= lis[j2].claim_order) {
          j2++;
        }
        const anchor = j2 < lis.length ? lis[j2] : null;
        target.insertBefore(toMove[i2], anchor);
      }
    }
    function append2(target, node) {
      target.appendChild(node);
    }
    function append_styles2(target, style_sheet_id, styles) {
      const append_styles_to = get_root_for_style2(target);
      if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element2("style");
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet2(append_styles_to, style);
      }
    }
    function get_root_for_style2(node) {
      if (!node)
        return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
      if (root && root.host) {
        return root;
      }
      return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
      const style_element = element2("style");
      append_stylesheet2(get_root_for_style2(node), style_element);
      return style_element.sheet;
    }
    function append_stylesheet2(node, style) {
      append2(node.head || node, style);
      return style.sheet;
    }
    function append_hydration(target, node) {
      if (is_hydrating2) {
        init_hydrate(target);
        if (target.actual_end_child === void 0 || target.actual_end_child !== null && target.actual_end_child.parentNode !== target) {
          target.actual_end_child = target.firstChild;
        }
        while (target.actual_end_child !== null && target.actual_end_child.claim_order === void 0) {
          target.actual_end_child = target.actual_end_child.nextSibling;
        }
        if (node !== target.actual_end_child) {
          if (node.claim_order !== void 0 || node.parentNode !== target) {
            target.insertBefore(node, target.actual_end_child);
          }
        } else {
          target.actual_end_child = node.nextSibling;
        }
      } else if (node.parentNode !== target || node.nextSibling !== null) {
        target.appendChild(node);
      }
    }
    function insert2(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }
    function insert_hydration(target, node, anchor) {
      if (is_hydrating2 && !anchor) {
        append_hydration(target, node);
      } else if (node.parentNode !== target || node.nextSibling != anchor) {
        target.insertBefore(node, anchor || null);
      }
    }
    function detach2(node) {
      node.parentNode.removeChild(node);
    }
    function destroy_each2(iterations, detaching) {
      for (let i2 = 0; i2 < iterations.length; i2 += 1) {
        if (iterations[i2])
          iterations[i2].d(detaching);
      }
    }
    function element2(name) {
      return document.createElement(name);
    }
    function element_is(name, is2) {
      return document.createElement(name, { is: is2 });
    }
    function object_without_properties(obj, exclude) {
      const target = {};
      for (const k2 in obj) {
        if (has_prop(obj, k2) && exclude.indexOf(k2) === -1) {
          target[k2] = obj[k2];
        }
      }
      return target;
    }
    function svg_element(name) {
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }
    function text2(data) {
      return document.createTextNode(data);
    }
    function space2() {
      return text2(" ");
    }
    function empty2() {
      return text2("");
    }
    function listen2(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn3) {
      return function(event) {
        event.preventDefault();
        return fn3.call(this, event);
      };
    }
    function stop_propagation2(fn3) {
      return function(event) {
        event.stopPropagation();
        return fn3.call(this, event);
      };
    }
    function self2(fn3) {
      return function(event) {
        if (event.target === this)
          fn3.call(this, event);
      };
    }
    function trusted(fn3) {
      return function(event) {
        if (event.isTrusted)
          fn3.call(this, event);
      };
    }
    function attr2(node, attribute, value) {
      if (value == null)
        node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
    }
    function set_attributes2(node, attributes) {
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === "style") {
          node.style.cssText = attributes[key];
        } else if (key === "__value") {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr2(node, key, attributes[key]);
        }
      }
    }
    function set_svg_attributes(node, attributes) {
      for (const key in attributes) {
        attr2(node, key, attributes[key]);
      }
    }
    function set_custom_element_data(node, prop, value) {
      if (prop in node) {
        node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
      } else {
        attr2(node, prop, value);
      }
    }
    function xlink_attr(node, attribute, value) {
      node.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
    }
    function get_binding_group_value(group, __value, checked) {
      const value = new Set();
      for (let i2 = 0; i2 < group.length; i2 += 1) {
        if (group[i2].checked)
          value.add(group[i2].__value);
      }
      if (!checked) {
        value.delete(__value);
      }
      return Array.from(value);
    }
    function to_number2(value) {
      return value === "" ? null : +value;
    }
    function time_ranges_to_array(ranges) {
      const array = [];
      for (let i2 = 0; i2 < ranges.length; i2 += 1) {
        array.push({ start: ranges.start(i2), end: ranges.end(i2) });
      }
      return array;
    }
    function children2(element3) {
      return Array.from(element3.childNodes);
    }
    function init_claim_info(nodes) {
      if (nodes.claim_info === void 0) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
      }
    }
    function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
      init_claim_info(nodes);
      const resultNode = (() => {
        for (let i2 = nodes.claim_info.last_index; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if (predicate(node)) {
            const replacement = processNode(node);
            if (replacement === void 0) {
              nodes.splice(i2, 1);
            } else {
              nodes[i2] = replacement;
            }
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i2;
            }
            return node;
          }
        }
        for (let i2 = nodes.claim_info.last_index - 1; i2 >= 0; i2--) {
          const node = nodes[i2];
          if (predicate(node)) {
            const replacement = processNode(node);
            if (replacement === void 0) {
              nodes.splice(i2, 1);
            } else {
              nodes[i2] = replacement;
            }
            if (!dontUpdateLastIndex) {
              nodes.claim_info.last_index = i2;
            } else if (replacement === void 0) {
              nodes.claim_info.last_index--;
            }
            return node;
          }
        }
        return createNode();
      })();
      resultNode.claim_order = nodes.claim_info.total_claimed;
      nodes.claim_info.total_claimed += 1;
      return resultNode;
    }
    function claim_element_base(nodes, name, attributes, create_element) {
      return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j2 = 0; j2 < node.attributes.length; j2++) {
          const attribute = node.attributes[j2];
          if (!attributes[attribute.name]) {
            remove.push(attribute.name);
          }
        }
        remove.forEach((v2) => node.removeAttribute(v2));
        return void 0;
      }, () => create_element(name));
    }
    function claim_element(nodes, name, attributes) {
      return claim_element_base(nodes, name, attributes, element2);
    }
    function claim_svg_element(nodes, name, attributes) {
      return claim_element_base(nodes, name, attributes, svg_element);
    }
    function claim_text(nodes, data) {
      return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
        const dataStr = "" + data;
        if (node.data.startsWith(dataStr)) {
          if (node.data.length !== dataStr.length) {
            return node.splitText(dataStr.length);
          }
        } else {
          node.data = dataStr;
        }
      }, () => text2(data), true);
    }
    function claim_space(nodes) {
      return claim_text(nodes, " ");
    }
    function find_comment(nodes, text3, start2) {
      for (let i2 = start2; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        if (node.nodeType === 8 && node.textContent.trim() === text3) {
          return i2;
        }
      }
      return nodes.length;
    }
    function claim_html_tag(nodes, is_svg) {
      const start_index = find_comment(nodes, "HTML_TAG_START", 0);
      const end_index = find_comment(nodes, "HTML_TAG_END", start_index);
      if (start_index === end_index) {
        return new HtmlTagHydration(void 0, is_svg);
      }
      init_claim_info(nodes);
      const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
      detach2(html_tag_nodes[0]);
      detach2(html_tag_nodes[html_tag_nodes.length - 1]);
      const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
      for (const n2 of claimed_nodes) {
        n2.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
      }
      return new HtmlTagHydration(claimed_nodes, is_svg);
    }
    function set_data2(text3, data) {
      data = "" + data;
      if (text3.wholeText !== data)
        text3.data = data;
    }
    function set_input_value2(input, value) {
      input.value = value == null ? "" : value;
    }
    function set_input_type(input, type) {
      try {
        input.type = type;
      } catch (e) {
      }
    }
    function set_style2(node, key, value, important) {
      if (value === null) {
        node.style.removeProperty(key);
      } else {
        node.style.setProperty(key, value, important ? "important" : "");
      }
    }
    function select_option2(select, value) {
      for (let i2 = 0; i2 < select.options.length; i2 += 1) {
        const option2 = select.options[i2];
        if (option2.__value === value) {
          option2.selected = true;
          return;
        }
      }
      select.selectedIndex = -1;
    }
    function select_options(select, value) {
      for (let i2 = 0; i2 < select.options.length; i2 += 1) {
        const option2 = select.options[i2];
        option2.selected = ~value.indexOf(option2.__value);
      }
    }
    function select_value(select) {
      const selected_option = select.querySelector(":checked") || select.options[0];
      return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
      return [].map.call(select.querySelectorAll(":checked"), (option2) => option2.__value);
    }
    var crossorigin;
    function is_crossorigin() {
      if (crossorigin === void 0) {
        crossorigin = false;
        try {
          if (typeof window !== "undefined" && window.parent) {
            void window.parent.document;
          }
        } catch (error2) {
          crossorigin = true;
        }
      }
      return crossorigin;
    }
    function add_resize_listener(node, fn3) {
      const computed_style = getComputedStyle(node);
      if (computed_style.position === "static") {
        node.style.position = "relative";
      }
      const iframe = element2("iframe");
      iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
      iframe.setAttribute("aria-hidden", "true");
      iframe.tabIndex = -1;
      const crossorigin2 = is_crossorigin();
      let unsubscribe;
      if (crossorigin2) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
        unsubscribe = listen2(window, "message", (event) => {
          if (event.source === iframe.contentWindow)
            fn3();
        });
      } else {
        iframe.src = "about:blank";
        iframe.onload = () => {
          unsubscribe = listen2(iframe.contentWindow, "resize", fn3);
        };
      }
      append2(node, iframe);
      return () => {
        if (crossorigin2) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }
        detach2(iframe);
      };
    }
    function toggle_class2(element3, name, toggle) {
      element3.classList[toggle ? "add" : "remove"](name);
    }
    function custom_event2(type, detail, { bubbles = false, cancelable = false } = {}) {
      const e = document.createEvent("CustomEvent");
      e.initCustomEvent(type, bubbles, cancelable, detail);
      return e;
    }
    function query_selector_all(selector, parent = document.body) {
      return Array.from(parent.querySelectorAll(selector));
    }
    var HtmlTag = class {
      constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
      }
      c(html) {
        this.h(html);
      }
      m(html, target, anchor = null) {
        if (!this.e) {
          if (this.is_svg)
            this.e = svg_element(target.nodeName);
          else
            this.e = element2(target.nodeName);
          this.t = target;
          this.c(html);
        }
        this.i(anchor);
      }
      h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }
      i(anchor) {
        for (let i2 = 0; i2 < this.n.length; i2 += 1) {
          insert2(this.t, this.n[i2], anchor);
        }
      }
      p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }
      d() {
        this.n.forEach(detach2);
      }
    };
    var HtmlTagHydration = class extends HtmlTag {
      constructor(claimed_nodes, is_svg = false) {
        super(is_svg);
        this.e = this.n = null;
        this.l = claimed_nodes;
      }
      c(html) {
        if (this.l) {
          this.n = this.l;
        } else {
          super.c(html);
        }
      }
      i(anchor) {
        for (let i2 = 0; i2 < this.n.length; i2 += 1) {
          insert_hydration(this.t, this.n[i2], anchor);
        }
      }
    };
    function attribute_to_object(attributes) {
      const result = {};
      for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
      }
      return result;
    }
    function get_custom_elements_slots(element3) {
      const result = {};
      element3.childNodes.forEach((node) => {
        result[node.slot || "default"] = true;
      });
      return result;
    }
    var managed_styles2 = new Map();
    var active = 0;
    function hash3(str) {
      let hash4 = 5381;
      let i2 = str.length;
      while (i2--)
        hash4 = (hash4 << 5) - hash4 ^ str.charCodeAt(i2);
      return hash4 >>> 0;
    }
    function create_style_information(doc, node) {
      const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
      managed_styles2.set(doc, info);
      return info;
    }
    function create_rule(node, a2, b2, duration, delay, ease, fn3, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = "{\n";
      for (let p2 = 0; p2 <= 1; p2 += step) {
        const t3 = a2 + (b2 - a2) * ease(p2);
        keyframes += p2 * 100 + `%{${fn3(t3, 1 - t3)}}
`;
      }
      const rule = keyframes + `100% {${fn3(b2, 1 - b2)}}
}`;
      const name = `__svelte_${hash3(rule)}_${uid}`;
      const doc = get_root_for_style2(node);
      const { stylesheet, rules } = managed_styles2.get(doc) || create_style_information(doc, node);
      if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }
      const animation = node.style.animation || "";
      node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }
    function delete_rule(node, name) {
      const previous = (node.style.animation || "").split(", ");
      const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
      const deleted = previous.length - next.length;
      if (deleted) {
        node.style.animation = next.join(", ");
        active -= deleted;
        if (!active)
          clear_rules();
      }
    }
    function clear_rules() {
      exports.raf(() => {
        if (active)
          return;
        managed_styles2.forEach((info) => {
          const { ownerNode } = info.stylesheet;
          if (ownerNode)
            detach2(ownerNode);
        });
        managed_styles2.clear();
      });
    }
    function create_animation(node, from, fn3, params) {
      if (!from)
        return noop3;
      const to = node.getBoundingClientRect();
      if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop3;
      const {
        delay = 0,
        duration = 300,
        easing = identity,
        start: start_time = exports.now() + delay,
        end: end2 = start_time + duration,
        tick: tick3 = noop3,
        css: css2
      } = fn3(node, { from, to }, params);
      let running = true;
      let started = false;
      let name;
      function start2() {
        if (css2) {
          name = create_rule(node, 0, 1, duration, delay, easing, css2);
        }
        if (!delay) {
          started = true;
        }
      }
      function stop() {
        if (css2)
          delete_rule(node, name);
        running = false;
      }
      loop((now) => {
        if (!started && now >= start_time) {
          started = true;
        }
        if (started && now >= end2) {
          tick3(1, 0);
          stop();
        }
        if (!running) {
          return false;
        }
        if (started) {
          const p2 = now - start_time;
          const t3 = 0 + 1 * easing(p2 / duration);
          tick3(t3, 1 - t3);
        }
        return true;
      });
      start2();
      tick3(0, 1);
      return stop;
    }
    function fix_position(node) {
      const style = getComputedStyle(node);
      if (style.position !== "absolute" && style.position !== "fixed") {
        const { width, height } = style;
        const a2 = node.getBoundingClientRect();
        node.style.position = "absolute";
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a2);
      }
    }
    function add_transform(node, a2) {
      const b2 = node.getBoundingClientRect();
      if (a2.left !== b2.left || a2.top !== b2.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === "none" ? "" : style.transform;
        node.style.transform = `${transform} translate(${a2.left - b2.left}px, ${a2.top - b2.top}px)`;
      }
    }
    function set_current_component2(component) {
      exports.current_component = component;
    }
    function get_current_component2() {
      if (!exports.current_component)
        throw new Error("Function called outside component initialization");
      return exports.current_component;
    }
    function beforeUpdate2(fn3) {
      get_current_component2().$$.before_update.push(fn3);
    }
    function onMount2(fn3) {
      get_current_component2().$$.on_mount.push(fn3);
    }
    function afterUpdate2(fn3) {
      get_current_component2().$$.after_update.push(fn3);
    }
    function onDestroy2(fn3) {
      get_current_component2().$$.on_destroy.push(fn3);
    }
    function createEventDispatcher2() {
      const component = get_current_component2();
      return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
          const event = custom_event2(type, detail, { cancelable });
          callbacks.slice().forEach((fn3) => {
            fn3.call(component, event);
          });
          return !event.defaultPrevented;
        }
        return true;
      };
    }
    function setContext2(key, context) {
      get_current_component2().$$.context.set(key, context);
      return context;
    }
    function getContext2(key) {
      return get_current_component2().$$.context.get(key);
    }
    function getAllContexts2() {
      return get_current_component2().$$.context;
    }
    function hasContext2(key) {
      return get_current_component2().$$.context.has(key);
    }
    function bubble2(component, event) {
      const callbacks = component.$$.callbacks[event.type];
      if (callbacks) {
        callbacks.slice().forEach((fn3) => fn3.call(this, event));
      }
    }
    var dirty_components2 = [];
    var intros = { enabled: false };
    var binding_callbacks2 = [];
    var render_callbacks2 = [];
    var flush_callbacks2 = [];
    var resolved_promise2 = Promise.resolve();
    var update_scheduled2 = false;
    function schedule_update2() {
      if (!update_scheduled2) {
        update_scheduled2 = true;
        resolved_promise2.then(flush2);
      }
    }
    function tick2() {
      schedule_update2();
      return resolved_promise2;
    }
    function add_render_callback2(fn3) {
      render_callbacks2.push(fn3);
    }
    function add_flush_callback2(fn3) {
      flush_callbacks2.push(fn3);
    }
    var seen_callbacks2 = new Set();
    var flushidx2 = 0;
    function flush2() {
      const saved_component = exports.current_component;
      do {
        while (flushidx2 < dirty_components2.length) {
          const component = dirty_components2[flushidx2];
          flushidx2++;
          set_current_component2(component);
          update2(component.$$);
        }
        set_current_component2(null);
        dirty_components2.length = 0;
        flushidx2 = 0;
        while (binding_callbacks2.length)
          binding_callbacks2.pop()();
        for (let i2 = 0; i2 < render_callbacks2.length; i2 += 1) {
          const callback = render_callbacks2[i2];
          if (!seen_callbacks2.has(callback)) {
            seen_callbacks2.add(callback);
            callback();
          }
        }
        render_callbacks2.length = 0;
      } while (dirty_components2.length);
      while (flush_callbacks2.length) {
        flush_callbacks2.pop()();
      }
      update_scheduled2 = false;
      seen_callbacks2.clear();
      set_current_component2(saved_component);
    }
    function update2($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all2($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback2);
      }
    }
    var promise;
    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }
      return promise;
    }
    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event2(`${direction ? "intro" : "outro"}${kind}`));
    }
    var outroing2 = new Set();
    var outros2;
    function group_outros2() {
      outros2 = {
        r: 0,
        c: [],
        p: outros2
      };
    }
    function check_outros2() {
      if (!outros2.r) {
        run_all2(outros2.c);
      }
      outros2 = outros2.p;
    }
    function transition_in2(block, local) {
      if (block && block.i) {
        outroing2.delete(block);
        block.i(local);
      }
    }
    function transition_out2(block, local, detach3, callback) {
      if (block && block.o) {
        if (outroing2.has(block))
          return;
        outroing2.add(block);
        outros2.c.push(() => {
          outroing2.delete(block);
          if (callback) {
            if (detach3)
              block.d(1);
            callback();
          }
        });
        block.o(local);
      } else if (callback) {
        callback();
      }
    }
    var null_transition = { duration: 0 };
    function create_in_transition(node, fn3, params) {
      let config = fn3(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;
      function cleanup() {
        if (animation_name)
          delete_rule(node, animation_name);
      }
      function go() {
        const { delay = 0, duration = 300, easing = identity, tick: tick3 = noop3, css: css2 } = config || null_transition;
        if (css2)
          animation_name = create_rule(node, 0, 1, duration, delay, easing, css2, uid++);
        tick3(0, 1);
        const start_time = exports.now() + delay;
        const end_time = start_time + duration;
        if (task)
          task.abort();
        running = true;
        add_render_callback2(() => dispatch(node, true, "start"));
        task = loop((now) => {
          if (running) {
            if (now >= end_time) {
              tick3(1, 0);
              dispatch(node, true, "end");
              cleanup();
              return running = false;
            }
            if (now >= start_time) {
              const t3 = easing((now - start_time) / duration);
              tick3(t3, 1 - t3);
            }
          }
          return running;
        });
      }
      let started = false;
      return {
        start() {
          if (started)
            return;
          started = true;
          delete_rule(node);
          if (is_function2(config)) {
            config = config();
            wait().then(go);
          } else {
            go();
          }
        },
        invalidate() {
          started = false;
        },
        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }
      };
    }
    function create_out_transition(node, fn3, params) {
      let config = fn3(node, params);
      let running = true;
      let animation_name;
      const group = outros2;
      group.r += 1;
      function go() {
        const { delay = 0, duration = 300, easing = identity, tick: tick3 = noop3, css: css2 } = config || null_transition;
        if (css2)
          animation_name = create_rule(node, 1, 0, duration, delay, easing, css2);
        const start_time = exports.now() + delay;
        const end_time = start_time + duration;
        add_render_callback2(() => dispatch(node, false, "start"));
        loop((now) => {
          if (running) {
            if (now >= end_time) {
              tick3(0, 1);
              dispatch(node, false, "end");
              if (!--group.r) {
                run_all2(group.c);
              }
              return false;
            }
            if (now >= start_time) {
              const t3 = easing((now - start_time) / duration);
              tick3(1 - t3, t3);
            }
          }
          return running;
        });
      }
      if (is_function2(config)) {
        wait().then(() => {
          config = config();
          go();
        });
      } else {
        go();
      }
      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }
          if (running) {
            if (animation_name)
              delete_rule(node, animation_name);
            running = false;
          }
        }
      };
    }
    function create_bidirectional_transition(node, fn3, params, intro) {
      let config = fn3(node, params);
      let t3 = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;
      function clear_animation() {
        if (animation_name)
          delete_rule(node, animation_name);
      }
      function init4(program, duration) {
        const d2 = program.b - t3;
        duration *= Math.abs(d2);
        return {
          a: t3,
          b: program.b,
          d: d2,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }
      function go(b2) {
        const { delay = 0, duration = 300, easing = identity, tick: tick3 = noop3, css: css2 } = config || null_transition;
        const program = {
          start: exports.now() + delay,
          b: b2
        };
        if (!b2) {
          program.group = outros2;
          outros2.r += 1;
        }
        if (running_program || pending_program) {
          pending_program = program;
        } else {
          if (css2) {
            clear_animation();
            animation_name = create_rule(node, t3, b2, duration, delay, easing, css2);
          }
          if (b2)
            tick3(0, 1);
          running_program = init4(program, duration);
          add_render_callback2(() => dispatch(node, b2, "start"));
          loop((now) => {
            if (pending_program && now > pending_program.start) {
              running_program = init4(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, "start");
              if (css2) {
                clear_animation();
                animation_name = create_rule(node, t3, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }
            if (running_program) {
              if (now >= running_program.end) {
                tick3(t3 = running_program.b, 1 - t3);
                dispatch(node, running_program.b, "end");
                if (!pending_program) {
                  if (running_program.b) {
                    clear_animation();
                  } else {
                    if (!--running_program.group.r)
                      run_all2(running_program.group.c);
                  }
                }
                running_program = null;
              } else if (now >= running_program.start) {
                const p2 = now - running_program.start;
                t3 = running_program.a + running_program.d * easing(p2 / running_program.duration);
                tick3(t3, 1 - t3);
              }
            }
            return !!(running_program || pending_program);
          });
        }
      }
      return {
        run(b2) {
          if (is_function2(config)) {
            wait().then(() => {
              config = config();
              go(b2);
            });
          } else {
            go(b2);
          }
        },
        end() {
          clear_animation();
          running_program = pending_program = null;
        }
      };
    }
    function handle_promise2(promise2, info) {
      const token = info.token = {};
      function update3(type, index2, key, value) {
        if (info.token !== token)
          return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== void 0) {
          child_ctx = child_ctx.slice();
          child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
          if (info.blocks) {
            info.blocks.forEach((block2, i2) => {
              if (i2 !== index2 && block2) {
                group_outros2();
                transition_out2(block2, 1, 1, () => {
                  if (info.blocks[i2] === block2) {
                    info.blocks[i2] = null;
                  }
                });
                check_outros2();
              }
            });
          } else {
            info.block.d(1);
          }
          block.c();
          transition_in2(block, 1);
          block.m(info.mount(), info.anchor);
          needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
          info.blocks[index2] = block;
        if (needs_flush) {
          flush2();
        }
      }
      if (is_promise2(promise2)) {
        const current_component2 = get_current_component2();
        promise2.then((value) => {
          set_current_component2(current_component2);
          update3(info.then, 1, info.value, value);
          set_current_component2(null);
        }, (error2) => {
          set_current_component2(current_component2);
          update3(info.catch, 2, info.error, error2);
          set_current_component2(null);
          if (!info.hasCatch) {
            throw error2;
          }
        });
        if (info.current !== info.pending) {
          update3(info.pending, 0);
          return true;
        }
      } else {
        if (info.current !== info.then) {
          update3(info.then, 1, info.value, promise2);
          return true;
        }
        info.resolved = promise2;
      }
    }
    function update_await_block_branch2(info, ctx, dirty) {
      const child_ctx = ctx.slice();
      const { resolved } = info;
      if (info.current === info.then) {
        child_ctx[info.value] = resolved;
      }
      if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
      }
      info.block.p(child_ctx, dirty);
    }
    var globals2 = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
    function destroy_block(block, lookup) {
      block.d(1);
      lookup.delete(block.key);
    }
    function outro_and_destroy_block2(block, lookup) {
      transition_out2(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }
    function fix_and_destroy_block(block, lookup) {
      block.f();
      destroy_block(block, lookup);
    }
    function fix_and_outro_and_destroy_block(block, lookup) {
      block.f();
      outro_and_destroy_block2(block, lookup);
    }
    function update_keyed_each2(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy2, create_each_block17, next, get_context2) {
      let o2 = old_blocks.length;
      let n2 = list.length;
      let i2 = o2;
      const old_indexes = {};
      while (i2--)
        old_indexes[old_blocks[i2].key] = i2;
      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i2 = n2;
      while (i2--) {
        const child_ctx = get_context2(ctx, list, i2);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
          block = create_each_block17(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i2] = block);
        if (key in old_indexes)
          deltas.set(key, Math.abs(i2 - old_indexes[key]));
      }
      const will_move = new Set();
      const did_move = new Set();
      function insert3(block) {
        transition_in2(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n2--;
      }
      while (o2 && n2) {
        const new_block = new_blocks[n2 - 1];
        const old_block = old_blocks[o2 - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
          next = new_block.first;
          o2--;
          n2--;
        } else if (!new_lookup.has(old_key)) {
          destroy2(old_block, lookup);
          o2--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert3(new_block);
        } else if (did_move.has(old_key)) {
          o2--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert3(new_block);
        } else {
          will_move.add(old_key);
          o2--;
        }
      }
      while (o2--) {
        const old_block = old_blocks[o2];
        if (!new_lookup.has(old_block.key))
          destroy2(old_block, lookup);
      }
      while (n2)
        insert3(new_blocks[n2 - 1]);
      return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context2, get_key) {
      const keys = new Set();
      for (let i2 = 0; i2 < list.length; i2++) {
        const key = get_key(get_context2(ctx, list, i2));
        if (keys.has(key)) {
          throw new Error("Cannot have duplicate keys in a keyed each");
        }
        keys.add(key);
      }
    }
    function get_spread_update2(levels, updates) {
      const update3 = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i2 = levels.length;
      while (i2--) {
        const o2 = levels[i2];
        const n2 = updates[i2];
        if (n2) {
          for (const key in o2) {
            if (!(key in n2))
              to_null_out[key] = 1;
          }
          for (const key in n2) {
            if (!accounted_for[key]) {
              update3[key] = n2[key];
              accounted_for[key] = 1;
            }
          }
          levels[i2] = n2;
        } else {
          for (const key in o2) {
            accounted_for[key] = 1;
          }
        }
      }
      for (const key in to_null_out) {
        if (!(key in update3))
          update3[key] = void 0;
      }
      return update3;
    }
    function get_spread_object(spread_props) {
      return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
    }
    var boolean_attributes2 = new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
    function is_void(name) {
      return void_element_names.test(name) || name.toLowerCase() === "!doctype";
    }
    var invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    function spread(args, attrs_to_add) {
      const attributes = Object.assign({}, ...args);
      if (attrs_to_add) {
        const classes_to_add = attrs_to_add.classes;
        const styles_to_add = attrs_to_add.styles;
        if (classes_to_add) {
          if (attributes.class == null) {
            attributes.class = classes_to_add;
          } else {
            attributes.class += " " + classes_to_add;
          }
        }
        if (styles_to_add) {
          if (attributes.style == null) {
            attributes.style = style_object_to_string(styles_to_add);
          } else {
            attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
          }
        }
      }
      let str = "";
      Object.keys(attributes).forEach((name) => {
        if (invalid_attribute_name_character.test(name))
          return;
        const value = attributes[name];
        if (value === true)
          str += " " + name;
        else if (boolean_attributes2.has(name.toLowerCase())) {
          if (value)
            str += " " + name;
        } else if (value != null) {
          str += ` ${name}="${value}"`;
        }
      });
      return str;
    }
    function merge_ssr_styles(style_attribute, style_directive) {
      const style_object = {};
      for (const individual_style of style_attribute.split(";")) {
        const colon_index = individual_style.indexOf(":");
        const name = individual_style.slice(0, colon_index).trim();
        const value = individual_style.slice(colon_index + 1).trim();
        if (!name)
          continue;
        style_object[name] = value;
      }
      for (const name in style_directive) {
        const value = style_directive[name];
        if (value) {
          style_object[name] = value;
        } else {
          delete style_object[name];
        }
      }
      return style_object;
    }
    var ATTR_REGEX = /[&"]/g;
    var CONTENT_REGEX = /[&<]/g;
    function escape2(value, is_attr = false) {
      const str = String(value);
      const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
      pattern.lastIndex = 0;
      let escaped = "";
      let last = 0;
      while (pattern.test(str)) {
        const i2 = pattern.lastIndex - 1;
        const ch = str[i2];
        escaped += str.substring(last, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
        last = i2 + 1;
      }
      return escaped + str.substring(last);
    }
    function escape_attribute_value(value) {
      const should_escape = typeof value === "string" || value && typeof value === "object";
      return should_escape ? escape2(value, true) : value;
    }
    function escape_object(obj) {
      const result = {};
      for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
      }
      return result;
    }
    function each(items, fn3) {
      let str = "";
      for (let i2 = 0; i2 < items.length; i2 += 1) {
        str += fn3(items[i2], i2);
      }
      return str;
    }
    var missing_component = {
      $$render: () => ""
    };
    function validate_component(component, name) {
      if (!component || !component.$$render) {
        if (name === "svelte:component")
          name += " this={...}";
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
      }
      return component;
    }
    function debug(file, line, column, values) {
      console.log(`{@debug} ${file ? file + " " : ""}(${line}:${column})`);
      console.log(values);
      return "";
    }
    var on_destroy;
    function create_ssr_component(fn3) {
      function $$render(result, props, bindings, slots, context) {
        const parent_component = exports.current_component;
        const $$ = {
          on_destroy,
          context: new Map(context || (parent_component ? parent_component.$$.context : [])),
          on_mount: [],
          before_update: [],
          after_update: [],
          callbacks: blank_object2()
        };
        set_current_component2({ $$ });
        const html = fn3(result, props, bindings, slots);
        set_current_component2(parent_component);
        return html;
      }
      return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
          on_destroy = [];
          const result = { title: "", head: "", css: new Set() };
          const html = $$render(result, props, {}, $$slots, context);
          run_all2(on_destroy);
          return {
            html,
            css: {
              code: Array.from(result.css).map((css2) => css2.code).join("\n"),
              map: null
            },
            head: result.title + result.head
          };
        },
        $$render
      };
    }
    function add_attribute(name, value, boolean) {
      if (value == null || boolean && !value)
        return "";
      const assignment = boolean && value === true ? "" : `="${escape2(value, true)}"`;
      return ` ${name}${assignment}`;
    }
    function add_classes(classes) {
      return classes ? ` class="${classes}"` : "";
    }
    function style_object_to_string(style_object) {
      return Object.keys(style_object).filter((key) => style_object[key]).map((key) => `${key}: ${style_object[key]};`).join(" ");
    }
    function add_styles(style_object) {
      const styles = style_object_to_string(style_object);
      return styles ? ` style="${styles}"` : "";
    }
    function bind2(component, name, callback) {
      const index2 = component.$$.props[name];
      if (index2 !== void 0) {
        component.$$.bound[index2] = callback;
        callback(component.$$.ctx[index2]);
      }
    }
    function create_component2(block) {
      block && block.c();
    }
    function claim_component(block, parent_nodes) {
      block && block.l(parent_nodes);
    }
    function mount_component2(component, target, anchor, customElement) {
      const { fragment, on_mount, on_destroy: on_destroy2, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      if (!customElement) {
        add_render_callback2(() => {
          const new_on_destroy = on_mount.map(run2).filter(is_function2);
          if (on_destroy2) {
            on_destroy2.push(...new_on_destroy);
          } else {
            run_all2(new_on_destroy);
          }
          component.$$.on_mount = [];
        });
      }
      after_update.forEach(add_render_callback2);
    }
    function destroy_component2(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
        run_all2($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }
    function make_dirty2(component, i2) {
      if (component.$$.dirty[0] === -1) {
        dirty_components2.push(component);
        schedule_update2();
        component.$$.dirty.fill(0);
      }
      component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
    }
    function init3(component, options, instance96, create_fragment96, not_equal3, props, append_styles3, dirty = [-1]) {
      const parent_component = exports.current_component;
      set_current_component2(component);
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        props,
        update: noop3,
        not_equal: not_equal3,
        bound: blank_object2(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        callbacks: blank_object2(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
      };
      append_styles3 && append_styles3($$.root);
      let ready = false;
      $$.ctx = instance96 ? instance96(component, options.props || {}, (i2, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;
        if ($$.ctx && not_equal3($$.ctx[i2], $$.ctx[i2] = value)) {
          if (!$$.skip_bound && $$.bound[i2])
            $$.bound[i2](value);
          if (ready)
            make_dirty2(component, i2);
        }
        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all2($$.before_update);
      $$.fragment = create_fragment96 ? create_fragment96($$.ctx) : false;
      if (options.target) {
        if (options.hydrate) {
          start_hydrating2();
          const nodes = children2(options.target);
          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach2);
        } else {
          $$.fragment && $$.fragment.c();
        }
        if (options.intro)
          transition_in2(component.$$.fragment);
        mount_component2(component, options.target, options.anchor, options.customElement);
        end_hydrating2();
        flush2();
      }
      set_current_component2(parent_component);
    }
    if (typeof HTMLElement === "function") {
      exports.SvelteElement = class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          const { on_mount } = this.$$;
          this.$$.on_disconnect = on_mount.map(run2).filter(is_function2);
          for (const key in this.$$.slotted) {
            this.appendChild(this.$$.slotted[key]);
          }
        }
        attributeChangedCallback(attr3, _oldValue, newValue) {
          this[attr3] = newValue;
        }
        disconnectedCallback() {
          run_all2(this.$$.on_disconnect);
        }
        $destroy() {
          destroy_component2(this, 1);
          this.$destroy = noop3;
        }
        $on(type, callback) {
          const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return () => {
            const index2 = callbacks.indexOf(callback);
            if (index2 !== -1)
              callbacks.splice(index2, 1);
          };
        }
        $set($$props) {
          if (this.$$set && !is_empty2($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      };
    }
    var SvelteComponent2 = class {
      $destroy() {
        destroy_component2(this, 1);
        this.$destroy = noop3;
      }
      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index2 = callbacks.indexOf(callback);
          if (index2 !== -1)
            callbacks.splice(index2, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty2($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event2(type, Object.assign({ version: "3.50.1" }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append2(target, node);
    }
    function append_hydration_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append_hydration(target, node);
    }
    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert2(target, node, anchor);
    }
    function insert_hydration_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert_hydration(target, node, anchor);
    }
    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", { node });
      detach2(node);
    }
    function detach_between_dev(before, after) {
      while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
      }
    }
    function detach_before_dev(after) {
      while (after.previousSibling) {
        detach_dev(after.previousSibling);
      }
    }
    function detach_after_dev(before) {
      while (before.nextSibling) {
        detach_dev(before.nextSibling);
      }
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
        modifiers.push("preventDefault");
      if (has_stop_propagation)
        modifiers.push("stopPropagation");
      dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
      const dispose = listen2(node, event, handler, options);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
      };
    }
    function attr_dev(node, attribute, value) {
      attr2(node, attribute, value);
      if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
      else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function dataset_dev(node, property, value) {
      node.dataset[property] = value;
      dispatch_dev("SvelteDOMSetDataset", { node, property, value });
    }
    function set_data_dev(text3, data) {
      data = "" + data;
      if (text3.wholeText === data)
        return;
      dispatch_dev("SvelteDOMSetData", { node: text3, data });
      text3.data = data;
    }
    function validate_each_argument(arg) {
      if (typeof arg !== "string" && !(arg && typeof arg === "object" && "length" in arg)) {
        let msg = "{#each} only iterates over array-like objects.";
        if (typeof Symbol === "function" && arg && Symbol.iterator in arg) {
          msg += " You can use a spread to convert this iterable into an array.";
        }
        throw new Error(msg);
      }
    }
    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }
    function validate_dynamic_element(tag) {
      const is_string = typeof tag === "string";
      if (tag && !is_string) {
        throw new Error('<svelte:element> expects "this" attribute to be a string.');
      }
    }
    function validate_void_dynamic_element(tag) {
      if (tag && is_void(tag)) {
        throw new Error(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
      }
    }
    var SvelteComponentDev2 = class extends SvelteComponent2 {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error("'target' is a required option");
        }
        super();
      }
      $destroy() {
        super.$destroy();
        this.$destroy = () => {
          console.warn("Component was already destroyed");
        };
      }
      $capture_state() {
      }
      $inject_state() {
      }
    };
    var SvelteComponentTyped2 = class extends SvelteComponentDev2 {
      constructor(options) {
        super(options);
      }
    };
    function loop_guard(timeout) {
      const start2 = Date.now();
      return () => {
        if (Date.now() - start2 > timeout) {
          throw new Error("Infinite loop detected");
        }
      };
    }
    exports.HtmlTag = HtmlTag;
    exports.HtmlTagHydration = HtmlTagHydration;
    exports.SvelteComponent = SvelteComponent2;
    exports.SvelteComponentDev = SvelteComponentDev2;
    exports.SvelteComponentTyped = SvelteComponentTyped2;
    exports.action_destroyer = action_destroyer2;
    exports.add_attribute = add_attribute;
    exports.add_classes = add_classes;
    exports.add_flush_callback = add_flush_callback2;
    exports.add_location = add_location;
    exports.add_render_callback = add_render_callback2;
    exports.add_resize_listener = add_resize_listener;
    exports.add_styles = add_styles;
    exports.add_transform = add_transform;
    exports.afterUpdate = afterUpdate2;
    exports.append = append2;
    exports.append_dev = append_dev;
    exports.append_empty_stylesheet = append_empty_stylesheet;
    exports.append_hydration = append_hydration;
    exports.append_hydration_dev = append_hydration_dev;
    exports.append_styles = append_styles2;
    exports.assign = assign2;
    exports.attr = attr2;
    exports.attr_dev = attr_dev;
    exports.attribute_to_object = attribute_to_object;
    exports.beforeUpdate = beforeUpdate2;
    exports.bind = bind2;
    exports.binding_callbacks = binding_callbacks2;
    exports.blank_object = blank_object2;
    exports.bubble = bubble2;
    exports.check_outros = check_outros2;
    exports.children = children2;
    exports.claim_component = claim_component;
    exports.claim_element = claim_element;
    exports.claim_html_tag = claim_html_tag;
    exports.claim_space = claim_space;
    exports.claim_svg_element = claim_svg_element;
    exports.claim_text = claim_text;
    exports.clear_loops = clear_loops;
    exports.component_subscribe = component_subscribe2;
    exports.compute_rest_props = compute_rest_props;
    exports.compute_slots = compute_slots2;
    exports.createEventDispatcher = createEventDispatcher2;
    exports.create_animation = create_animation;
    exports.create_bidirectional_transition = create_bidirectional_transition;
    exports.create_component = create_component2;
    exports.create_in_transition = create_in_transition;
    exports.create_out_transition = create_out_transition;
    exports.create_slot = create_slot2;
    exports.create_ssr_component = create_ssr_component;
    exports.custom_event = custom_event2;
    exports.dataset_dev = dataset_dev;
    exports.debug = debug;
    exports.destroy_block = destroy_block;
    exports.destroy_component = destroy_component2;
    exports.destroy_each = destroy_each2;
    exports.detach = detach2;
    exports.detach_after_dev = detach_after_dev;
    exports.detach_before_dev = detach_before_dev;
    exports.detach_between_dev = detach_between_dev;
    exports.detach_dev = detach_dev;
    exports.dirty_components = dirty_components2;
    exports.dispatch_dev = dispatch_dev;
    exports.each = each;
    exports.element = element2;
    exports.element_is = element_is;
    exports.empty = empty2;
    exports.end_hydrating = end_hydrating2;
    exports.escape = escape2;
    exports.escape_attribute_value = escape_attribute_value;
    exports.escape_object = escape_object;
    exports.exclude_internal_props = exclude_internal_props;
    exports.fix_and_destroy_block = fix_and_destroy_block;
    exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
    exports.fix_position = fix_position;
    exports.flush = flush2;
    exports.getAllContexts = getAllContexts2;
    exports.getContext = getContext2;
    exports.get_all_dirty_from_scope = get_all_dirty_from_scope2;
    exports.get_binding_group_value = get_binding_group_value;
    exports.get_current_component = get_current_component2;
    exports.get_custom_elements_slots = get_custom_elements_slots;
    exports.get_root_for_style = get_root_for_style2;
    exports.get_slot_changes = get_slot_changes2;
    exports.get_spread_object = get_spread_object;
    exports.get_spread_update = get_spread_update2;
    exports.get_store_value = get_store_value2;
    exports.globals = globals2;
    exports.group_outros = group_outros2;
    exports.handle_promise = handle_promise2;
    exports.hasContext = hasContext2;
    exports.has_prop = has_prop;
    exports.identity = identity;
    exports.init = init3;
    exports.insert = insert2;
    exports.insert_dev = insert_dev;
    exports.insert_hydration = insert_hydration;
    exports.insert_hydration_dev = insert_hydration_dev;
    exports.intros = intros;
    exports.invalid_attribute_name_character = invalid_attribute_name_character;
    exports.is_client = is_client;
    exports.is_crossorigin = is_crossorigin;
    exports.is_empty = is_empty2;
    exports.is_function = is_function2;
    exports.is_promise = is_promise2;
    exports.is_void = is_void;
    exports.listen = listen2;
    exports.listen_dev = listen_dev;
    exports.loop = loop;
    exports.loop_guard = loop_guard;
    exports.merge_ssr_styles = merge_ssr_styles;
    exports.missing_component = missing_component;
    exports.mount_component = mount_component2;
    exports.noop = noop3;
    exports.not_equal = not_equal2;
    exports.null_to_empty = null_to_empty2;
    exports.object_without_properties = object_without_properties;
    exports.onDestroy = onDestroy2;
    exports.onMount = onMount2;
    exports.once = once;
    exports.outro_and_destroy_block = outro_and_destroy_block2;
    exports.prevent_default = prevent_default;
    exports.prop_dev = prop_dev;
    exports.query_selector_all = query_selector_all;
    exports.run = run2;
    exports.run_all = run_all2;
    exports.safe_not_equal = safe_not_equal2;
    exports.schedule_update = schedule_update2;
    exports.select_multiple_value = select_multiple_value;
    exports.select_option = select_option2;
    exports.select_options = select_options;
    exports.select_value = select_value;
    exports.self = self2;
    exports.setContext = setContext2;
    exports.set_attributes = set_attributes2;
    exports.set_current_component = set_current_component2;
    exports.set_custom_element_data = set_custom_element_data;
    exports.set_data = set_data2;
    exports.set_data_dev = set_data_dev;
    exports.set_input_type = set_input_type;
    exports.set_input_value = set_input_value2;
    exports.set_now = set_now;
    exports.set_raf = set_raf;
    exports.set_store_value = set_store_value;
    exports.set_style = set_style2;
    exports.set_svg_attributes = set_svg_attributes;
    exports.space = space2;
    exports.spread = spread;
    exports.src_url_equal = src_url_equal2;
    exports.start_hydrating = start_hydrating2;
    exports.stop_propagation = stop_propagation2;
    exports.subscribe = subscribe2;
    exports.svg_element = svg_element;
    exports.text = text2;
    exports.tick = tick2;
    exports.time_ranges_to_array = time_ranges_to_array;
    exports.to_number = to_number2;
    exports.toggle_class = toggle_class2;
    exports.transition_in = transition_in2;
    exports.transition_out = transition_out2;
    exports.trusted = trusted;
    exports.update_await_block_branch = update_await_block_branch2;
    exports.update_keyed_each = update_keyed_each2;
    exports.update_slot = update_slot;
    exports.update_slot_base = update_slot_base2;
    exports.validate_component = validate_component;
    exports.validate_dynamic_element = validate_dynamic_element;
    exports.validate_each_argument = validate_each_argument;
    exports.validate_each_keys = validate_each_keys;
    exports.validate_slots = validate_slots;
    exports.validate_store = validate_store;
    exports.validate_void_dynamic_element = validate_void_dynamic_element;
    exports.xlink_attr = xlink_attr;
  }
});

// node_modules/svelte/store/index.js
var require_store = __commonJS({
  "node_modules/svelte/store/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var internal = require_internal();
    var subscriber_queue2 = [];
    function readable2(value, start2) {
      return {
        subscribe: writable2(value, start2).subscribe
      };
    }
    function writable2(value, start2 = internal.noop) {
      let stop;
      const subscribers = new Set();
      function set(new_value) {
        if (internal.safe_not_equal(value, new_value)) {
          value = new_value;
          if (stop) {
            const run_queue = !subscriber_queue2.length;
            for (const subscriber of subscribers) {
              subscriber[1]();
              subscriber_queue2.push(subscriber, value);
            }
            if (run_queue) {
              for (let i2 = 0; i2 < subscriber_queue2.length; i2 += 2) {
                subscriber_queue2[i2][0](subscriber_queue2[i2 + 1]);
              }
              subscriber_queue2.length = 0;
            }
          }
        }
      }
      function update2(fn3) {
        set(fn3(value));
      }
      function subscribe2(run2, invalidate = internal.noop) {
        const subscriber = [run2, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
          stop = start2(set) || internal.noop;
        }
        run2(value);
        return () => {
          subscribers.delete(subscriber);
          if (subscribers.size === 0) {
            stop();
            stop = null;
          }
        };
      }
      return { set, update: update2, subscribe: subscribe2 };
    }
    function derived2(stores, fn3, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single ? [stores] : stores;
      const auto2 = fn3.length < 2;
      return readable2(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = internal.noop;
        const sync = () => {
          if (pending) {
            return;
          }
          cleanup();
          const result = fn3(single ? values[0] : values, set);
          if (auto2) {
            set(result);
          } else {
            cleanup = internal.is_function(result) ? result : internal.noop;
          }
        };
        const unsubscribers = stores_array.map((store, i2) => internal.subscribe(store, (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (inited) {
            sync();
          }
        }, () => {
          pending |= 1 << i2;
        }));
        inited = true;
        sync();
        return function stop() {
          internal.run_all(unsubscribers);
          cleanup();
        };
      });
    }
    Object.defineProperty(exports, "get", {
      enumerable: true,
      get: function() {
        return internal.get_store_value;
      }
    });
    exports.derived = derived2;
    exports.readable = readable2;
    exports.writable = writable2;
  }
});

// node_modules/svelte-i18next/translation-store.js
var require_translation_store = __commonJS({
  "node_modules/svelte-i18next/translation-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.I18NextTranslationStore = exports.isLoading = void 0;
    var store_1 = require_store();
    exports.isLoading = (0, store_1.writable)(true);
    var I18NextTranslationStore = class {
      constructor(i18n2) {
        this.i18n = this.createInstance(i18n2);
        this.isLoading = this.createLoadingInstance(i18n2);
      }
      createInstance(i18n2) {
        const i18nWritable = (0, store_1.writable)(i18n2);
        i18n2.on("initialized", () => {
          i18nWritable.set(i18n2);
        });
        i18n2.on("loaded", () => {
          i18nWritable.set(i18n2);
        });
        i18n2.on("added", () => i18nWritable.set(i18n2));
        i18n2.on("languageChanged", () => {
          i18nWritable.set(i18n2);
        });
        return i18nWritable;
      }
      createLoadingInstance(i18n2) {
        i18n2.on("loaded", (resources) => {
          Object.keys(resources).length !== 0 && exports.isLoading.set(false);
        });
        i18n2.on("failedLoading", () => {
          exports.isLoading.set(true);
        });
        return exports.isLoading;
      }
    };
    exports.I18NextTranslationStore = I18NextTranslationStore;
  }
});

// node_modules/svelte-i18next/i18n.js
var require_i18n = __commonJS({
  "node_modules/svelte-i18next/i18n.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createI18nStore = void 0;
    var translation_store_1 = require_translation_store();
    var createI18nStore2 = (i18n2) => {
      const i18nStore = new translation_store_1.I18NextTranslationStore(i18n2);
      return i18nStore.i18n;
    };
    exports.createI18nStore = createI18nStore2;
  }
});

// node_modules/svelte-i18next/index.js
var require_svelte_i18next = __commonJS({
  "node_modules/svelte-i18next/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m[k2];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding2(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_i18n(), exports);
    __exportStar2(require_translation_store(), exports);
  }
});

// src/main.ts
__export(exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => ProjectsPlugin
});

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run(fn3) {
  return fn3();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
var src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_24) => value = _24)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn3) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn3);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn3) {
  return definition[1] && fn3 ? assign($$scope.ctx.slice(), definition[1](fn3(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn3) {
  if (definition[2] && fn3) {
    const lets = definition[2](fn3(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn3) {
  return function(event) {
    event.stopPropagation();
    return fn3.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value) {
  for (let i2 = 0; i2 < select.options.length; i2 += 1) {
    const option2 = select.options[i2];
    if (option2.__value === value) {
      option2.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = new Map();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn3) {
  get_current_component().$$.on_mount.push(fn3);
}
function onDestroy(fn3) {
  get_current_component().$$.on_destroy.push(fn3);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn3) => {
        fn3.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn3) => fn3.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn3) {
  render_callbacks.push(fn3);
}
function add_flush_callback(fn3) {
  flush_callbacks.push(fn3);
}
var seen_callbacks = new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function handle_promise(promise, info) {
  const token = info.token = {};
  function update2(type, index2, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index2 && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index2] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    const current_component2 = get_current_component();
    promise.then((value) => {
      set_current_component(current_component2);
      update2(info.then, 1, info.value, value);
      set_current_component(null);
    }, (error2) => {
      set_current_component(current_component2);
      update2(info.catch, 2, info.error, error2);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error2;
      }
    });
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy2, create_each_block17, next, get_context2) {
  let o2 = old_blocks.length;
  let n2 = list.length;
  let i2 = o2;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = new Map();
  const deltas = new Map();
  i2 = n2;
  while (i2--) {
    const child_ctx = get_context2(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block17(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = new Set();
  const did_move = new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o2 && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o2 - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o2--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy2(old_block, lookup);
      o2--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o2--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o2--;
    }
  }
  while (o2--) {
    const old_block = old_blocks[o2];
    if (!new_lookup.has(old_block.key))
      destroy2(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o2 = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key in o2) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key in o2) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function bind(component, name, callback) {
  const index2 = component.$$.props[name];
  if (index2 !== void 0) {
    component.$$.bound[index2] = callback;
    callback(component.$$.ctx[index2]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance96, create_fragment96, not_equal2, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal: not_equal2,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance96 ? instance96(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal2($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment96 ? create_fragment96($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index2 = callbacks.indexOf(callback);
        if (index2 !== -1)
          callbacks.splice(index2, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start2) {
  return {
    subscribe: writable(value, start2).subscribe
  };
}
function writable(value, start2 = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn3) {
    set(fn3(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn3, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto2 = fn3.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn3(single ? values[0] : values, set);
      if (auto2) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i2) => subscribe(store, (value) => {
      values[i2] = value;
      pending &= ~(1 << i2);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i2;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}

// src/main.ts
var import_obsidian50 = __toModule(require("obsidian"));
var import_obsidian_dataview4 = __toModule(require_lib());
var import_dayjs8 = __toModule(require_dayjs_min());
var import_isoWeek = __toModule(require_isoWeek());
var import_localizedFormat = __toModule(require_localizedFormat());

// src/view.ts
var import_obsidian47 = __toModule(require("obsidian"));

// node_modules/tslib/modules/index.js
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle2(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance96 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance96.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance96.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance96.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance96.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element2),
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c2) {
    return p2.replace(/%s/, c2);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
      return self2.indexOf(value) === index2;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
            return '"' + s2 + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn3) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn3(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance96 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance96.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance: instance96
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance96.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance96;
    }
    instance96.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance96,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance96;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/svelte-portal/src/Portal.svelte
function create_fragment(ctx) {
  let div;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      div.hidden = true;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portal_action = portal.call(null, div, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (portal_action && is_function(portal_action.update) && dirty & 1)
        portal_action.update.call(null, ctx2[0]);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function portal(el, target = "body") {
  let targetEl;
  function update2(newTarget) {
    return __async(this, null, function* () {
      target = newTarget;
      if (typeof target === "string") {
        targetEl = document.querySelector(target);
        if (targetEl === null) {
          yield tick();
          targetEl = document.querySelector(target);
        }
        if (targetEl === null) {
          throw new Error(`No element found matching css selector: "${target}"`);
        }
      } else if (target instanceof HTMLElement) {
        targetEl = target;
      } else {
        throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
      }
      targetEl.appendChild(el);
      el.hidden = false;
    });
  }
  function destroy2() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update2(target);
  return { update: update2, destroy: destroy2 };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { target = "body" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("target" in $$props2)
      $$invalidate(0, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [target, $$scope, slots];
}
var Portal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { target: 0 });
  }
};
var Portal_default = Portal;

// node_modules/svelte-portal/src/main.es.js
var main_es_default = Portal_default;

// node_modules/obsidian-svelte/Popover/useClickOutside.js
function useClickOutside(element2, { onClickOutside, anchorEl, open }) {
  function onClick(event) {
    if (open && !anchorEl.contains(event.target) && !element2.contains(event.target)) {
      onClickOutside();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(props) {
      onClickOutside = props.onClickOutside;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// node_modules/obsidian-svelte/Popover/Popover.svelte
function add_css(target) {
  append_styles(target, "svelte-1xg3ic1", ".layer.svelte-1xg3ic1{z-index:var(--layer-popover)}");
}
function create_if_block(ctx) {
  let portal2;
  let current;
  portal2 = new main_es_default({
    props: {
      target: document.body,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty & 527) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal2.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal2, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let div;
  let div_class_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "" + (null_to_empty(ctx[2]) + " svelte-1xg3ic1"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[7](div);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useClickOutside_action = useClickOutside.call(null, div, {
          open: ctx[0],
          anchorEl: ctx[1],
          onClickOutside: ctx[8]
        }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[9], !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null), null);
        }
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "" + (null_to_empty(ctx2[2]) + " svelte-1xg3ic1"))) {
        attr(div, "class", div_class_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 3)
        useClickOutside_action.update.call(null, {
          open: ctx2[0],
          anchorEl: ctx2[1],
          onClickOutside: ctx2[8]
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { className = "popover layer" } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  let popperEl;
  let popper2 = null;
  const params = {
    placement,
    modifiers: [
      {
        name: "offset",
        options: { offset: [0, 4] }
      }
    ]
  };
  onDestroy(() => {
    if (popper2) {
      popper2.destroy();
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popperEl = $$value;
      $$invalidate(3, popperEl);
    });
  }
  const useClickOutside_function = () => $$invalidate(0, open = false);
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(1, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("onClose" in $$props2)
      $$invalidate(4, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(5, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 10) {
      $: {
        if (anchorEl && popperEl) {
          popper2 = createPopper(anchorEl, popperEl, params);
        }
      }
    }
    if ($$self.$$.dirty & 17) {
      $:
        if (!open) {
          onClose();
        }
    }
  };
  return [
    open,
    anchorEl,
    className,
    popperEl,
    onClose,
    placement,
    slots,
    div_binding,
    useClickOutside_function,
    $$scope
  ];
}
var Popover = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      anchorEl: 1,
      open: 0,
      className: 2,
      onClose: 4,
      placement: 5
    }, add_css);
  }
};
var Popover_default = Popover;

// node_modules/obsidian-svelte/Popover/Menu.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: ctx[0],
      open: ctx[1],
      placement: ctx[3],
      className: "menu",
      onClose: ctx[2],
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & 1)
        popover_changes.anchorEl = ctx2[0];
      if (dirty & 2)
        popover_changes.open = ctx2[1];
      if (dirty & 8)
        popover_changes.placement = ctx2[3];
      if (dirty & 4)
        popover_changes.onClose = ctx2[2];
      if (dirty & 32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Menu = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      anchorEl: 0,
      open: 1,
      onClose: 2,
      placement: 3
    });
  }
};
var Menu_default = Menu;

// node_modules/obsidian-svelte/Switch/Switch.svelte
function add_css2(target) {
  append_styles(target, "svelte-1i6m2hn", ".disabled.svelte-1i6m2hn{opacity:0.6}");
}
function create_fragment4(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<input type="checkbox"/>`;
      attr(div, "class", "checkbox-container svelte-1i6m2hn");
      toggle_class(div, "disabled", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[5]),
          listen(div, "keypress", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        toggle_class(div, "disabled", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { checked } = $$props;
  let { disabled = false } = $$props;
  let ref;
  const dispatch = createEventDispatcher();
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(2, ref);
    });
  }
  const click_handler = () => {
    if (!disabled) {
      $$invalidate(0, checked = !checked);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("check", checked);
    }
    if ($$self.$$.dirty & 5) {
      $: {
        if (ref) {
          if (checked) {
            ref.classList.add("is-enabled");
          } else {
            ref.classList.remove("is-enabled");
          }
        }
      }
    }
  };
  return [checked, disabled, ref, keypress_handler, div_binding, click_handler];
}
var Switch = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { checked: 0, disabled: 1 }, add_css2);
  }
};
var Switch_default = Switch;

// node_modules/obsidian-svelte/Icon/Icon.svelte
function add_css3(target) {
  append_styles(target, "svelte-s7qdhh", "span.svelte-s7qdhh{color:var(--icon-color);fill:var(--icon-color);opacity:var(--icon-opacity);display:flex;flex:0 1 auto}.icon-xs.svelte-s7qdhh{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-s7qdhh{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-s7qdhh{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-s7qdhh{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}.accent.svelte-s7qdhh{color:var(--text-on-accent);fill:var(--text-on-accent)}");
}
function create_fragment5(ctx) {
  let span;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "aria-label", ctx[3]);
      attr(span, "class", "svelte-s7qdhh");
      toggle_class(span, "accent", ctx[2]);
      toggle_class(span, "icon-xs", ctx[1] === "xs");
      toggle_class(span, "icon-sm", ctx[1] === "sm");
      toggle_class(span, "icon-md", ctx[1] === "md");
      toggle_class(span, "icon-lg", ctx[1] === "lg");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, span, ctx[0]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        attr(span, "aria-label", ctx2[3]);
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 1)
        useIcon_action.update.call(null, ctx2[0]);
      if (dirty & 4) {
        toggle_class(span, "accent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(span, "icon-xs", ctx2[1] === "xs");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-sm", ctx2[1] === "sm");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-md", ctx2[1] === "md");
      }
      if (dirty & 2) {
        toggle_class(span, "icon-lg", ctx2[1] === "lg");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { name } = $$props;
  let { size = "md" } = $$props;
  let { accent = false } = $$props;
  let { tooltip = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("accent" in $$props2)
      $$invalidate(2, accent = $$props2.accent);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
  };
  return [name, size, accent, tooltip];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0, size: 1, accent: 2, tooltip: 3 }, add_css3);
  }
};
var Icon_default = Icon;

// node_modules/obsidian-svelte/Icon/IconButton.svelte
function add_css4(target) {
  append_styles(target, "svelte-r9r5oc", ".nopadding.svelte-r9r5oc{padding:0}.icon-xs.svelte-r9r5oc{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width)}.icon-sm.svelte-r9r5oc{--icon-size:var(--icon-s);--icon-stroke:var(--icon-s-stroke-width)}.icon-md.svelte-r9r5oc{--icon-size:var(--icon-m);--icon-stroke:var(--icon-m-stroke-width)}.icon-lg.svelte-r9r5oc{--icon-size:var(--icon-l);--icon-stroke:var(--icon-l-stroke-width)}");
}
function create_fragment6(ctx) {
  let div;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "clickable-icon svelte-r9r5oc");
      attr(div, "aria-label", ctx[3]);
      toggle_class(div, "nopadding", ctx[4]);
      toggle_class(div, "is-active", ctx[2]);
      toggle_class(div, "icon-xs", ctx[1] === "xs");
      toggle_class(div, "icon-sm", ctx[1] === "sm");
      toggle_class(div, "icon-md", ctx[1] === "md");
      toggle_class(div, "icon-lg", ctx[1] === "lg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useIcon_action = useIcon.call(null, div, ctx[0])),
          listen(div, "click", ctx[5]),
          listen(div, "keypress", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        attr(div, "aria-label", ctx2[3]);
      }
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 1)
        useIcon_action.update.call(null, ctx2[0]);
      if (dirty & 16) {
        toggle_class(div, "nopadding", ctx2[4]);
      }
      if (dirty & 4) {
        toggle_class(div, "is-active", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(div, "icon-xs", ctx2[1] === "xs");
      }
      if (dirty & 2) {
        toggle_class(div, "icon-sm", ctx2[1] === "sm");
      }
      if (dirty & 2) {
        toggle_class(div, "icon-md", ctx2[1] === "md");
      }
      if (dirty & 2) {
        toggle_class(div, "icon-lg", ctx2[1] === "lg");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let { size = "md" } = $$props;
  let { active = false } = $$props;
  let { tooltip = "" } = $$props;
  let { nopadding = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2)
      $$invalidate(0, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("tooltip" in $$props2)
      $$invalidate(3, tooltip = $$props2.tooltip);
    if ("nopadding" in $$props2)
      $$invalidate(4, nopadding = $$props2.nopadding);
  };
  return [icon, size, active, tooltip, nopadding, click_handler, keypress_handler];
}
var IconButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      icon: 0,
      size: 1,
      active: 2,
      tooltip: 3,
      nopadding: 4
    }, add_css4);
  }
};
var IconButton_default = IconButton;

// node_modules/obsidian-svelte/Icon/useIcon.js
var import_obsidian = __toModule(require("obsidian"));
function useIcon(node, name) {
  (0, import_obsidian.setIcon)(node, name);
  return {
    update(name2) {
      (0, import_obsidian.setIcon)(node, name2);
    }
  };
}

// node_modules/obsidian-svelte/Popover/MenuItem.svelte
function create_if_block_1(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({ props: { checked: ctx[0] } });
  switch_1.$on("check", ctx[6]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = ctx2[0];
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let useIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "menu-item-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, div, ctx[2]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 4)
        useIcon_action.update.call(null, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment7(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let t22;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0] !== void 0 && create_if_block_1(ctx);
  let if_block1 = ctx[2] && create_if_block2(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      t22 = text(ctx[1]);
      attr(div0, "class", "menu-item-title");
      attr(div1, "class", "menu-item");
      toggle_class(div1, "selected", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div0, t22);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "mouseenter", ctx[7]),
          listen(div1, "mouseleave", ctx[8]),
          listen(div1, "click", ctx[4]),
          listen(div1, "keypress", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0] !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 2)
        set_data(t22, ctx2[1]);
      if (!current || dirty & 8) {
        toggle_class(div1, "selected", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let selected = false;
  let { icon = "" } = $$props;
  let { checked = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const check_handler = ({ detail: enabled }) => $$invalidate(0, checked = enabled);
  const mouseenter_handler = () => $$invalidate(3, selected = true);
  const mouseleave_handler = () => $$invalidate(3, selected = false);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("check", checked);
    }
  };
  return [
    checked,
    label,
    icon,
    selected,
    click_handler,
    keypress_handler,
    check_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var MenuItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { label: 1, icon: 2, checked: 0 });
  }
};
var MenuItem_default = MenuItem;

// node_modules/obsidian-svelte/Popover/Suggestion.svelte
function create_default_slot3(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "suggestion");
      set_style(div, "max-height", "300px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let popover;
  let current;
  popover = new Popover_default({
    props: {
      anchorEl: ctx[0],
      open: ctx[1],
      placement: ctx[3],
      className: "suggestion-container",
      onClose: ctx[2],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const popover_changes = {};
      if (dirty & 1)
        popover_changes.anchorEl = ctx2[0];
      if (dirty & 2)
        popover_changes.open = ctx2[1];
      if (dirty & 8)
        popover_changes.placement = ctx2[3];
      if (dirty & 4)
        popover_changes.onClose = ctx2[2];
      if (dirty & 32) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { anchorEl } = $$props;
  let { open } = $$props;
  let { onClose = () => {
  } } = $$props;
  let { placement = "bottom-start" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("anchorEl" in $$props2)
      $$invalidate(0, anchorEl = $$props2.anchorEl);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("onClose" in $$props2)
      $$invalidate(2, onClose = $$props2.onClose);
    if ("placement" in $$props2)
      $$invalidate(3, placement = $$props2.placement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [anchorEl, open, onClose, placement, slots, $$scope];
}
var Suggestion = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      anchorEl: 0,
      open: 1,
      onClose: 2,
      placement: 3
    });
  }
};
var Suggestion_default = Suggestion;

// node_modules/obsidian-svelte/Popover/SuggestionItem.svelte
function create_fragment9(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t22;
  let t3;
  let div3;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      t22 = text(ctx[2]);
      t3 = space();
      div3 = element("div");
      attr(div0, "class", "suggestion-title");
      attr(div1, "class", "suggestion-note");
      attr(div2, "class", "suggestion-content");
      attr(div3, "class", "suggestion-aux");
      attr(div4, "class", "suggestion-item mod-complex");
      toggle_class(div4, "is-selected", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t22);
      append(div4, t3);
      append(div4, div3);
      ctx[5](div4);
      if (!mounted) {
        dispose = [
          listen(div4, "mouseenter", ctx[6]),
          listen(div4, "mouseleave", ctx[7]),
          listen(div4, "mousedown", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4)
        set_data(t22, ctx2[2]);
      if (dirty & 1) {
        toggle_class(div4, "is-selected", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div4);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let { description = "" } = $$props;
  let { selected = false } = $$props;
  const dispatch = createEventDispatcher();
  let ref;
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const mouseenter_handler = () => {
    $$invalidate(0, selected = true);
  };
  const mouseleave_handler = () => $$invalidate(0, selected = false);
  const mousedown_handler = () => dispatch("click");
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("select", selected);
    }
    if ($$self.$$.dirty & 9) {
      $: {
        if (selected && ref) {
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
      }
    }
  };
  return [
    selected,
    label,
    description,
    ref,
    dispatch,
    div4_binding,
    mouseenter_handler,
    mouseleave_handler,
    mousedown_handler
  ];
}
var SuggestionItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { label: 1, description: 2, selected: 0 });
  }
};
var SuggestionItem_default = SuggestionItem;

// node_modules/obsidian-svelte/Input/Input.svelte
function add_css5(target) {
  append_styles(target, "svelte-su9mt0", ".embed.svelte-su9mt0{all:unset;box-sizing:border-box;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal)}.embed.svelte-su9mt0:focus{box-shadow:none}.noPadding.svelte-su9mt0{padding:0}.error.svelte-su9mt0{border-color:var(--background-modifier-error)}.error.svelte-su9mt0:hover{border-color:var(--background-modifier-error-hover)}.error.svelte-su9mt0:focus{box-shadow:0 0 0 2px var(--background-modifier-error);border-color:var(--background-modifier-error)}small.svelte-su9mt0{margin-top:var(--size-4-1);font-size:var(--font-ui-smaller);color:var(--text-muted);display:block}.errorText.svelte-su9mt0{color:var(--text-error)}");
}
function create_if_block3(ctx) {
  let small;
  let t3;
  return {
    c() {
      small = element("small");
      t3 = text(ctx[9]);
      attr(small, "class", "svelte-su9mt0");
      toggle_class(small, "errorText", ctx[6]);
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 512)
        set_data(t3, ctx2[9]);
      if (dirty & 64) {
        toggle_class(small, "errorText", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment10(ctx) {
  let div;
  let input;
  let input_style_value;
  let t3;
  let div_style_value;
  let mounted;
  let dispose;
  let if_block = !!ctx[9] && create_if_block3(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t3 = space();
      if (if_block)
        if_block.c();
      input.value = ctx[2];
      attr(input, "type", ctx[1]);
      attr(input, "placeholder", ctx[4]);
      input.readOnly = ctx[3];
      attr(input, "style", input_style_value = `width: ${ctx[5]}`);
      attr(input, "class", "svelte-su9mt0");
      toggle_class(input, "error", ctx[6]);
      toggle_class(input, "embed", ctx[7]);
      toggle_class(input, "noPadding", ctx[8]);
      attr(div, "style", div_style_value = `width: ${ctx[5]}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[16](input);
      append(div, t3);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[11]),
          listen(input, "focus", ctx[12]),
          listen(input, "blur", ctx[13]),
          listen(input, "keydown", ctx[14]),
          listen(input, "keyup", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        input.value = ctx2[2];
      }
      if (dirty & 2) {
        attr(input, "type", ctx2[1]);
      }
      if (dirty & 16) {
        attr(input, "placeholder", ctx2[4]);
      }
      if (dirty & 8) {
        input.readOnly = ctx2[3];
      }
      if (dirty & 32 && input_style_value !== (input_style_value = `width: ${ctx2[5]}`)) {
        attr(input, "style", input_style_value);
      }
      if (dirty & 64) {
        toggle_class(input, "error", ctx2[6]);
      }
      if (dirty & 128) {
        toggle_class(input, "embed", ctx2[7]);
      }
      if (dirty & 256) {
        toggle_class(input, "noPadding", ctx2[8]);
      }
      if (!!ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32 && div_style_value !== (div_style_value = `width: ${ctx2[5]}`)) {
        attr(div, "style", div_style_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[16](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  onMount(() => {
    if (autoFocus && ref) {
      ref.focus();
    }
  });
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(4, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(10, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        dispatch("input", value);
    }
  };
  return [
    ref,
    type,
    value,
    readonly,
    placeholder,
    width,
    error2,
    embed,
    noPadding,
    helperText,
    autoFocus,
    input_handler,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler,
    input_binding
  ];
}
var Input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      type: 1,
      value: 2,
      ref: 0,
      readonly: 3,
      placeholder: 4,
      autoFocus: 10,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    }, add_css5);
  }
};
var Input_default = Input;

// node_modules/obsidian-svelte/Input/TextInput.svelte
function create_fragment11(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "text",
    readonly: ctx[2],
    noPadding: ctx[9],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[8],
    error: ctx[6],
    helperText: ctx[7]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  input.$on("keyup", ctx[16]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 512)
        input_changes.noPadding = ctx2[9];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 256)
        input_changes.embed = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 128)
        input_changes.helperText = ctx2[7];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { helperText = "" } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { ref = null } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.value);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("helperText" in $$props2)
      $$invalidate(7, helperText = $$props2.helperText);
    if ("embed" in $$props2)
      $$invalidate(8, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(9, noPadding = $$props2.noPadding);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error2,
    helperText,
    embed,
    noPadding,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TextInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      value: 0,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      helperText: 7,
      embed: 8,
      noPadding: 9,
      ref: 1
    });
  }
};
var TextInput_default = TextInput;

// node_modules/obsidian-svelte/Input/NumberInput.svelte
function create_fragment12(ctx) {
  let input;
  let updating_ref;
  let updating_value;
  let current;
  function input_ref_binding(value) {
    ctx[11](value);
  }
  function input_value_binding(value) {
    ctx[12](value);
  }
  let input_props = {
    type: "number",
    readonly: ctx[2],
    placeholder: ctx[3],
    autoFocus: ctx[4],
    width: ctx[5],
    embed: ctx[7],
    noPadding: ctx[8],
    error: ctx[6],
    helperText: ctx[9]
  };
  if (ctx[1] !== void 0) {
    input_props.ref = ctx[1];
  }
  if (ctx[0] !== void 0) {
    input_props.value = ctx[0];
  }
  input = new Input_default({ props: input_props });
  binding_callbacks.push(() => bind(input, "ref", input_ref_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  input.$on("input", ctx[10]);
  input.$on("focus", ctx[13]);
  input.$on("blur", ctx[14]);
  input.$on("keydown", ctx[15]);
  return {
    c() {
      create_component(input.$$.fragment);
    },
    m(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const input_changes = {};
      if (dirty & 4)
        input_changes.readonly = ctx2[2];
      if (dirty & 8)
        input_changes.placeholder = ctx2[3];
      if (dirty & 16)
        input_changes.autoFocus = ctx2[4];
      if (dirty & 32)
        input_changes.width = ctx2[5];
      if (dirty & 128)
        input_changes.embed = ctx2[7];
      if (dirty & 256)
        input_changes.noPadding = ctx2[8];
      if (dirty & 64)
        input_changes.error = ctx2[6];
      if (dirty & 512)
        input_changes.helperText = ctx2[9];
      if (!updating_ref && dirty & 2) {
        updating_ref = true;
        input_changes.ref = ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        input_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(input, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { ref = null } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { autoFocus = false } = $$props;
  let { width = "auto" } = $$props;
  let { error: error2 = false } = $$props;
  let { embed = false } = $$props;
  let { noPadding = false } = $$props;
  let { helperText = "" } = $$props;
  const dispatch = createEventDispatcher();
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  function input_ref_binding(value2) {
    ref = value2;
    $$invalidate(1, ref);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("ref" in $$props2)
      $$invalidate(1, ref = $$props2.ref);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("autoFocus" in $$props2)
      $$invalidate(4, autoFocus = $$props2.autoFocus);
    if ("width" in $$props2)
      $$invalidate(5, width = $$props2.width);
    if ("error" in $$props2)
      $$invalidate(6, error2 = $$props2.error);
    if ("embed" in $$props2)
      $$invalidate(7, embed = $$props2.embed);
    if ("noPadding" in $$props2)
      $$invalidate(8, noPadding = $$props2.noPadding);
    if ("helperText" in $$props2)
      $$invalidate(9, helperText = $$props2.helperText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [
    value,
    ref,
    readonly,
    placeholder,
    autoFocus,
    width,
    error2,
    embed,
    noPadding,
    helperText,
    handleInput,
    input_ref_binding,
    input_value_binding,
    focus_handler,
    blur_handler,
    keydown_handler
  ];
}
var NumberInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      value: 0,
      ref: 1,
      readonly: 2,
      placeholder: 3,
      autoFocus: 4,
      width: 5,
      error: 6,
      embed: 7,
      noPadding: 8,
      helperText: 9
    });
  }
};
var NumberInput_default = NumberInput;

// node_modules/obsidian-svelte/Autocomplete/Autocomplete.svelte
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2].label;
  child_ctx[24] = list[i2].description;
  child_ctx[26] = i2;
  return child_ctx;
}
function create_if_block4(ctx) {
  let suggestionitem;
  let current;
  suggestionitem = new SuggestionItem_default({
    props: { label: "", description: "No options" }
  });
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_each_block(ctx) {
  let suggestionitem;
  let current;
  function click_handler() {
    return ctx[20](ctx[26]);
  }
  function select_handler(...args) {
    return ctx[21](ctx[26], ...args);
  }
  suggestionitem = new SuggestionItem_default({
    props: {
      label: ctx[23],
      description: ctx[24],
      selected: ctx[8] === ctx[26]
    }
  });
  suggestionitem.$on("click", click_handler);
  suggestionitem.$on("select", select_handler);
  return {
    c() {
      create_component(suggestionitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(suggestionitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const suggestionitem_changes = {};
      if (dirty & 1024)
        suggestionitem_changes.label = ctx[23];
      if (dirty & 1024)
        suggestionitem_changes.description = ctx[24];
      if (dirty & 256)
        suggestionitem_changes.selected = ctx[8] === ctx[26];
      suggestionitem.$set(suggestionitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestionitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestionitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(suggestionitem, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let t3;
  let each_1_anchor;
  let current;
  let if_block = !ctx[10].length && create_if_block4(ctx);
  let each_value = ctx[10];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[10].length) {
        if (if_block) {
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 3329) {
        each_value = ctx2[10];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment13(ctx) {
  let textinput;
  let updating_value;
  let updating_ref;
  let t3;
  let suggestion;
  let current;
  function textinput_value_binding(value) {
    ctx[14](value);
  }
  function textinput_ref_binding(value) {
    ctx[15](value);
  }
  let textinput_props = {
    readonly: ctx[2],
    width: ctx[4],
    placeholder: ctx[3],
    autoFocus: ctx[6],
    embed: ctx[5]
  };
  if (ctx[0] !== void 0) {
    textinput_props.value = ctx[0];
  }
  if (ctx[9] !== void 0) {
    textinput_props.ref = ctx[9];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  binding_callbacks.push(() => bind(textinput, "ref", textinput_ref_binding));
  textinput.$on("focus", ctx[16]);
  textinput.$on("blur", ctx[17]);
  textinput.$on("input", ctx[18]);
  textinput.$on("keydown", ctx[19]);
  suggestion = new Suggestion_default({
    props: {
      anchorEl: ctx[9],
      open: ctx[1],
      onClose: ctx[22],
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(textinput.$$.fragment);
      t3 = space();
      create_component(suggestion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t3, anchor);
      mount_component(suggestion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textinput_changes = {};
      if (dirty & 4)
        textinput_changes.readonly = ctx2[2];
      if (dirty & 16)
        textinput_changes.width = ctx2[4];
      if (dirty & 8)
        textinput_changes.placeholder = ctx2[3];
      if (dirty & 64)
        textinput_changes.autoFocus = ctx2[6];
      if (dirty & 32)
        textinput_changes.embed = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textinput_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_ref && dirty & 512) {
        updating_ref = true;
        textinput_changes.ref = ctx2[9];
        add_flush_callback(() => updating_ref = false);
      }
      textinput.$set(textinput_changes);
      const suggestion_changes = {};
      if (dirty & 512)
        suggestion_changes.anchorEl = ctx2[9];
      if (dirty & 2)
        suggestion_changes.open = ctx2[1];
      if (dirty & 2)
        suggestion_changes.onClose = ctx2[22];
      if (dirty & 134219009) {
        suggestion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suggestion.$set(suggestion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      transition_in(suggestion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      transition_out(suggestion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t3);
      destroy_component(suggestion, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let filteredOptions;
  let { value } = $$props;
  let { options } = $$props;
  let { maxItems = 50 } = $$props;
  let { open = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { embed = false } = $$props;
  let { autoFocus = false } = $$props;
  let selected = -1;
  let inputRef;
  const dispatch = createEventDispatcher();
  let willClose = false;
  function textinput_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textinput_ref_binding(value2) {
    inputRef = value2;
    $$invalidate(9, inputRef);
  }
  const focus_handler = () => $$invalidate(1, open = true);
  const blur_handler = (event) => {
    $$invalidate(1, open = false);
    dispatch("change", value);
    dispatch("blur", event);
  };
  const input_handler = () => $$invalidate(1, open = true);
  const keydown_handler = (event) => {
    var _a, _b;
    if (open) {
      switch (event.key) {
        case "ArrowUp":
          const prev = selected - 1;
          $$invalidate(8, selected = prev < 0 ? filteredOptions.length - 1 : prev);
          event.stopPropagation();
          break;
        case "ArrowDown":
          const next = selected + 1;
          $$invalidate(8, selected = next > filteredOptions.length - 1 ? 0 : next);
          event.stopPropagation();
          break;
        case "Enter":
          $$invalidate(0, value = (_b = (_a = filteredOptions[selected]) == null ? void 0 : _a.label) != null ? _b : value);
          $$invalidate(7, willClose = true);
          break;
      }
    }
  };
  const click_handler = (i2) => {
    var _a, _b;
    $$invalidate(0, value = (_b = (_a = filteredOptions[i2]) == null ? void 0 : _a.label) != null ? _b : value);
    dispatch("change", value);
  };
  const select_handler = (i2, { detail }) => {
    if (detail) {
      $$invalidate(8, selected = i2);
    }
  };
  const func7 = () => $$invalidate(1, open = false);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("options" in $$props2)
      $$invalidate(12, options = $$props2.options);
    if ("maxItems" in $$props2)
      $$invalidate(13, maxItems = $$props2.maxItems);
    if ("open" in $$props2)
      $$invalidate(1, open = $$props2.open);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("embed" in $$props2)
      $$invalidate(5, embed = $$props2.embed);
    if ("autoFocus" in $$props2)
      $$invalidate(6, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12289) {
      $:
        $$invalidate(10, filteredOptions = options.filter((option2) => !value || option2.label.toLocaleLowerCase().contains(value.toLocaleLowerCase())).slice(0, Math.min(maxItems, options.length)));
    }
    if ($$self.$$.dirty & 128) {
      $:
        if (willClose) {
          $$invalidate(1, open = false);
          $$invalidate(7, willClose = false);
        }
    }
  };
  return [
    value,
    open,
    readonly,
    placeholder,
    width,
    embed,
    autoFocus,
    willClose,
    selected,
    inputRef,
    filteredOptions,
    dispatch,
    options,
    maxItems,
    textinput_value_binding,
    textinput_ref_binding,
    focus_handler,
    blur_handler,
    input_handler,
    keydown_handler,
    click_handler,
    select_handler,
    func7
  ];
}
var Autocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      value: 0,
      options: 12,
      maxItems: 13,
      open: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      embed: 5,
      autoFocus: 6
    });
  }
};
var Autocomplete_default = Autocomplete;

// node_modules/obsidian-svelte/Autocomplete/FileAutocomplete.svelte
function create_fragment14(ctx) {
  let autocomplete;
  let updating_value;
  let updating_options;
  let current;
  function autocomplete_value_binding(value) {
    ctx[10](value);
  }
  function autocomplete_options_binding(value) {
    ctx[11](value);
  }
  let autocomplete_props = {
    readonly: ctx[2],
    placeholder: ctx[3],
    width: ctx[4],
    embed: ctx[1],
    autoFocus: ctx[5]
  };
  if (ctx[0] !== void 0) {
    autocomplete_props.value = ctx[0];
  }
  if (ctx[6] !== void 0) {
    autocomplete_props.options = ctx[6];
  }
  autocomplete = new Autocomplete_default({ props: autocomplete_props });
  binding_callbacks.push(() => bind(autocomplete, "value", autocomplete_value_binding));
  binding_callbacks.push(() => bind(autocomplete, "options", autocomplete_options_binding));
  autocomplete.$on("change", ctx[12]);
  autocomplete.$on("blur", ctx[13]);
  return {
    c() {
      create_component(autocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const autocomplete_changes = {};
      if (dirty & 4)
        autocomplete_changes.readonly = ctx2[2];
      if (dirty & 8)
        autocomplete_changes.placeholder = ctx2[3];
      if (dirty & 16)
        autocomplete_changes.width = ctx2[4];
      if (dirty & 2)
        autocomplete_changes.embed = ctx2[1];
      if (dirty & 32)
        autocomplete_changes.autoFocus = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        autocomplete_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_options && dirty & 64) {
        updating_options = true;
        autocomplete_changes.options = ctx2[6];
        add_flush_callback(() => updating_options = false);
      }
      autocomplete.$set(autocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let options;
  let { value } = $$props;
  let { files } = $$props;
  let { getLabel = (file) => file.name } = $$props;
  let { getDescription = () => "" } = $$props;
  let { embed = false } = $$props;
  let { readonly = false } = $$props;
  let { placeholder = "" } = $$props;
  let { width = "auto" } = $$props;
  let { autoFocus = false } = $$props;
  function autocomplete_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function autocomplete_options_binding(value2) {
    options = value2;
    $$invalidate(6, options), $$invalidate(7, files), $$invalidate(8, getLabel), $$invalidate(9, getDescription);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("files" in $$props2)
      $$invalidate(7, files = $$props2.files);
    if ("getLabel" in $$props2)
      $$invalidate(8, getLabel = $$props2.getLabel);
    if ("getDescription" in $$props2)
      $$invalidate(9, getDescription = $$props2.getDescription);
    if ("embed" in $$props2)
      $$invalidate(1, embed = $$props2.embed);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("placeholder" in $$props2)
      $$invalidate(3, placeholder = $$props2.placeholder);
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("autoFocus" in $$props2)
      $$invalidate(5, autoFocus = $$props2.autoFocus);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 896) {
      $:
        $$invalidate(6, options = files.map((file) => ({
          label: getLabel(file),
          description: getDescription(file)
        })));
    }
  };
  return [
    value,
    embed,
    readonly,
    placeholder,
    width,
    autoFocus,
    options,
    files,
    getLabel,
    getDescription,
    autocomplete_value_binding,
    autocomplete_options_binding,
    change_handler,
    blur_handler
  ];
}
var FileAutocomplete = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      value: 0,
      files: 7,
      getLabel: 8,
      getDescription: 9,
      embed: 1,
      readonly: 2,
      placeholder: 3,
      width: 4,
      autoFocus: 5
    });
  }
};
var FileAutocomplete_default = FileAutocomplete;

// node_modules/obsidian-svelte/Button/Button.svelte
function add_css6(target) {
  append_styles(target, "svelte-12xcpmj", "button.svelte-12xcpmj{gap:var(--size-4-1)}.mod-plain.svelte-12xcpmj{background:none;box-shadow:none;border:none;color:var(--text-muted)}.mod-plain.svelte-12xcpmj:hover{color:var(--text-normal)}.disabled.svelte-12xcpmj{opacity:0.6}");
}
function create_fragment15(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "aria-label", ctx[2]);
      button.disabled = ctx[1];
      attr(button, "class", "svelte-12xcpmj");
      toggle_class(button, "mod-cta", ctx[0] === "primary");
      toggle_class(button, "mod-warning", ctx[0] === "destructive");
      toggle_class(button, "mod-plain", ctx[0] === "plain");
      toggle_class(button, "disabled", ctx[1]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        attr(button, "aria-label", ctx2[2]);
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-cta", ctx2[0] === "primary");
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-warning", ctx2[0] === "destructive");
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-plain", ctx2[0] === "plain");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "disabled", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "default" } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(2, tooltip = $$props2.tooltip);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [variant, disabled, tooltip, $$scope, slots, click_handler];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, { variant: 0, disabled: 1, tooltip: 2 }, add_css6);
  }
};
var Button_default = Button;

// node_modules/obsidian-svelte/Callout/Callout.svelte
function create_fragment16(ctx) {
  let div4;
  let div2;
  let div0;
  let useIcon_action;
  let t0;
  let div1;
  let t1;
  let t22;
  let div3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(ctx[0]);
      t22 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "callout-icon");
      attr(div1, "class", "callout-title-inner");
      attr(div2, "class", "callout-title");
      attr(div3, "class", "callout-content");
      attr(div4, "data-callout-metadata", "");
      attr(div4, "data-callout-fold", "");
      attr(div4, "data-callout", ctx[2]);
      attr(div4, "class", "callout");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      append(div1, t1);
      append(div4, t22);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useIcon_action = useIcon.call(null, div0, ctx[1]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (useIcon_action && is_function(useIcon_action.update) && dirty & 2)
        useIcon_action.update.call(null, ctx2[1]);
      if (!current || dirty & 1)
        set_data(t1, ctx2[0]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        attr(div4, "data-callout", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { icon } = $$props;
  let { variant } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("icon" in $$props2)
      $$invalidate(1, icon = $$props2.icon);
    if ("variant" in $$props2)
      $$invalidate(2, variant = $$props2.variant);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [title, icon, variant, $$scope, slots];
}
var Callout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { title: 0, icon: 1, variant: 2 });
  }
};
var Callout_default = Callout;

// node_modules/obsidian-svelte/Checkbox/Checkbox.svelte
function create_fragment17(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      input.checked = ctx[0];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "dblclick", stop_propagation(ctx[2])),
          listen(input, "click", stop_propagation(ctx[3])),
          listen(input, "change", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { checked } = $$props;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, checked = event.currentTarget.checked);
    }
  }
  function dblclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("check", checked);
    }
  };
  return [checked, handleChange, dblclick_handler, click_handler];
}
var Checkbox = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, { checked: 0 });
  }
};
var Checkbox_default = Checkbox;

// node_modules/obsidian-svelte/DateInput/DateInput.svelte
function add_css7(target) {
  append_styles(target, "svelte-2qn54x", "input.svelte-2qn54x{border-radius:9999px;border:0;background-color:var(--background-modifier-hover);font-family:var(--font-default);padding:0.1em 0.6em}.embed.svelte-2qn54x{margin:0 8px}");
}
function create_fragment18(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "date");
      attr(input, "class", "svelte-2qn54x");
      toggle_class(input, "embed", ctx[0]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[4](input);
      if (!mounted) {
        dispose = listen(input, "change", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(input, "embed", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { embed = false } = $$props;
  let ref;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      if (event.currentTarget.valueAsDate) {
        dispatch("change", event.currentTarget.valueAsDate);
      }
    }
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref), $$invalidate(3, value);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(3, value = $$props2.value);
    if ("embed" in $$props2)
      $$invalidate(0, embed = $$props2.embed);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 10) {
      $: {
        if (ref && value) {
          $$invalidate(1, ref.valueAsDate = new Date(value.getFullYear(), value.getMonth(), value.getDate(), 12), ref);
        }
      }
    }
  };
  return [embed, ref, handleChange, value, input_binding];
}
var DateInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, { value: 3, embed: 0 }, add_css7);
  }
};
var DateInput_default = DateInput;

// node_modules/obsidian-svelte/Link/InternalLink.svelte
function add_css8(target) {
  append_styles(target, "svelte-u3bamg", ".is-unresolved.svelte-u3bamg{opacity:0.5}");
}
function create_fragment19(ctx) {
  let a2;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      a2 = element("a");
      if (default_slot)
        default_slot.c();
      attr(a2, "href", ctx[0]);
      attr(a2, "data-href", ctx[0]);
      attr(a2, "class", a_class_value = "" + (null_to_empty(`internal-link`) + " svelte-u3bamg"));
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noopener");
      toggle_class(a2, "is-unresolved", !ctx[2]);
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      if (default_slot) {
        default_slot.m(a2, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a2, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[4], !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(a2, "href", ctx2[0]);
      }
      if (!current || dirty & 1) {
        attr(a2, "data-href", ctx2[0]);
      }
      if (!current || dirty & 4) {
        toggle_class(a2, "is-unresolved", !ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { linkText } = $$props;
  let { sourcePath } = $$props;
  let { resolved } = $$props;
  const dispatch = createEventDispatcher();
  const click_handler = (event) => {
    event.stopPropagation();
    dispatch("open", {
      linkText,
      sourcePath,
      newLeaf: event.ctrlKey || event.metaKey
    });
  };
  $$self.$$set = ($$props2) => {
    if ("linkText" in $$props2)
      $$invalidate(0, linkText = $$props2.linkText);
    if ("sourcePath" in $$props2)
      $$invalidate(1, sourcePath = $$props2.sourcePath);
    if ("resolved" in $$props2)
      $$invalidate(2, resolved = $$props2.resolved);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [linkText, sourcePath, resolved, dispatch, $$scope, slots, click_handler];
}
var InternalLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, { linkText: 0, sourcePath: 1, resolved: 2 }, add_css8);
  }
};
var InternalLink_default = InternalLink;

// node_modules/obsidian-svelte/Loading/Loading.svelte
function create_fragment20(ctx) {
  let div9;
  return {
    c() {
      div9 = element("div");
      div9.innerHTML = `<div class="sk-cube sk-cube1"></div> 
	<div class="sk-cube sk-cube2"></div> 
	<div class="sk-cube sk-cube3"></div> 
	<div class="sk-cube sk-cube4"></div> 
	<div class="sk-cube sk-cube5"></div> 
	<div class="sk-cube sk-cube6"></div> 
	<div class="sk-cube sk-cube7"></div> 
	<div class="sk-cube sk-cube8"></div> 
	<div class="sk-cube sk-cube9"></div>`;
      attr(div9, "class", "loader-cube");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div9);
    }
  };
}
var Loading = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment20, safe_not_equal, {});
  }
};
var Loading_default = Loading;

// node_modules/obsidian-svelte/Modal/ModalButtonGroup.svelte
function create_fragment21(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-button-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ModalButtonGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment21, safe_not_equal, {});
  }
};
var ModalButtonGroup_default = ModalButtonGroup;

// node_modules/obsidian-svelte/Modal/ModalContent.svelte
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ModalContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment22, safe_not_equal, {});
  }
};
var ModalContent_default = ModalContent;

// node_modules/obsidian-svelte/Modal/ModalLayout.svelte
function create_fragment23(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      div = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "modal-title");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      insert(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [title, $$scope, slots];
}
var ModalLayout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment23, safe_not_equal, { title: 0 });
  }
};
var ModalLayout_default = ModalLayout;

// node_modules/obsidian-svelte/Select/SelectItem.svelte
function create_fragment24(ctx) {
  let option2;
  let t_value = (ctx[0] || ctx[1]) + "";
  let t3;
  return {
    c() {
      option2 = element("option");
      t3 = text(t_value);
      option2.__value = ctx[1];
      option2.value = option2.__value;
      option2.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, option2, anchor);
      append(option2, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && t_value !== (t_value = (ctx2[0] || ctx2[1]) + ""))
        set_data(t3, t_value);
      if (dirty & 2) {
        option2.__value = ctx2[1];
        option2.value = option2.__value;
      }
      if (dirty & 4) {
        option2.disabled = ctx2[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(option2);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { text: text2 } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [text2, value, disabled];
}
var SelectItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment24, safe_not_equal, { text: 0, value: 1, disabled: 2 });
  }
};
var SelectItem_default = SelectItem;

// node_modules/obsidian-svelte/Select/Select.svelte
function get_each_context2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[2],
      value: "",
      disabled: true
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: { text: ctx[2], value: "" }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 4)
        selectitem_changes.text = ctx2[2];
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let selectitem;
  let current;
  selectitem = new SelectItem_default({
    props: {
      text: ctx[6].label,
      value: ctx[6].value
    }
  });
  return {
    c() {
      create_component(selectitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectitem_changes = {};
      if (dirty & 1)
        selectitem_changes.text = ctx2[6].label;
      if (dirty & 1)
        selectitem_changes.value = ctx2[6].value;
      selectitem.$set(selectitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectitem, detaching);
    }
  };
}
function create_fragment25(ctx) {
  let select;
  let if_block0_anchor;
  let if_block1_anchor;
  let select_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[0].length && ctx[2] && create_if_block_12(ctx);
  let if_block1 = ctx[3] && create_if_block5(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      select = element("select");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      select.disabled = select_disabled_value = !ctx[0].length && !!ctx[2];
      attr(select, "class", "dropdown");
    },
    m(target, anchor) {
      insert(target, select, anchor);
      if (if_block0)
        if_block0.m(select, null);
      append(select, if_block0_anchor);
      if (if_block1)
        if_block1.m(select, null);
      append(select, if_block1_anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(select, null);
      }
      select_option(select, ctx[1]);
      current = true;
      if (!mounted) {
        dispose = listen(select, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[0].length && ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(select, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(select, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & 1) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(select, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 5 && select_disabled_value !== (select_disabled_value = !ctx2[0].length && !!ctx2[2])) {
        select.disabled = select_disabled_value;
      }
      if (!current || dirty & 2) {
        select_option(select, ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { value } = $$props;
  let { placeholder = "" } = $$props;
  let { allowEmpty = false } = $$props;
  const dispatch = createEventDispatcher();
  function handleChange(event) {
    if (event.currentTarget instanceof HTMLSelectElement) {
      dispatch("change", event.currentTarget.value);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("allowEmpty" in $$props2)
      $$invalidate(3, allowEmpty = $$props2.allowEmpty);
  };
  return [options, value, placeholder, allowEmpty, handleChange];
}
var Select = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment25, safe_not_equal, {
      options: 0,
      value: 1,
      placeholder: 2,
      allowEmpty: 3
    });
  }
};
var Select_default = Select;

// node_modules/obsidian-svelte/Setting/SettingItem.svelte
function add_css9(target) {
  append_styles(target, "svelte-17mpvkc", ".vertical.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1)}.vertical-control.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1);width:100%}");
}
function create_fragment26(ctx) {
  var _a, _b;
  let div4;
  let div2;
  let div0;
  let t0_value = ((_a = ctx[0]) != null ? _a : "") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ((_b = ctx[1]) != null ? _b : "") + "";
  let t22;
  let t3;
  let div3;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t22 = text(t2_value);
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control svelte-17mpvkc");
      toggle_class(div3, "vertical-control", ctx[2]);
      attr(div4, "class", "setting-item svelte-17mpvkc");
      toggle_class(div4, "vertical", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t22);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ((_a2 = ctx2[0]) != null ? _a2 : "") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t2_value !== (t2_value = ((_b2 = ctx2[1]) != null ? _b2 : "") + ""))
        set_data(t22, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        toggle_class(div3, "vertical-control", ctx2[2]);
      }
      if (!current || dirty & 4) {
        toggle_class(div4, "vertical", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, description, vertical, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment26, safe_not_equal, { name: 0, description: 1, vertical: 2 }, add_css9);
  }
};
var SettingItem_default = SettingItem;

// node_modules/obsidian-svelte/Tag/Tag.svelte
function add_css10(target) {
  append_styles(target, "svelte-ehq9e", "div.svelte-ehq9e{background-color:var(--tag-background);border:var(--tag-border-width) solid var(--tag-border-color);border-radius:var(--tag-radius);color:var(--tag-color);font-size:var(--tag-size);text-decoration:var(--tag-decoration);padding:var(--tag-padding-y) var(--tag-padding-x);line-height:1;display:inline-flex;align-items:center;gap:var(--size-4-1)}");
}
function create_fragment27(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-ehq9e");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Tag = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment27, safe_not_equal, {}, add_css10);
  }
};
var Tag_default = Tag;

// node_modules/obsidian-svelte/TextArea/TextArea.svelte
function add_css11(target) {
  append_styles(target, "svelte-1yhxf9x", "textarea.svelte-1yhxf9x{font-family:var(--font-monospace-default)}");
}
function create_fragment28(ctx) {
  let textarea;
  let textarea_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "rows", ctx[1]);
      attr(textarea, "style", textarea_style_value = `width: ${ctx[2]}`);
      attr(textarea, "class", "svelte-1yhxf9x");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(textarea, "rows", ctx2[1]);
      }
      if (dirty & 4 && textarea_style_value !== (textarea_style_value = `width: ${ctx2[2]}`)) {
        attr(textarea, "style", textarea_style_value);
      }
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { rows } = $$props;
  let { width = "auto" } = $$props;
  const dispatch = createEventDispatcher();
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("rows" in $$props2)
      $$invalidate(1, rows = $$props2.rows);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        dispatch("input", value);
    }
  };
  return [value, rows, width, textarea_input_handler];
}
var TextArea = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment28, safe_not_equal, { value: 0, rows: 1, width: 2 }, add_css11);
  }
};
var TextArea_default = TextArea;

// node_modules/obsidian-svelte/Typography/Typography.svelte
function add_css12(target) {
  append_styles(target, "svelte-1wyn8wx", ".nomargin.svelte-1wyn8wx{margin:0}");
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let svelte_element_levels = [{ class: "svelte-1wyn8wx" }];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  return {
    c() {
      svelte_element = element(ctx[2][ctx[0]]);
      if (default_slot)
        default_slot.c();
      set_attributes(svelte_element, svelte_element_data);
      toggle_class(svelte_element, "nomargin", ctx[1]);
      toggle_class(svelte_element, "setting-item-name", ctx[0] === "label");
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{ class: "svelte-1wyn8wx" }]));
      toggle_class(svelte_element, "nomargin", ctx2[1]);
      toggle_class(svelte_element, "setting-item-name", ctx2[0] === "label");
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment29(ctx) {
  let previous_tag = ctx[2][ctx[0]];
  let svelte_element_anchor;
  let current;
  let svelte_element = ctx[2][ctx[0]] && create_dynamic_element(ctx);
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[2][ctx2[0]]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, ctx2[2][ctx2[0]])) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = ctx2[2][ctx2[0]];
    },
    i(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o(local) {
      transition_out(svelte_element);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant } = $$props;
  let { nomargin = false } = $$props;
  const elements = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    body: "p",
    label: "p"
  };
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("nomargin" in $$props2)
      $$invalidate(1, nomargin = $$props2.nomargin);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [variant, nomargin, elements, $$scope, slots];
}
var Typography = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment29, safe_not_equal, { variant: 0, nomargin: 1 }, add_css12);
  }
};
var Typography_default = Typography;

// node_modules/obsidian-svelte/useClickOutside.js
function useClickOutside2(element2, callbackFunction) {
  function onClick(event) {
    if (!element2.contains(event.target)) {
      callbackFunction();
    }
  }
  document.body.addEventListener("click", onClick);
  return {
    update(newCallbackFunction) {
      callbackFunction = newCallbackFunction;
    },
    destroy() {
      document.body.removeEventListener("click", onClick);
    }
  };
}

// src/lib/data-api.ts
var import_dayjs = __toModule(require_dayjs_min());

// node_modules/immer/dist/immer.esm.mjs
function n(n2) {
  for (var r2 = arguments.length, t3 = Array(r2 > 1 ? r2 - 1 : 0), e = 1; e < r2; e++)
    t3[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? typeof i2 == "function" ? i2.apply(null, t3) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t3.length ? " " + t3.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || typeof n3 != "object")
      return false;
    var r2 = Object.getPrototypeOf(n3);
    if (r2 === null)
      return true;
    var t3 = Object.hasOwnProperty.call(r2, "constructor") && r2.constructor;
    return t3 === Object || typeof t3 == "function" && Function.toString.call(t3) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function i(n2, r2, t3) {
  t3 === void 0 && (t3 = false), o(n2) === 0 ? (t3 ? Object.keys : nn)(n2).forEach(function(e) {
    t3 && typeof e == "symbol" || r2(e, n2[e], n2);
  }) : n2.forEach(function(t4, e) {
    return r2(e, t4, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return o(n2) === 2 ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return o(n2) === 2 ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t3) {
  var e = o(n2);
  e === 2 ? n2.set(r2, t3) : e === 3 ? (n2.delete(r2), n2.add(t3)) : n2[r2] = t3;
}
function c(n2, r2) {
  return n2 === r2 ? n2 !== 0 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t3 = nn(r2), e = 0; e < t3.length; e++) {
    var i2 = t3[e], o2 = r2[i2];
    o2.writable === false && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e) {
  return e === void 0 && (e = false), y(n2) || r(n2) || !t(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return n2 == null || typeof n2 != "object" || Object.isFrozen(n2);
}
function b(r2) {
  var t3 = tn[r2];
  return t3 || n(18, r2), t3;
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  r2.i === 0 || r2.i === 1 ? r2.j() : r2.O = true;
}
function P(r2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = r2 !== void 0 && r2 !== i2;
  return e.h.g || b("ES5").S(e, r2, o2), o2 ? (i2[Q].P && (O(e), n(4)), t(r2) && (r2 = M(e, r2), e.l || x(e, r2)), e.u && b("Patches").M(i2[Q].t, r2, e.u, e.s)) : r2 = M(e, i2, []), O(e), e.u && e.v(e.u, e.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t3) {
  if (y(r2))
    return r2;
  var e = r2[Q];
  if (!e)
    return i(r2, function(i2, o3) {
      return A(n2, e, r2, i2, o3, t3);
    }, true), r2;
  if (e.A !== n2)
    return r2;
  if (!e.P)
    return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = e.i === 4 || e.i === 5 ? e.o = l(e.k) : e.o;
    i(e.i === 3 ? new Set(o2) : o2, function(r3, i2) {
      return A(n2, e, o2, r3, i2, t3);
    }), x(n2, o2, false), t3 && n2.u && b("Patches").R(e, t3, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2) {
  if (c2 === o2 && n(5), r(c2)) {
    var v2 = M(e, c2, s2 && i2 && i2.i !== 3 && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, v2), !r(v2))
      return;
    e.m = false;
  }
  if (t(c2) && !y(c2)) {
    if (!e.h.F && e._ < 1)
      return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, r2, t3) {
  t3 === void 0 && (t3 = false), n2.h.F && n2.m && d(r2, t3);
}
function z(n2, r2) {
  var t3 = n2[Q];
  return (t3 ? p(t3) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t3 = Object.getPrototypeOf(n2); t3; ) {
      var e = Object.getOwnPropertyDescriptor(t3, r2);
      if (e)
        return e;
      t3 = Object.getPrototypeOf(t3);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, r2, t3) {
  var e = s(r2) ? b("MapSet").N(r2, t3) : v(r2) ? b("MapSet").T(r2, t3) : n2.g ? function(n3, r3) {
    var t4 = Array.isArray(n3), e2 = { i: t4 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, D: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    t4 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e2.k = f2, e2.j = a2, f2;
  }(r2, t3) : b("ES5").J(r2, t3);
  return (t3 ? t3.A : _()).p.push(e), e;
}
function D(e) {
  return r(e) || n(22, e), function n2(r2) {
    if (!t(r2))
      return r2;
    var e2, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e2 = F(r2, c2), u2.I = false;
    } else
      e2 = F(r2, c2);
    return i(e2, function(r3, t3) {
      u2 && a(u2.t, r3) === t3 || f(e2, r3, n2(t3));
    }), c2 === 3 ? new Set(e2) : e2;
  }(e);
}
function F(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
var G;
var U;
var W = typeof Symbol != "undefined" && typeof Symbol("x") == "symbol";
var X = typeof Map != "undefined";
var q = typeof Set != "undefined";
var B = typeof Proxy != "undefined" && Proxy.revocable !== void 0 && typeof Reflect != "undefined";
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var V = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = typeof Reflect != "undefined" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t3) {
    r2[t3] = Object.getOwnPropertyDescriptor(n2, t3);
  }), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e = p(n2);
  if (!u(e, r2))
    return function(n3, r3, t3) {
      var e2, i3 = I(r3, t3);
      return i3 ? "value" in i3 ? i3.value : (e2 = i3.get) === null || e2 === void 0 ? void 0 : e2.call(n3.k) : void 0;
    }(n2, e, r2);
  var i2 = e[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = R(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t3) {
  var e = I(p(n2), r2);
  if (e == null ? void 0 : e.set)
    return e.set.call(n2.k, t3), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = i2 == null ? void 0 : i2[Q];
    if (o2 && o2.t === t3)
      return n2.o[r2] = t3, n2.D[r2] = false, true;
    if (c(t3, i2) && (t3 !== void 0 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t3 && typeof t3 != "number" && (t3 !== void 0 || r2 in n2.o) || (n2.o[r2] = t3, n2.D[r2] = true, true);
}, deleteProperty: function(n2, r2) {
  return z(n2.t, r2) !== void 0 || r2 in n2.t ? (n2.D[r2] = false, E(n2), k(n2)) : delete n2.D[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t3 = p(n2), e = Reflect.getOwnPropertyDescriptor(t3, r2);
  return e ? { writable: true, configurable: n2.i !== 1 || r2 !== "length", enumerable: e.enumerable, value: t3[r2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t3) {
  return isNaN(parseInt(t3)) && n(13), on.set.call(this, r2, t3, void 0);
}, on.set = function(r2, t3, e) {
  return t3 !== "length" && isNaN(parseInt(t3)) && n(14), en.set.call(this, r2[0], t3, e, r2[0]);
};
var un = function() {
  function e(r2) {
    var e2 = this;
    this.g = B, this.F = true, this.produce = function(r3, i3, o2) {
      if (typeof r3 == "function" && typeof i3 != "function") {
        var u2 = i3;
        i3 = r3;
        var a2 = e2;
        return function(n2) {
          var r4 = this;
          n2 === void 0 && (n2 = u2);
          for (var t3 = arguments.length, e3 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t4;
            return (t4 = i3).call.apply(t4, [r4, n3].concat(e3));
          });
        };
      }
      var f2;
      if (typeof i3 != "function" && n(6), o2 !== void 0 && typeof o2 != "function" && n(7), t(r3)) {
        var c2 = w(e2), s2 = R(e2, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return typeof Promise != "undefined" && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || typeof r3 != "object") {
        if ((f2 = i3(r3)) === void 0 && (f2 = r3), f2 === H && (f2 = void 0), e2.F && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if (typeof n2 == "function")
        return function(r4) {
          for (var t4 = arguments.length, i4 = Array(t4 > 1 ? t4 - 1 : 0), o3 = 1; o3 < t4; o3++)
            i4[o3 - 1] = arguments[o3];
          return e2.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t3, i3, o2 = e2.produce(n2, r3, function(n3, r4) {
        t3 = n3, i3 = r4;
      });
      return typeof Promise != "undefined" && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t3, i3];
      }) : [o2, t3, i3];
    }, typeof (r2 == null ? void 0 : r2.useProxies) == "boolean" && this.setUseProxies(r2.useProxies), typeof (r2 == null ? void 0 : r2.autoFreeze) == "boolean" && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    t(e2) || n(8), r(e2) && (e2 = D(e2));
    var i3 = w(this), o2 = R(this, e2, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function(r2, t3) {
    var e2 = r2 && r2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, t3), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.g = r2;
  }, i2.applyPatches = function(n2, t3) {
    var e2;
    for (e2 = t3.length - 1; e2 >= 0; e2--) {
      var i3 = t3[e2];
      if (i3.path.length === 0 && i3.op === "replace") {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (t3 = t3.slice(e2 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t3) : this.produce(n2, function(n3) {
      return o2(n3, t3);
    });
  }, e;
}();
var an = new un();
var fn2 = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn2;

// src/lib/data-api.ts
var import_moment = __toModule(require_moment());
var import_obsidian4 = __toModule(require("obsidian"));

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
var i2;
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance96, Constructor) {
  if (!(instance96 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toArray.js
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

// node_modules/i18next/dist/esm/i18next.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init3(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }, {
    key: "clone",
    value: function clone2(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger2(this.logger, options);
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on3(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off2(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a2, s2, t3) {
  a2.forEach(function(m) {
    if (s2[m])
      t3[m] = s2[m];
  });
}
function getLastOfPath(object, path4, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path4 !== "string" ? [].concat(path4) : path4.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path4, newValue) {
  var _getLastOfPath = getLastOfPath(object, path4, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path4, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path4, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat)
    obj[k2].push(newValue);
}
function getPath(object, path4) {
  var _getLastOfPath3 = getLastOfPath(object, path4), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s2) {
      return _entityMap[s2];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && typeof window.navigator.userAgentData === "undefined" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki = key.indexOf(keySeparator);
    if (ki > 0 && !r2.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function deepFind(obj, path4) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path4])
    return obj[path4];
  var paths = path4.split(keySeparator);
  var current = obj;
  for (var i2 = 0; i2 < paths.length; ++i2) {
    if (!current)
      return void 0;
    if (typeof current[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i2]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i2, i2 + j2).join(keySeparator);
      var mix = current[p2];
      while (mix === void 0 && paths.length > i2 + j2) {
        j2++;
        p2 = paths.slice(i2, i2 + j2).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (mix === null)
        return null;
      if (path4.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      var joinedPath = paths.slice(i2 + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i2]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path4 = [lng, ns];
      if (key && typeof key !== "string")
        path4 = path4.concat(key);
      if (key && typeof key === "string")
        path4 = path4.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path4 = lng.split(".");
      }
      var result = getPath(this.data, path4);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path4 = [lng, ns];
      if (key)
        path4 = path4.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path4 = lng.split(".");
        value = ns;
        ns = path4[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path4, value);
      if (!options.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
          this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
      }
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path4 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path4 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path4[1];
      }
      this.addNamespaces(ns);
      var pack = getPath(this.data, path4) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path4, pack);
      if (!options.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1(Translator2);
  function Translator2(services) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage2(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists2(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;
      if (_typeof(options) !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options)
        options = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }
          return "".concat(namespace).concat(nsSeparator).concat(key);
        }
        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }
        return key;
      }
      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          var r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
          if (returnDetails) {
            resolved.res = r2;
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy2[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m] === deepKey)
                copy2[m] = res[m];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          var send = function send2(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function(suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options.nest = false;
        }
        if (options.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options);
        if (options.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = "defaultValue";
      for (var option2 in options) {
        if (Object.prototype.hasOwnProperty.call(options, option2) && prefix === option2.substring(0, prefix.length) && options[option2] !== void 0) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _2(n2) {
    return Number(n2 > 1);
  },
  2: function _3(n2) {
    return Number(n2 != 1);
  },
  3: function _4(n2) {
    return 0;
  },
  4: function _5(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _6(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _9(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _10(n2) {
    return Number(n2 >= 2);
  },
  10: function _11(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _12(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _13(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _14(n2) {
    return Number(n2 !== 0);
  },
  14: function _15(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _17(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _18(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _19(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _21(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _22(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _23(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || function(value) {
      return value;
    };
    this.init(options);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation)
        options.interpolation = {
          escapeValue: true
        };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path4 = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path4, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path4;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          var matchedVar = match[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread$3({}, options);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        var matchedSingleQuotes = optionsString.match(/'/g);
        var matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r2 = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
var Formatter = function() {
  function Formatter2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: function number(val, lng, options2) {
        return new Intl.NumberFormat(lng, options2).format(val);
      },
      currency: function currency(val, lng, options2) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options2), {}, {
          style: "currency"
        })).format(val);
      },
      datetime: function datetime(val, lng, options2) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options2)).format(val);
      },
      relativetime: function relativetime(val, lng, options2) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options2)).format(val, options2.range || "day");
      },
      list: function list(val, lng, options2) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options2)).format(val);
      }
    };
    this.init(options);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init3(services) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "format",
    value: function format2(value, _format, lng, options) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error2) {
            _this.logger.warn(error2);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function removePending(q2, name) {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create("backendConnector");
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;
      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending[name] === void 0)
              pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0)
              pending[name] = true;
            if (toLoad[name] === void 0)
              toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0)
              toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns);
        removePending(q2, name);
        if (err)
          q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = {};
            var loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach(function(ns2) {
                if (loaded2[l2][ns2] === void 0)
                  loaded2[l2][ns2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      return this.backend[fcName](lng, ns, function(err, data) {
        _this3.readingCalls--;
        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();
          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data && tried < _this3.maxRetries) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s2 = name.split("|");
      var lng = s2[0];
      var ns = s2[1];
      this.read(lng, ns, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function(key) {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function noop2() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init3() {
      var _this2 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s2 = this.services;
        s2.logger = baseLogger;
        s2.resourceStore = this.store;
        s2.languageUtils = lu;
        s2.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s2.formatter = createClassOnDemand(formatter);
          s2.formatter.init(s2, this.options);
          this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
        }
        s2.interpolator = new Interpolator(this.options);
        s2.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
        s2.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s2.languageDetector.init(s2, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s2.i18nFormat.init)
            s2.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init)
            m.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop2;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err, t3) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t3);
          callback(err, t3);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources2(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append2 = function append3(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        } else {
          append2(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e) {
          if (!e && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources2(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop2;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use2(module2) {
      if (!module2)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "formatter") {
        this.modules.formatter = module2;
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage2(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT2(lng, ns, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }
        options.lng = options.lng || fixedT2.lng;
        options.lngs = options.lngs || fixedT2.lngs;
        options.ns = options.ns || fixedT2.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT2.keyPrefix;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t3() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists2() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace2(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns) {
      var _this6 = this;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages2(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone2.logger = clone2.logger.clone(options);
      }
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone2[m] = _this8[m];
      });
      clone2.services = _objectSpread$6({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options, callback);
});
var instance29 = I18n.createInstance();
instance29.createInstance = I18n.createInstance;
var createInstance = instance29.createInstance;
var init2 = instance29.init;
var loadResources = instance29.loadResources;
var reloadResources = instance29.reloadResources;
var use = instance29.use;
var changeLanguage = instance29.changeLanguage;
var getFixedT = instance29.getFixedT;
var t2 = instance29.t;
var exists = instance29.exists;
var setDefaultNamespace = instance29.setDefaultNamespace;
var hasLoadedNamespace = instance29.hasLoadedNamespace;
var loadNamespaces = instance29.loadNamespaces;
var loadLanguages = instance29.loadLanguages;
var i18next_default = instance29;

// src/lib/stores/i18n.ts
var import_svelte_i18next = __toModule(require_svelte_i18next());
i18next_default.init({
  lng: "en",
  resources: {
    en: {
      translation: {
        "data-types": {
          string: "Text",
          number: "Number",
          boolean: "True or false",
          date: "Date",
          link: "Link",
          list: "List",
          unknown: "Unknown data type"
        },
        commands: {
          "show-projects": {
            name: "Show projects"
          },
          "create-project": {
            name: "Create new project"
          },
          "create-note": {
            name: "Create new note"
          }
        },
        menus: {
          project: {
            create: {
              title: "Create project in folder"
            }
          }
        },
        modals: {
          project: {
            create: {
              "short-title": "New project",
              untitled: "Untitled project",
              title: "Create new project",
              cta: "Create project",
              "existing-name-error": "A project with that name already exists.",
              "empty-name-error": "Project name can't be empty."
            },
            edit: {
              "short-title": "Edit project",
              title: "Edit project",
              cta: "Save"
            },
            delete: {
              "short-title": "Delete project",
              title: "Delete project",
              message: "Are you sure you want to delete the project?",
              cta: "Delete"
            },
            name: {
              name: "Name",
              description: ""
            },
            path: {
              name: "Path",
              description: "Path to the folder you want to manage. Leave empty to use root folder."
            },
            dataview: {
              name: "Use Dataview",
              description: "Use Dataview to query read-only data instead of using paths.",
              error: {
                title: "Dataview is disabled",
                message: "Enable the Dataview plugin to continue using this project."
              }
            },
            query: {
              name: "Query",
              description: "Only supports TABLE queries."
            },
            recursive: {
              name: "Include subfolders",
              description: "Manage notes inside subfolders within the project path."
            },
            templates: {
              name: "Templates",
              description: "Templates to choose from when you create new notes."
            },
            defaultName: {
              name: "Default name",
              description: "Default name for new notes. Supports {{date}} and {{time}} template variables.",
              invalid: "Contains illegal characters."
            }
          },
          view: {
            create: {
              "short-title": "New view",
              title: "Add new view",
              optional: "Optional",
              type: {
                name: "Type",
                description: ""
              },
              name: {
                name: "Name",
                description: ""
              },
              cta: "Add view",
              "existing-name-error": "A view with that name already exists."
            },
            delete: {
              "short-title": "Delete view",
              title: "Delete view",
              message: "Are you sure you want to delete the view?",
              cta: "Delete"
            }
          },
          note: {
            create: {
              "short-title": "New note",
              title: "Create new note",
              name: {
                name: "Name",
                description: ""
              },
              templatePath: {
                name: "Template",
                description: "",
                none: "None"
              },
              project: {
                name: "Project",
                description: ""
              },
              "name-taken-error": "A note with that name already exists.",
              "empty-name-error": "Name can't be empty.",
              create: "Create note",
              readonly: {
                title: "Read-only project",
                message: "{{project}} is a read-only project. Select another project to create a note."
              },
              untitled: "Untitled note"
            },
            edit: {
              "short-title": "Edit note",
              title: "Edit note",
              save: "Save",
              "no-editable-fields": {
                title: "No editable fields",
                message: "This note has no editable fields."
              }
            }
          },
          input: {
            cancel: "Cancel"
          },
          confirm: {
            delete: "Delete",
            cancel: "Cancel"
          }
        },
        views: {
          developer: {
            name: "Developer"
          },
          table: {
            name: "Table",
            "hide-fields": "Hide fields",
            "rename-field": "Rename field",
            rename: "Rename"
          },
          board: {
            name: "Board",
            "no-status": "No status",
            fields: {
              status: "Status",
              priority: "Priority",
              none: "None"
            },
            unprioritized: "Unprioritized",
            note: {
              add: "Add note"
            }
          },
          calendar: {
            name: "Calendar",
            "new-note": "New note",
            fields: {
              date: "Date",
              check: "Check",
              none: "None"
            },
            today: "Today",
            weekday: "{{value, datetime}}",
            date: "{{value, datetime}}",
            interval: "{{from, datetime}} \u2013 {{to, datetime}}",
            intervals: {
              month_one: "Month",
              month_other: "Months",
              monthWithCount_one: "{{count}} month",
              monthWithCount_other: "{{count}} months",
              week_one: "Week",
              week_other: "Weeks",
              weekWithCount_one: "{{count}} week",
              weekWithCount_other: "{{count}} weeks",
              day_one: "Day",
              day_other: "Days",
              dayWithCount_one: "{{count}} day",
              dayWithCount_other: "{{count}} days"
            }
          },
          gallery: {
            name: "Gallery",
            fields: {
              cover: "Cover",
              none: "None"
            },
            empty: "This view is empty."
          }
        },
        components: {
          "data-grid": {
            column: {
              rename: "Rename field",
              delete: "Delete field",
              hide: "Hide field"
            },
            row: {
              add: "Add note",
              edit: "Edit note",
              delete: "Delete note"
            },
            cell: {
              clear: "Clear value"
            },
            sort: {
              asc: "Sort A \u2192 Z",
              desc: "Sort Z \u2192 A"
            }
          }
        },
        toolbar: {
          new: "New",
          view: {
            add: "Add view"
          },
          projects: {
            none: "No projects"
          }
        },
        errors: {
          missingDataview: {
            title: "Dataview is disabled",
            message: "Enable the Dataview plugin to continue using this project."
          }
        }
      }
    }
  },
  interpolation: {
    escapeValue: false
  }
});
var i18n = (0, import_svelte_i18next.createI18nStore)(i18next_default);

// src/lib/helpers.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/lib/stores/obsidian.ts
var app = writable();
var view = writable();
var plugin = writable();

// src/lib/helpers.ts
function notEmpty(value) {
  return value !== null && value !== void 0;
}
function uniquify(name, exists2) {
  if (!exists2(name)) {
    return name;
  }
  let num = 1;
  while (exists2(name + " " + num)) {
    num++;
  }
  return name + " " + num;
}
function nextUniqueFileName(path4, name) {
  return uniquify(name, (name2) => {
    return get_store_value(app).vault.getAbstractFileByPath((0, import_obsidian2.normalizePath)(path4 + "/" + name2 + ".md")) instanceof import_obsidian2.TFile;
  });
}
function nextUniqueProjectName(projects, name) {
  return uniquify(name, (candidate) => {
    return !!projects.find((project) => project.name === candidate);
  });
}
function nextUniqueViewName(views, name) {
  return uniquify(name, (candidate) => {
    return !!views.find((view2) => view2.name === candidate);
  });
}

// src/lib/stores/settings.ts
function createSettings() {
  const { set, update: update2, subscribe: subscribe2 } = writable({
    version: 1,
    projects: []
  });
  return {
    set,
    subscribe: subscribe2,
    saveLayout(projectId, viewId) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.lastProjectId = projectId;
        draft.lastViewId = viewId;
      }));
    },
    addProject(project) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects.push(project);
      }));
    },
    updateProject(project) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects = draft.projects.map((w2) => w2.id === project.id ? project : w2);
      }));
    },
    deleteProject(projectId) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects = draft.projects.filter((w2) => w2.id !== projectId);
      }));
    },
    addView(projectId, view2) {
      update2((state) => immer_esm_default(state, (draft) => {
        const idx = draft.projects.findIndex((ws) => ws.id === projectId);
        if (idx >= 0) {
          const ws = draft.projects[idx];
          if (ws) {
            draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, ws), {
              views: [...ws.views, view2]
            }));
          }
        }
        return draft;
      }));
    },
    sortViews(projectId, viewIds) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects = draft.projects.map((p2) => p2.id !== projectId ? p2 : immer_esm_default(p2, (draft2) => {
          draft2.views = viewIds.map((id) => draft2.views.find((v2) => v2.id === id)).filter(notEmpty);
        }));
      }));
    },
    renameView(projectId, viewId, name) {
      update2((state) => immer_esm_default(state, (draft) => {
        const idx = draft.projects.findIndex((p2) => p2.id === projectId);
        if (idx >= 0) {
          const p2 = draft.projects[idx];
          if (p2) {
            draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, p2), {
              views: p2.views.map((view2) => view2.id === viewId ? __spreadProps(__spreadValues({}, view2), { name }) : view2)
            }));
          }
        }
      }));
    },
    deleteView(projectId, viewId) {
      update2((state) => immer_esm_default(state, (draft) => {
        const idx = draft.projects.findIndex((ws) => ws.id === projectId);
        if (idx >= 0) {
          const ws = draft.projects[idx];
          if (ws) {
            draft.projects.splice(idx, 1, __spreadProps(__spreadValues({}, ws), {
              views: ws.views.filter((view2) => view2.id !== viewId)
            }));
          }
        }
      }));
    },
    updateView(projectId, updatedView) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects = draft.projects.map((project) => {
          if (project.id === projectId) {
            return __spreadProps(__spreadValues({}, project), {
              views: project.views.map((view2) => {
                if (view2.id === updatedView.id) {
                  return updatedView;
                }
                return view2;
              })
            });
          }
          return project;
        });
      }));
    },
    updateViewConfig(projectId, viewId, config) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.projects = draft.projects.map((project) => {
          if (project.id === projectId) {
            return __spreadProps(__spreadValues({}, project), {
              views: project.views.map((view2) => {
                if (view2.id === viewId) {
                  return __spreadProps(__spreadValues({}, view2), {
                    config
                  });
                }
                return view2;
              })
            });
          }
          return project;
        });
      }));
    }
  };
}
var settings = createSettings();
function migrateAny(settings2) {
  if (!settings2) {
    return { version: 1, projects: [] };
  }
  if ("version" in settings2) {
    return Object.assign({}, DEFAULT_SETTINGS, settings2);
  }
  return migrate(settings2);
}
function migrate(v0) {
  return {
    version: 1,
    lastProjectId: v0.lastWorkspaceId,
    lastViewId: v0.lastViewId,
    projects: v0.workspaces
  };
}

// src/lib/templates/index.ts
function interpolateTemplate(template, data) {
  return template.replace(/\{\{\s*(.*?)\s*\}\}/g, (_24, name) => {
    const [func7, arg] = name.split(/:(.*)/s);
    const f2 = data[func7];
    return f2 ? f2(arg) : "";
  });
}

// src/lib/data.ts
var DataFieldType;
(function(DataFieldType2) {
  DataFieldType2["String"] = "string";
  DataFieldType2["Number"] = "number";
  DataFieldType2["Boolean"] = "boolean";
  DataFieldType2["Date"] = "date";
  DataFieldType2["Link"] = "link";
  DataFieldType2["List"] = "list";
  DataFieldType2["Unknown"] = "unknown";
})(DataFieldType || (DataFieldType = {}));
var DataSource = class {
  constructor(project) {
    this.project = project;
  }
  readonly() {
    return false;
  }
};
function isBoolean(value) {
  return typeof value === "boolean";
}
function isString(value) {
  return typeof value === "string";
}
function isLink(value) {
  if (value && typeof value === "object") {
    return "linkText" in value && "sourcePath" in value;
  }
  return false;
}
function isNumber(value) {
  return typeof value === "number";
}
function isDate(value) {
  return value instanceof Date;
}
function isOptionalBoolean(value) {
  return typeof value === "boolean" || value === void 0;
}
function isOptionalString(value) {
  return typeof value === "string" || value === void 0;
}
function isOptionalLink(value) {
  if (typeof value === "object") {
    return "linkText" in value && "sourcePath" in value;
  }
  return value === void 0;
}
function isOptionalList(value) {
  return Array.isArray(value) || value === void 0;
}
function isOptionalNumber(value) {
  return typeof value === "number" || value === void 0;
}
function isOptionalDate(value) {
  return value instanceof Date || value === void 0;
}
function isRawLink(value) {
  if (value && Array.isArray(value)) {
    if (value.length === 1) {
      const nextValue = value[0];
      if (nextValue && Array.isArray(nextValue)) {
        return nextValue.length === 1;
      }
    }
  }
  return false;
}

// src/lib/data-api.ts
var DataApi = class {
  constructor(app2) {
    this.app = app2;
  }
  updateRecord(fields, record) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath(record.id);
      if (file instanceof import_obsidian4.TFile) {
        this.updateFile(file, (data) => doUpdateRecord(data, fields, record));
      }
    });
  }
  renameField(files, from, to) {
    return __async(this, null, function* () {
      for (const file of files) {
        this.updateFile(file, (data) => doRenameField(data, from, to));
      }
    });
  }
  deleteField(files, name) {
    return __async(this, null, function* () {
      for (const file of files) {
        this.updateFile(file, (data) => doDeleteField(data, name));
      }
    });
  }
  createNote(record, templatePath) {
    return __async(this, null, function* () {
      let content = "";
      if (templatePath) {
        const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
        if (templateFile instanceof import_obsidian4.TFile) {
          content = yield this.app.vault.read(templateFile);
          content = interpolateTemplate(content, {
            title: () => {
              var _a;
              return (_a = record.values["name"]) != null ? _a : "";
            },
            date: (format2) => (0, import_moment.default)().format(format2 || "YYYY-MM-DD"),
            time: (format2) => (0, import_moment.default)().format(format2 || "HH:mm")
          });
        }
      }
      const file = yield this.app.vault.create(record.id, content);
      this.updateFile(file, (data) => doUpdateRecord(data, [], record));
      return file;
    });
  }
  updateFile(file, cb) {
    return __async(this, null, function* () {
      const data = yield this.app.vault.read(file);
      yield this.app.vault.modify(file, cb(data));
    });
  }
  deleteRecord(path4) {
    return __async(this, null, function* () {
      const file = this.app.vault.getAbstractFileByPath(path4);
      if (file) {
        this.app.vault.trash(file, true);
      }
    });
  }
};
function doUpdateRecord(data, fields, record) {
  const frontmatter = decodeFrontMatter(data);
  const updated = Object.fromEntries(Object.entries(__spreadValues(__spreadValues({}, frontmatter), record.values)).map((entry) => isDate(entry[1]) ? immer_esm_default(entry, (draft) => {
    draft[1] = (0, import_dayjs.default)(entry[1]).format("YYYY-MM-DD");
  }) : entry).map((entry) => isLink(entry[1]) ? immer_esm_default(entry, (draft) => {
    draft[1] = `[[${draft[1].linkText}]]`;
  }) : entry).filter((entry) => !fields.find((field) => field.name === entry[0] && field.derived)).filter((entry) => entry[1] !== void 0).filter((entry) => entry[1] !== null));
  const encoded = encodeFrontMatter(data, updated);
  return encoded.replace(/"\[\[(.*)\]\]"/, (_24, p1) => {
    return `[[${p1}]]`;
  });
}
function doDeleteField(data, field) {
  const frontmatter = decodeFrontMatter(data);
  frontmatter[field] = null;
  const updated = Object.fromEntries(Object.entries(frontmatter).filter((entry) => entry[1] !== void 0).filter((entry) => entry[1] !== null));
  return encodeFrontMatter(data, updated);
}
function doRenameField(data, from, to) {
  const frontmatter = decodeFrontMatter(data);
  frontmatter[to] = frontmatter[from];
  frontmatter[from] = null;
  const updated = Object.fromEntries(Object.entries(frontmatter).filter((entry) => entry[1] !== void 0).filter((entry) => entry[1] !== null));
  return encodeFrontMatter(data, updated);
}
function decodeFrontMatter(data) {
  const delim = "---";
  const startPosition = data.indexOf(delim) + delim.length;
  const isStart = data.slice(0, startPosition).trim() === delim;
  const endPosition = data.slice(startPosition).indexOf(delim) + startPosition;
  const hasFrontMatter = isStart && endPosition > startPosition;
  const _a = hasFrontMatter ? (0, import_obsidian4.parseYaml)(data.slice(startPosition, endPosition)) : {}, { position } = _a, cache = __objRest(_a, ["position"]);
  return cache;
}
function encodeFrontMatter(data, frontmatter) {
  const delim = "---";
  const startPosition = data.indexOf(delim) + delim.length;
  const isStart = data.slice(0, startPosition).trim() === delim;
  const endPosition = data.slice(startPosition).indexOf(delim) + startPosition;
  const hasFrontMatter = isStart && endPosition > startPosition;
  if (Object.entries(frontmatter).length) {
    const res = hasFrontMatter ? data.slice(0, startPosition + 1) + (0, import_obsidian4.stringifyYaml)(frontmatter) + data.slice(endPosition) : delim + "\n" + (0, import_obsidian4.stringifyYaml)(frontmatter) + delim + "\n\n" + data;
    return res;
  }
  return hasFrontMatter ? data.slice(0, startPosition - delim.length) + data.slice(endPosition + delim.length + 1) : data;
}
function createProject() {
  return {
    id: v4_default(),
    name: nextUniqueProjectName(get_store_value(settings).projects, get_store_value(i18n).t("modals.project.create.untitled")),
    path: "",
    recursive: false,
    defaultName: "",
    templates: [],
    views: [
      {
        id: v4_default(),
        name: get_store_value(i18n).t("views.table.name"),
        type: "table",
        config: {}
      }
    ]
  };
}
function createDataRecord(name, project, values) {
  return {
    id: (0, import_obsidian4.normalizePath)(project.path + "/" + name + ".md"),
    values: values != null ? values : {}
  };
}

// src/lib/stores/api.ts
var api = derived(app, ($app) => new DataApi($app));

// src/lib/stores/dataframe.ts
var dataSource = writable();
var dataFrame = createDataFrame();
function createDataFrame() {
  const { update: update2, set, subscribe: subscribe2 } = writable({
    fields: [],
    records: []
  });
  return {
    set,
    subscribe: subscribe2,
    addRecord(record) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.records.push(record);
      }));
    },
    updateRecord(record) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.records = draft.records.map((r2) => r2.id === record.id ? record : r2);
      }));
    },
    deleteRecord(id) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.records = draft.records.filter((record) => record.id !== id);
      }));
    },
    renameField(from, to) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.fields = draft.fields.map((field) => field.name === from ? __spreadProps(__spreadValues({}, field), {
          name: to
        }) : field);
      }));
    },
    deleteField(fieldName) {
      update2((state) => immer_esm_default(state, (draft) => {
        draft.fields = draft.fields.filter((field) => field.name !== fieldName);
      }));
    },
    merge(frame) {
      update2((existing) => immer_esm_default(existing, (draft) => {
        const recordSet = Object.fromEntries(existing.records.map((record) => [record.id, record]));
        frame.records.forEach((record) => {
          recordSet[record.id] = record;
        });
        draft.records = Object.values(recordSet);
        frame.fields.forEach((newField) => {
          const existingField = existing.fields.find((f2) => f2.name === newField.name);
          if (existingField) {
            if (existingField.type !== newField.type) {
              const existingFieldIndex = existing.fields.findIndex((field) => field.name === newField.name);
              draft.fields[existingFieldIndex] = __spreadProps(__spreadValues({}, newField), {
                type: DataFieldType.String
              });
            }
          } else {
            draft.fields.push(newField);
          }
        });
      }));
    }
  };
}

// src/modals/create-project-modal.ts
var import_obsidian12 = __toModule(require("obsidian"));

// src/modals/components/CreateProject.svelte
var import_moment2 = __toModule(require_moment());

// src/lib/stores/capabilities.ts
var import_obsidian_dataview = __toModule(require_lib());
var capabilities = derived(app, ($app) => {
  return {
    dataview: (0, import_obsidian_dataview.isPluginEnabled)($app)
  };
});

// src/lib/obsidian.ts
var import_obsidian7 = __toModule(require("obsidian"));
var import_os = __toModule(require("os"));
function isTFile(value) {
  return value instanceof import_obsidian7.TFile;
}
function filesFromRecords(app2, records) {
  return records.map((record) => record.id).map((path4) => {
    return app2.vault.getAbstractFileByPath(path4);
  }).filter(isTFile);
}
function getFilesInFolder(folder) {
  const result = [];
  import_obsidian7.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian7.TFile) {
      result.push(file);
    }
  });
  return result;
}
function getNotesInFolder(folder) {
  return getFilesInFolder(folder).filter((file) => file.extension === "md");
}
function getFoldersInFolder(folder) {
  const result = [];
  import_obsidian7.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian7.TFolder) {
      result.push(file);
    }
  });
  return result;
}
function isValidPath(path4) {
  const illegalCharacters = {
    darwin: /[\\\/\|\#\^\[\]]/,
    win32: /[\\\/\|\:\<\>\*\"\?]/
  };
  const expr = illegalCharacters[import_os.default.platform()];
  if (!expr) {
    return true;
  }
  return !expr.test(path4);
}

// src/components/FileListInput/FileListInput.svelte
function add_css13(target) {
  append_styles(target, "svelte-biiywl", "div.svelte-biiywl{display:flex;align-items:center;justify-content:space-between;gap:4px;padding-bottom:4px;width:100%}div.svelte-biiywl:first-child{flex:1}");
}
function get_each_context3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_each_block3(ctx) {
  let div;
  let fileautocomplete;
  let t3;
  let iconbutton;
  let current;
  function change_handler(...args) {
    return ctx[3](ctx[8], ...args);
  }
  fileautocomplete = new FileAutocomplete_default({
    props: {
      value: ctx[6],
      files: getFilesInFolder(ctx[2].vault.getRoot()),
      getLabel: func,
      width: "100%"
    }
  });
  fileautocomplete.$on("change", change_handler);
  function click_handler() {
    return ctx[4](ctx[8]);
  }
  iconbutton = new IconButton_default({ props: { icon: "x" } });
  iconbutton.$on("click", click_handler);
  return {
    c() {
      div = element("div");
      create_component(fileautocomplete.$$.fragment);
      t3 = space();
      create_component(iconbutton.$$.fragment);
      attr(div, "class", "svelte-biiywl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(fileautocomplete, div, null);
      append(div, t3);
      mount_component(iconbutton, div, null);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const fileautocomplete_changes = {};
      if (dirty & 1)
        fileautocomplete_changes.value = ctx[6];
      if (dirty & 4)
        fileautocomplete_changes.files = getFilesInFolder(ctx[2].vault.getRoot());
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(fileautocomplete);
      destroy_component(iconbutton);
    }
  };
}
function create_default_slot5(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Add template");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment30(ctx) {
  let t3;
  let button;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[5]);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t3, anchor);
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const button_changes = {};
      if (dirty & 512) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button, detaching);
    }
  };
}
var func = (file) => file.path;
function instance30($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(2, $app = $$value));
  let { paths } = $$props;
  let { onPathsChange } = $$props;
  const change_handler = (i2, { detail: value }) => {
    onPathsChange(immer_esm_default(paths, (draft) => {
      draft[i2] = value;
      return draft;
    }));
  };
  const click_handler = (i2) => {
    onPathsChange(paths.filter((_24, j2) => j2 !== i2));
  };
  const click_handler_1 = () => {
    onPathsChange([...paths, ""]);
  };
  $$self.$$set = ($$props2) => {
    if ("paths" in $$props2)
      $$invalidate(0, paths = $$props2.paths);
    if ("onPathsChange" in $$props2)
      $$invalidate(1, onPathsChange = $$props2.onPathsChange);
  };
  return [paths, onPathsChange, $app, change_handler, click_handler, click_handler_1];
}
var FileListInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, { paths: 0, onPathsChange: 1 }, add_css13);
  }
};
var FileListInput_default = FileListInput;

// src/modals/components/CreateProject.svelte
function add_css14(target) {
  append_styles(target, "svelte-6mkdkz", "small.svelte-6mkdkz{font-size:var(--font-ui-smaller);color:var(--text-accent);font-weight:var(--font-semibold)}.error.svelte-6mkdkz{color:var(--text-error)}");
}
function create_default_slot_11(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: ctx[0].name,
      autoFocus: true,
      error: !!ctx[4],
      helperText: ctx[4]
    }
  });
  textinput.$on("input", ctx[12]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0].name;
      if (dirty & 16)
        textinput_changes.error = !!ctx2[4];
      if (dirty & 16)
        textinput_changes.helperText = ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.dataview.name"),
      description: (_a = ctx[6].t("modals.project.dataview.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & 64)
        settingitem_changes.name = ctx2[6].t("modals.project.dataview.name");
      if (dirty & 64)
        settingitem_changes.description = (_a2 = ctx2[6].t("modals.project.dataview.description")) != null ? _a2 : "";
      if (dirty & 8388609) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: { checked: !!ctx[0].dataview }
  });
  switch_1.$on("check", ctx[13]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = !!ctx2[0].dataview;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[6].t("modals.project.dataview.error.title"),
      icon: "zap",
      variant: "danger",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 64)
        callout_changes.title = ctx2[6].t("modals.project.dataview.error.title");
      if (dirty & 8388672) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let t_value = ctx[6].t("modals.project.dataview.error.message") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.project.dataview.error.message") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block(ctx) {
  var _a, _b;
  let settingitem0;
  let t3;
  let settingitem1;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.path.name"),
      description: (_a = ctx[6].t("modals.project.path.description")) != null ? _a : "",
      vertical: true,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.recursive.name"),
      description: (_b = ctx[6].t("modals.project.recursive.description")) != null ? _b : "",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t3 = space();
      create_component(settingitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const settingitem0_changes = {};
      if (dirty & 64)
        settingitem0_changes.name = ctx2[6].t("modals.project.path.name");
      if (dirty & 64)
        settingitem0_changes.description = (_a2 = ctx2[6].t("modals.project.path.description")) != null ? _a2 : "";
      if (dirty & 8388865) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 64)
        settingitem1_changes.name = ctx2[6].t("modals.project.recursive.name");
      if (dirty & 64)
        settingitem1_changes.description = (_b2 = ctx2[6].t("modals.project.recursive.description")) != null ? _b2 : "";
      if (dirty & 8388609) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.query.name"),
      description: (_a = ctx[6].t("modals.project.query.description")) != null ? _a : "",
      vertical: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & 64)
        settingitem_changes.name = ctx2[6].t("modals.project.query.name");
      if (dirty & 64)
        settingitem_changes.description = (_a2 = ctx2[6].t("modals.project.query.description")) != null ? _a2 : "";
      if (dirty & 8388609) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      files: getFoldersInFolder(ctx[8].vault.getRoot()),
      value: ctx[0].path,
      getLabel: func2,
      width: "100%"
    }
  });
  fileautocomplete.$on("change", ctx[15]);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fileautocomplete_changes = {};
      if (dirty & 256)
        fileautocomplete_changes.files = getFoldersInFolder(ctx2[8].vault.getRoot());
      if (dirty & 1)
        fileautocomplete_changes.value = ctx2[0].path;
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: { checked: ctx[0].recursive }
  });
  switch_1.$on("check", ctx[16]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = ctx2[0].recursive;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  var _a;
  let textarea;
  let current;
  textarea = new TextArea_default({
    props: {
      value: (_a = ctx[0].query) != null ? _a : "",
      rows: 6,
      width: "100%"
    }
  });
  textarea.$on("input", ctx[14]);
  return {
    c() {
      create_component(textarea.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textarea, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textarea_changes = {};
      if (dirty & 1)
        textarea_changes.value = (_a2 = ctx2[0].query) != null ? _a2 : "";
      textarea.$set(textarea_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textarea, detaching);
    }
  };
}
function create_if_block6(ctx) {
  let small;
  let t_value = ctx[6].t("modals.project.defaultName.invalid") + "";
  let t3;
  return {
    c() {
      small = element("small");
      t3 = text(t_value);
      attr(small, "class", "error svelte-6mkdkz");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.project.defaultName.invalid") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_default_slot_5(ctx) {
  var _a;
  let textinput;
  let t0;
  let small;
  let t1;
  let t22;
  let show_if = !isValidPath(ctx[5]);
  let if_block_anchor;
  let current;
  textinput = new TextInput_default({
    props: {
      value: (_a = ctx[0].defaultName) != null ? _a : "",
      width: "100%"
    }
  });
  textinput.$on("input", ctx[17]);
  let if_block = show_if && create_if_block6(ctx);
  return {
    c() {
      create_component(textinput.$$.fragment);
      t0 = space();
      small = element("small");
      t1 = text(ctx[5]);
      t22 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(small, "class", "svelte-6mkdkz");
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, small, anchor);
      append(small, t1);
      insert(target, t22, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = (_a2 = ctx2[0].defaultName) != null ? _a2 : "";
      textinput.$set(textinput_changes);
      if (!current || dirty & 32)
        set_data(t1, ctx2[5]);
      if (dirty & 32)
        show_if = !isValidPath(ctx2[5]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(small);
      if (detaching)
        detach(t22);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_4(ctx) {
  var _a;
  let filelistinput;
  let current;
  filelistinput = new FileListInput_default({
    props: {
      paths: (_a = ctx[0].templates) != null ? _a : [],
      onPathsChange: ctx[18]
    }
  });
  return {
    c() {
      create_component(filelistinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filelistinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const filelistinput_changes = {};
      if (dirty & 1)
        filelistinput_changes.paths = (_a2 = ctx2[0].templates) != null ? _a2 : [];
      if (dirty & 1)
        filelistinput_changes.onPathsChange = ctx2[18];
      filelistinput.$set(filelistinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filelistinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filelistinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filelistinput, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let t1;
  let t22;
  let current_block_type_index;
  let if_block2;
  let t3;
  let settingitem1;
  let t4;
  let settingitem2;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.name.name"),
      description: (_a = ctx[6].t("modals.project.name.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  let if_block0 = (ctx[0].dataview || ctx[7].dataview) && create_if_block_3(ctx);
  let if_block1 = ctx[0].dataview && !ctx[7].dataview && create_if_block_2(ctx);
  const if_block_creators = [create_if_block_13, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].dataview)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.defaultName.name"),
      description: (_b = ctx[6].t("modals.project.defaultName.description")) != null ? _b : "",
      vertical: true,
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.project.templates.name"),
      description: (_c = ctx[6].t("modals.project.templates.description")) != null ? _c : "",
      vertical: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t22 = space();
      if_block2.c();
      t3 = space();
      create_component(settingitem1.$$.fragment);
      t4 = space();
      create_component(settingitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t22, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t3, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t4, anchor);
      mount_component(settingitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & 64)
        settingitem0_changes.name = ctx2[6].t("modals.project.name.name");
      if (dirty & 64)
        settingitem0_changes.description = (_a2 = ctx2[6].t("modals.project.name.description")) != null ? _a2 : "";
      if (dirty & 8388625) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      if (ctx2[0].dataview || ctx2[7].dataview) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 129) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[0].dataview && !ctx2[7].dataview) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 129) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t22.parentNode, t22);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(t3.parentNode, t3);
      }
      const settingitem1_changes = {};
      if (dirty & 64)
        settingitem1_changes.name = ctx2[6].t("modals.project.defaultName.name");
      if (dirty & 64)
        settingitem1_changes.description = (_b2 = ctx2[6].t("modals.project.defaultName.description")) != null ? _b2 : "";
      if (dirty & 8388705) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & 64)
        settingitem2_changes.name = ctx2[6].t("modals.project.templates.name");
      if (dirty & 64)
        settingitem2_changes.description = (_c2 = ctx2[6].t("modals.project.templates.description")) != null ? _c2 : "";
      if (dirty & 8388609) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t22);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t3);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t4);
      destroy_component(settingitem2, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_1(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      disabled: !!ctx[4],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[19]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 16)
        button_changes.disabled = !!ctx2[4];
      if (dirty & 8388612) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot6(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 8389105) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 8388637) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment31(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[1],
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 2)
        modallayout_changes.title = ctx2[1];
      if (dirty & 8389117) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func2 = (file) => file.path;
function instance31($$self, $$props, $$invalidate) {
  let projects;
  let defaultName;
  let name;
  let nameError;
  let $i18n;
  let $settings;
  let $capabilities;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(11, $settings = $$value));
  component_subscribe($$self, capabilities, ($$value) => $$invalidate(7, $capabilities = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  var _a;
  let { title } = $$props;
  let { cta } = $$props;
  let { onSave } = $$props;
  let { project } = $$props;
  let originalName = project.name;
  function validateName(name2) {
    if (name2 === originalName) {
      return "";
    }
    if (name2 === "") {
      return $i18n.t("modals.project.create.empty-name-error");
    }
    if (projects.find((project2) => project2.name === name2)) {
      return $i18n.t("modals.project.create.existing-name-error");
    }
    return "";
  }
  const input_handler = ({ detail: name2 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { name: name2 }));
  const check_handler = ({ detail: dataview }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { dataview }));
  const input_handler_1 = ({ detail: query }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { query }));
  const change_handler = ({ detail: path4 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { path: path4 }));
  const check_handler_1 = ({ detail: recursive }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { recursive }));
  const input_handler_2 = ({ detail: defaultName2 }) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { defaultName: defaultName2 }));
  const func_13 = (templates) => $$invalidate(0, project = __spreadProps(__spreadValues({}, project), { templates }));
  const click_handler = () => {
    var _a2, _b;
    onSave(__spreadProps(__spreadValues({}, project), {
      templates: (_b = (_a2 = project.templates) == null ? void 0 : _a2.filter(notEmpty)) != null ? _b : []
    }));
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onSave" in $$props2)
      $$invalidate(3, onSave = $$props2.onSave);
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      $:
        projects = $settings.projects;
    }
    if ($$self.$$.dirty & 513) {
      $:
        $$invalidate(5, defaultName = interpolateTemplate($$invalidate(9, _a = project.defaultName) !== null && _a !== void 0 ? _a : "", {
          date: (format2) => (0, import_moment2.default)().format(format2 || "YYYY-MM-DD"),
          time: (format2) => (0, import_moment2.default)().format(format2 || "HH:mm")
        }));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(10, { name } = project, name);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    project,
    title,
    cta,
    onSave,
    nameError,
    defaultName,
    $i18n,
    $capabilities,
    $app,
    _a,
    name,
    $settings,
    input_handler,
    check_handler,
    input_handler_1,
    change_handler,
    check_handler_1,
    input_handler_2,
    func_13,
    click_handler
  ];
}
var CreateProject = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment31, safe_not_equal, { title: 1, cta: 2, onSave: 3, project: 0 }, add_css14);
  }
};
var CreateProject_default = CreateProject;

// src/modals/create-project-modal.ts
var CreateProjectModal = class extends import_obsidian12.Modal {
  constructor(app2, title, cta, onSave, defaults2) {
    super(app2);
    this.title = title;
    this.cta = cta;
    this.onSave = onSave;
    this.defaults = defaults2;
  }
  onOpen() {
    this.component = new CreateProject_default({
      target: this.contentEl,
      props: {
        title: this.title,
        cta: this.cta,
        project: this.defaults,
        onSave: (project) => {
          this.onSave(project);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/app/onboarding/demo-project.ts
var import_dayjs2 = __toModule(require_dayjs_min());
var import_obsidian13 = __toModule(require("obsidian"));
function createDemoProject(vault) {
  return __async(this, null, function* () {
    const demoFolder = "Projects - Demo Project";
    yield vault.createFolder(demoFolder);
    const startDate = (0, import_dayjs2.default)();
    const files = {
      "The Best Notes You'll Ever Make": {
        status: "Done",
        due: startDate.subtract(2, "weeks").format("YYYY-MM-DD"),
        published: true,
        weight: 1,
        tags: ["note-taking"],
        image: "https://images.unsplash.com/photo-1455390582262-044cdead277a?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "The Easiest Way to Start Taking Notes": {
        status: "Done",
        due: startDate.subtract(1, "weeks").format("YYYY-MM-DD"),
        published: true,
        weight: 2,
        tags: ["note-taking", "obsidian"],
        image: "https://images.unsplash.com/photo-1488190211105-8b0e65b80b4e?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "Why You Should Be Taking More Notes": {
        status: "Doing",
        due: startDate.format("YYYY-MM-DD"),
        published: false,
        weight: 3,
        tags: ["note-taking", "pkm"],
        image: "https://images.unsplash.com/photo-1501504905252-473c47e087f8?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "What I Learned From Taking 15,000 Notes": {
        status: "Backlog",
        due: startDate.add(1, "weeks").format("YYYY-MM-DD"),
        published: false,
        weight: 4,
        tags: ["pkm", "obsidian"],
        image: "https://images.unsplash.com/photo-1550592704-6c76defa9985?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      },
      "5 Mistake I Made When I Started Using Obsidian": {
        status: "Backlog",
        due: startDate.add(2, "weeks").format("YYYY-MM-DD"),
        published: false,
        tags: ["obsidian"],
        image: "https://images.unsplash.com/photo-1471107340929-a87cd0f5b5f3?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=300&q=80"
      }
    };
    for (const [linkText, data] of Object.entries(files)) {
      const content = "---\n" + (0, import_obsidian13.stringifyYaml)(data) + "---\n\n# " + linkText;
      yield vault.create((0, import_obsidian13.normalizePath)(demoFolder + "/" + linkText + ".md"), content);
    }
    const tableConfig = {
      fieldConfig: {
        name: {
          width: 360
        },
        path: {
          hide: true
        }
      }
    };
    const boardConfig = {
      groupByField: "status",
      priorityField: "weight"
    };
    const calendarConfig = {
      interval: "month",
      dateField: "due",
      checkField: "published"
    };
    const galleryConfig = {
      coverField: "image"
    };
    settings.addProject({
      name: "Demo project",
      id: v4_default(),
      path: demoFolder,
      recursive: false,
      views: [
        { name: "Table", id: v4_default(), type: "table", config: tableConfig },
        { name: "Board", id: v4_default(), type: "board", config: boardConfig },
        {
          name: "Calendar",
          id: v4_default(),
          type: "calendar",
          config: calendarConfig
        },
        {
          name: "Gallery",
          id: v4_default(),
          type: "gallery",
          config: galleryConfig
        }
      ]
    });
  });
}

// src/app/onboarding/onboarding-modal.ts
var import_obsidian14 = __toModule(require("obsidian"));

// src/app/onboarding/TabContainer.svelte
function add_css15(target) {
  append_styles(target, "svelte-1es105s", ".nomargin.svelte-1es105s{margin:0;padding:8px}.header.svelte-1es105s{display:flex;gap:4px;margin-bottom:4px}");
}
var get_default_slot_changes = (dirty) => ({ selected: dirty & 2 });
var get_default_slot_context = (ctx) => ({ selected: ctx[1] });
function get_each_context4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_each_block4(ctx) {
  let div;
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[4](ctx[6]);
  }
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      attr(div, "class", "clickable-icon");
      toggle_class(div, "is-active", ctx[6] === ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (!mounted) {
        dispose = listen(div, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[6] + ""))
        set_data(t0, t0_value);
      if (dirty & 3) {
        toggle_class(div, "is-active", ctx[6] === ctx[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment32(ctx) {
  let div2;
  let div0;
  let t3;
  let div1;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx, each_value, i2));
  }
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], get_default_slot_context);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "header svelte-1es105s");
      attr(div1, "class", "card nomargin svelte-1es105s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div0, null);
      }
      append(div2, t3);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 6)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, get_default_slot_changes), get_default_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  var _a;
  let { options } = $$props;
  let selected = (_a = options[0]) !== null && _a !== void 0 ? _a : "";
  const click_handler = (option2) => {
    $$invalidate(1, selected = option2);
  };
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(0, options = $$props2.options);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [options, selected, $$scope, slots, click_handler];
}
var TabContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, { options: 0 }, add_css15);
  }
};
var TabContainer_default = TabContainer;

// src/app/onboarding/Onboarding.svelte
function add_css16(target) {
  append_styles(target, "svelte-a9juqy", "pre.svelte-a9juqy{background-color:var(--background-secondary);border-radius:var(--radius-s);padding:8px}ol.svelte-a9juqy{margin:0;padding:0 22px}");
}
function create_default_slot_62(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Get started with Projects");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_52(ctx) {
  let t0;
  let a2;
  let t22;
  return {
    c() {
      t0 = text("Projects lets you manage groups of related notes using\n    ");
      a2 = element("a");
      a2.textContent = "front matter";
      t22 = text(". For example, a folder with the blog posts you're working on.");
      attr(a2, "href", "https://help.obsidian.md/Advanced+topics/YAML+front+matter");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, a2, anchor);
      insert(target, t22, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t22);
    }
  };
}
function create_default_slot_42(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Start from scratch, or explore a demo project \u{1F447}");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_32(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Create new project");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_22(ctx) {
  let t3;
  return {
    c() {
      t3 = text("Try a demo project");
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_12(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[2]);
  button1 = new Button_default({
    props: {
      variant: "default",
      tooltip: "Creates a new folder at the root of your vault with example notes.",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[3]);
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & 32) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 32) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_else_block2(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>In the top-right corner of the <strong>Projects</strong>
          view, click
          <strong>New</strong>.</li> 
        <li>Click <strong>New project</strong>.</li>`;
      attr(ol, "class", "svelte-a9juqy");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block_14(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Open the <strong>Command palette</strong>.</li> 
        <li>Search for <strong>Create new project</strong></li> 
        <li>Press <strong>Enter</strong>.</li>`;
      attr(ol, "class", "svelte-a9juqy");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_if_block7(ctx) {
  let ol;
  return {
    c() {
      ol = element("ol");
      ol.innerHTML = `<li>Right-click a folder in <strong>File explorer</strong>.</li> 
        <li>Click <strong>Create project in folder</strong>.</li>`;
      attr(ol, "class", "svelte-a9juqy");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(ol);
    }
  };
}
function create_default_slot7(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4] === "File explorer")
      return create_if_block7;
    if (ctx2[4] === "Command palette")
      return create_if_block_14;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment33(ctx) {
  let div;
  let typography0;
  let t0;
  let typography1;
  let t1;
  let pre;
  let t3;
  let typography2;
  let t4;
  let modalbuttongroup;
  let t5;
  let p2;
  let p_style_value;
  let t8;
  let tabcontainer;
  let current;
  typography0 = new Typography_default({
    props: {
      variant: "h1",
      $$slots: { default: [create_default_slot_62] },
      $$scope: { ctx }
    }
  });
  typography1 = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_52] },
      $$scope: { ctx }
    }
  });
  typography2 = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  tabcontainer = new TabContainer_default({
    props: {
      options: ["Projects view", "Command palette", "File explorer"],
      $$slots: {
        default: [
          create_default_slot7,
          ({ selected }) => ({ 4: selected }),
          ({ selected }) => selected ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(typography0.$$.fragment);
      t0 = space();
      create_component(typography1.$$.fragment);
      t1 = space();
      pre = element("pre");
      pre.innerHTML = `<code>---
status: Backlog
due: 2023-01-01
published: false
---

# My blog post</code>`;
      t3 = space();
      create_component(typography2.$$.fragment);
      t4 = space();
      create_component(modalbuttongroup.$$.fragment);
      t5 = space();
      p2 = element("p");
      p2.innerHTML = `<strong>Psst! \u{1F44B}</strong> Next time you can create your projects using any of
    the following ways:`;
      t8 = space();
      create_component(tabcontainer.$$.fragment);
      attr(pre, "class", "svelte-a9juqy");
      attr(p2, "style", p_style_value = "color: var(--text-muted); margin-top: 45px; font-size: var(--font-ui-smaller);");
      attr(div, "class", "center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography0, div, null);
      append(div, t0);
      mount_component(typography1, div, null);
      append(div, t1);
      append(div, pre);
      append(div, t3);
      mount_component(typography2, div, null);
      append(div, t4);
      mount_component(modalbuttongroup, div, null);
      append(div, t5);
      append(div, p2);
      append(div, t8);
      mount_component(tabcontainer, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography0_changes = {};
      if (dirty & 32) {
        typography0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography0.$set(typography0_changes);
      const typography1_changes = {};
      if (dirty & 32) {
        typography1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography1.$set(typography1_changes);
      const typography2_changes = {};
      if (dirty & 32) {
        typography2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography2.$set(typography2_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 35) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
      const tabcontainer_changes = {};
      if (dirty & 48) {
        tabcontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabcontainer.$set(tabcontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography0.$$.fragment, local);
      transition_in(typography1.$$.fragment, local);
      transition_in(typography2.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      transition_in(tabcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography0.$$.fragment, local);
      transition_out(typography1.$$.fragment, local);
      transition_out(typography2.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      transition_out(tabcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography0);
      destroy_component(typography1);
      destroy_component(typography2);
      destroy_component(modalbuttongroup);
      destroy_component(tabcontainer);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { onCreate } = $$props;
  let { onTry } = $$props;
  const click_handler = () => onCreate();
  const click_handler_1 = () => onTry();
  $$self.$$set = ($$props2) => {
    if ("onCreate" in $$props2)
      $$invalidate(0, onCreate = $$props2.onCreate);
    if ("onTry" in $$props2)
      $$invalidate(1, onTry = $$props2.onTry);
  };
  return [onCreate, onTry, click_handler, click_handler_1];
}
var Onboarding = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, { onCreate: 0, onTry: 1 }, add_css16);
  }
};
var Onboarding_default = Onboarding;

// src/app/onboarding/onboarding-modal.ts
var OnboardingModal = class extends import_obsidian14.Modal {
  constructor(app2, onCreate, onTry) {
    super(app2);
    this.onCreate = onCreate;
    this.onTry = onTry;
  }
  onOpen() {
    this.component = new Onboarding_default({
      target: this.contentEl,
      props: {
        onCreate: () => {
          this.onCreate();
          this.close();
        },
        onTry: () => {
          this.onTry();
          this.close();
        }
      }
    });
  }
};

// src/lib/view-api.ts
var ViewApi = class {
  constructor(app2, dataSource2, dataApi) {
    this.app = app2;
    this.dataSource = dataSource2;
    this.dataApi = dataApi;
  }
  addRecord(record, templatePath) {
    if (this.dataSource.includes(record.id)) {
      dataFrame.addRecord(record);
    }
    this.dataApi.createNote(record, templatePath);
  }
  updateRecord(record, fields) {
    if (this.dataSource.includes(record.id)) {
      dataFrame.updateRecord(record);
    }
    this.dataApi.updateRecord(fields, record);
  }
  deleteRecord(recordId) {
    if (this.dataSource.includes(recordId)) {
      dataFrame.deleteRecord(recordId);
    }
    this.dataApi.deleteRecord(recordId);
  }
  renameField(from, to) {
    dataFrame.renameField(from, to);
    this.dataApi.renameField(filesFromRecords(this.app, get_store_value(dataFrame).records), from, to);
  }
  deleteField(field) {
    dataFrame.deleteField(field);
    this.dataApi.deleteField(filesFromRecords(this.app, get_store_value(dataFrame).records), field);
  }
};

// src/lib/datasources/dataview/dataview.ts
var import_obsidian_dataview2 = __toModule(require_lib());

// src/lib/datasources/dataview/dataview-helpers.ts
var import_dayjs3 = __toModule(require_dayjs_min());
var import_obsidian16 = __toModule(require("obsidian"));
function standardizeValues(app2, values) {
  const res = {};
  Object.keys(values).forEach((field) => {
    var _a, _b;
    const value = values[field];
    if (!value) {
      return;
    }
    if (typeof value === "object") {
      if ("path" in value && "display" in value) {
        const file = app2.vault.getAbstractFileByPath(value.path);
        if (file instanceof import_obsidian16.TFile) {
          const linkText = app2.metadataCache.fileToLinktext(file, "", true);
          res[field] = {
            displayName: (_a = value.display) != null ? _a : linkText,
            fullPath: value.path,
            linkText,
            sourcePath: ""
          };
        } else {
          res[field] = {
            displayName: (_b = value.display) != null ? _b : value.path,
            fullPath: value.path,
            linkText: value.path,
            sourcePath: ""
          };
        }
      }
      if ("ts" in value) {
        res[field] = (0, import_dayjs3.default)(value.ts).format("YYYY-MM-DD");
      }
    } else {
      res[field] = value;
    }
  });
  return res;
}

// src/lib/datasources/helpers.ts
var import_dayjs4 = __toModule(require_dayjs_min());
function parseRecords(records, fields) {
  for (const field of fields) {
    for (const record of records) {
      const value = record.values[field.name];
      switch (field.type) {
        case DataFieldType.Date:
          if (typeof value === "string") {
            record.values[field.name] = (0, import_dayjs4.default)(value).toDate();
          }
          break;
        case DataFieldType.List:
          if (typeof value === "string") {
            record.values[field.name] = [value];
          }
          break;
        case DataFieldType.Number:
          if (typeof value === "string") {
            record.values[field.name] = parseFloat(value);
          }
          break;
        case DataFieldType.Boolean:
          if (typeof value === "string") {
            record.values[field.name] = stringToBoolean(value);
          }
          break;
        case DataFieldType.String:
          if (typeof value !== "object") {
            record.values[field.name] = value == null ? void 0 : value.toLocaleString();
          }
          break;
      }
    }
  }
  return records;
}
function detectFields(records) {
  const valuesByField = {};
  records.forEach((record) => {
    Object.entries(record.values).forEach(([field, value]) => {
      var _a;
      valuesByField[field] = [...(_a = valuesByField[field]) != null ? _a : [], value];
    });
  });
  return Object.entries(valuesByField).map(([field, values]) => ({
    name: field,
    type: typeFromValues(values),
    identifier: false,
    derived: false
  }));
}
function typeFromValues(values) {
  const types = values.map((value) => detectCellType(value));
  const result = {};
  for (const type of types) {
    if (!result[type]) {
      result[type] = 0;
    }
    result[type]++;
  }
  const detectedTypes = Object.keys(result).filter((type) => type !== DataFieldType.Unknown);
  if (detectedTypes.length === 1) {
    return detectedTypes[0];
  } else if (detectedTypes.length > 1) {
    return DataFieldType.String;
  } else {
    return DataFieldType.Unknown;
  }
}
function detectCellType(value) {
  if (typeof value === "string") {
    if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
      return DataFieldType.Date;
    }
    return DataFieldType.String;
  } else if (typeof value === "number") {
    return DataFieldType.Number;
  } else if (typeof value === "boolean") {
    return DataFieldType.Boolean;
  }
  if (isLink2(value)) {
    return DataFieldType.Link;
  } else if (Array.isArray(value)) {
    return DataFieldType.List;
  }
  return DataFieldType.Unknown;
}
function isLink2(value) {
  if (value && typeof value === "object") {
    return "linkText" in value && "sourcePath" in value;
  }
  return false;
}
function stringToBoolean(stringValue) {
  var _a;
  switch ((_a = stringValue == null ? void 0 : stringValue.toLowerCase()) == null ? void 0 : _a.trim()) {
    case "true":
    case "yes":
    case "1":
      return true;
    case "false":
    case "no":
    case "0":
    case null:
    case void 0:
      return false;
    default:
      return !!stringValue;
  }
}

// src/lib/datasources/dataview/dataview.ts
var UnsupportedCapability = class extends Error {
  constructor(message) {
    super(message);
    this.name = get_store_value(i18n).t("errors.missingDataview.title");
  }
};
var DataviewDataSource = class extends DataSource {
  constructor(app2, project) {
    super(project);
    this.app = app2;
  }
  queryOne() {
    return __async(this, null, function* () {
      return this.queryAll();
    });
  }
  queryAll() {
    return __async(this, null, function* () {
      var _a;
      const api2 = this.getDataviewAPI();
      const result = yield api2 == null ? void 0 : api2.query((_a = this.project.query) != null ? _a : "", void 0, {
        forceId: true
      });
      if (!(result == null ? void 0 : result.successful) || result.value.type !== "table") {
        throw new Error("dataview query failed");
      }
      const rows = parseTableResult(result.value);
      const standardizedRecords = this.standardizeRecords(rows);
      const fields = detectSchema(standardizedRecords);
      const records = parseRecords(standardizedRecords, fields);
      return { fields, records };
    });
  }
  includes(_24) {
    return true;
  }
  readonly() {
    return true;
  }
  getDataviewAPI() {
    if ((0, import_obsidian_dataview2.isPluginEnabled)(this.app)) {
      return (0, import_obsidian_dataview2.getAPI)(this.app);
    } else {
      throw new UnsupportedCapability(get_store_value(i18n).t("errors.missingDataview.message"));
    }
  }
  standardizeRecords(rows) {
    const records = [];
    rows.forEach((row) => {
      const values = standardizeValues(this.app, row);
      const id = values["File"];
      if (id && isLink2(id) && id.fullPath) {
        records.push({ id: id.fullPath, values });
      }
    });
    return records;
  }
};
function parseTableResult(value) {
  const headers = value.headers;
  const rows = [];
  value.values.forEach((row) => {
    const values = {};
    headers.forEach((header, index2) => {
      const value2 = row[index2];
      values[header] = value2;
    });
    rows.push(values);
  });
  return rows;
}
function detectSchema(records) {
  return detectFields(records).map((field) => __spreadProps(__spreadValues({}, field), { derived: true })).map((field) => field.name === "File" ? __spreadProps(__spreadValues({}, field), { identifier: true }) : field);
}

// src/lib/datasources/frontmatter/frontmatter-helpers.ts
function standardizeRecord(id, values) {
  return {
    id,
    values: Object.fromEntries(Object.entries(values).map(([field, value]) => {
      return [field, isRawLink(value) ? parseRawLink(value, "") : value];
    }))
  };
}
function parseRawLink(rawLink, sourcePath) {
  var _a;
  if (rawLink[0]) {
    const text2 = rawLink[0][0];
    if (text2) {
      const split = text2.split("|");
      const linkText = (_a = split[0]) != null ? _a : "";
      const link = {
        linkText,
        sourcePath
      };
      return split[1] ? __spreadProps(__spreadValues({}, link), { displayName: split[1] }) : link;
    }
  }
  return void 0;
}

// src/lib/datasources/frontmatter/frontmatter.ts
var FrontMatterDataSource = class extends DataSource {
  constructor(app2, project) {
    super(project);
    this.app = app2;
  }
  queryOne(file, fields) {
    return __async(this, null, function* () {
      return this.queryFiles([file], fields);
    });
  }
  queryAll() {
    return __async(this, null, function* () {
      const files = this.app.vault.getMarkdownFiles().filter((file) => this.includes(file.path));
      return this.queryFiles(files);
    });
  }
  queryFiles(files, predefinedFields) {
    return __async(this, null, function* () {
      const standardizedRecords = standardizeRecords(files, this.app.metadataCache);
      let fields = detectSchema2(standardizedRecords);
      for (const predefinedField of predefinedFields != null ? predefinedFields : []) {
        fields = fields.map((field) => field.name !== predefinedField.name ? field : __spreadProps(__spreadValues({}, field), { type: predefinedField.type }));
      }
      const records = parseRecords(standardizedRecords, fields);
      return { fields, records };
    });
  }
  includes(path4) {
    const trimmedPath = this.project.path.startsWith("/") ? this.project.path.slice(1) : this.project.path;
    if (!path4.startsWith(trimmedPath)) {
      return false;
    }
    if (!this.project.recursive) {
      const pathElements = path4.split("/").slice(0, -1);
      const projectPathElements = trimmedPath.split("/").filter((el) => el);
      return pathElements.join("/") === projectPathElements.join("/");
    }
    return true;
  }
};
function standardizeRecords(files, metadataCache) {
  var _a;
  const records = [];
  for (const file of files) {
    const cache = metadataCache.getFileCache(file);
    if (cache) {
      const _b = (_a = cache.frontmatter) != null ? _a : {}, { position } = _b, values = __objRest(_b, ["position"]);
      const filteredValues = Object.fromEntries(Object.entries(values).filter(([_24, value]) => notEmpty(value)));
      filteredValues["path"] = file.path;
      filteredValues["name"] = file.basename;
      records.push(standardizeRecord(file.path, filteredValues));
    }
  }
  return records;
}
function detectSchema2(records) {
  return detectFields(records).map((field) => field.name === "name" || field.name === "path" ? __spreadProps(__spreadValues({}, field), { derived: true }) : field).map((field) => field.name === "path" ? __spreadProps(__spreadValues({}, field), { identifier: true }) : field);
}

// src/app/toolbar/Toolbar.svelte
var import_obsidian25 = __toModule(require("obsidian"));

// src/modals/add-view-modal.ts
var import_obsidian17 = __toModule(require("obsidian"));

// src/lib/stores/custom-views.ts
var customViews = writable({});

// src/modals/components/AddView.svelte
function create_default_slot_63(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[3],
      options: ctx[8]
    }
  });
  select.$on("change", ctx[9]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 8)
        select_changes.value = ctx2[3];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_53(ctx) {
  var _a;
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: ctx[2],
      placeholder: (_a = ctx[6].t("modals.view.create.optional")) != null ? _a : "",
      error: !!ctx[4],
      helperText: ctx[4]
    }
  });
  textinput.$on("input", ctx[10]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const textinput_changes = {};
      if (dirty & 4)
        textinput_changes.value = ctx2[2];
      if (dirty & 64)
        textinput_changes.placeholder = (_a2 = ctx2[6].t("modals.view.create.optional")) != null ? _a2 : "";
      if (dirty & 16)
        textinput_changes.error = !!ctx2[4];
      if (dirty & 16)
        textinput_changes.helperText = ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_43(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[0].id,
      options: ctx[7].projects.map(func3)
    }
  });
  select.$on("change", ctx[11]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 1)
        select_changes.value = ctx2[0].id;
      if (dirty & 128)
        select_changes.options = ctx2[7].projects.map(func3);
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_33(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let settingitem2;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.view.create.type.name"),
      description: (_a = ctx[6].t("modals.view.create.type.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_63] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.view.create.name.name"),
      description: (_b = ctx[6].t("modals.view.create.name.description")) != null ? _b : "",
      $$slots: { default: [create_default_slot_53] },
      $$scope: { ctx }
    }
  });
  settingitem2 = new SettingItem_default({
    props: {
      name: ctx[6].t("modals.note.create.project.name"),
      description: (_c = ctx[6].t("modals.note.create.project.description")) != null ? _c : "",
      $$slots: { default: [create_default_slot_43] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      create_component(settingitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(settingitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & 64)
        settingitem0_changes.name = ctx2[6].t("modals.view.create.type.name");
      if (dirty & 64)
        settingitem0_changes.description = (_a2 = ctx2[6].t("modals.view.create.type.description")) != null ? _a2 : "";
      if (dirty & 32776) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 64)
        settingitem1_changes.name = ctx2[6].t("modals.view.create.name.name");
      if (dirty & 64)
        settingitem1_changes.description = (_b2 = ctx2[6].t("modals.view.create.name.description")) != null ? _b2 : "";
      if (dirty & 32852) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      const settingitem2_changes = {};
      if (dirty & 64)
        settingitem2_changes.name = ctx2[6].t("modals.note.create.project.name");
      if (dirty & 64)
        settingitem2_changes.description = (_c2 = ctx2[6].t("modals.note.create.project.description")) != null ? _c2 : "";
      if (dirty & 32897) {
        settingitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem2.$set(settingitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(settingitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(settingitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(settingitem2, detaching);
    }
  };
}
function create_default_slot_23(ctx) {
  let t_value = ctx[6].t("modals.view.create.cta") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.view.create.cta") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_13(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[12]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 32832) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot8(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 32989) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 32879) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment34(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[6].t("modals.view.create.title"),
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 64)
        modallayout_changes.title = ctx2[6].t("modals.view.create.title");
      if (dirty & 33023) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func3 = (project) => ({ label: project.name, value: project.id });
function instance34($$self, $$props, $$invalidate) {
  let selectedOption;
  let nameError;
  let $i18n;
  let $customViews;
  let $settings;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, customViews, ($$value) => $$invalidate(13, $customViews = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(7, $settings = $$value));
  let { onSave } = $$props;
  let { project } = $$props;
  let name = "";
  let type = "table";
  const options = Object.values($customViews).map((view2) => {
    return {
      label: view2.getDisplayName(),
      value: view2.getViewType()
    };
  });
  function validateName(name2) {
    if (project.views.find((view2) => view2.name === name2)) {
      return $i18n.t("modals.view.create.existing-name-error");
    }
    return "";
  }
  const change_handler = ({ detail: value }) => {
    $$invalidate(3, type = value);
  };
  const input_handler = ({ detail: value }) => $$invalidate(2, name = value);
  const change_handler_1 = ({ detail: id }) => {
    const res = $settings.projects.find((w2) => w2.id === id);
    if (res) {
      $$invalidate(0, project = res);
    }
  };
  const click_handler = () => {
    var _a;
    onSave(project.id, {
      id: v4_default(),
      name: name || nextUniqueViewName(project.views, (_a = selectedOption == null ? void 0 : selectedOption.label) != null ? _a : type),
      type,
      config: {}
    });
  };
  $$self.$$set = ($$props2) => {
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(5, selectedOption = options.find((option2) => option2.value === type));
    }
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    project,
    onSave,
    name,
    type,
    nameError,
    selectedOption,
    $i18n,
    $settings,
    options,
    change_handler,
    input_handler,
    change_handler_1,
    click_handler
  ];
}
var AddView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, { onSave: 1, project: 0 });
  }
};
var AddView_default = AddView;

// src/modals/add-view-modal.ts
var AddViewModal = class extends import_obsidian17.Modal {
  constructor(app2, project, onSave) {
    super(app2);
    this.project = project;
    this.onSave = onSave;
  }
  onOpen() {
    this.component = new AddView_default({
      target: this.contentEl,
      props: {
        project: this.project,
        onSave: (projectId, view2) => {
          this.onSave(projectId, view2);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/create-note-modal.ts
var import_moment3 = __toModule(require_moment());
var import_obsidian21 = __toModule(require("obsidian"));

// src/modals/components/CreateNote.svelte
var import_obsidian18 = __toModule(require("obsidian"));
function create_default_slot_72(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: ctx[0],
      autoFocus: true,
      error: !!ctx[4],
      helperText: ctx[4]
    }
  });
  textinput.$on("input", ctx[7]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0];
      if (dirty & 16)
        textinput_changes.error = !!ctx2[4];
      if (dirty & 16)
        textinput_changes.helperText = ctx2[4];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_default_slot_64(ctx) {
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[1].id,
      options: ctx[6].projects.map(func4)
    }
  });
  select.$on("change", ctx[8]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 2)
        select_changes.value = ctx2[1].id;
      if (dirty & 64)
        select_changes.options = ctx2[6].projects.map(func4);
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  var _a;
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[5].t("modals.note.create.templatePath.name"),
      description: (_a = ctx[5].t("modals.note.create.templatePath.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_54] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const settingitem_changes = {};
      if (dirty & 32)
        settingitem_changes.name = ctx2[5].t("modals.note.create.templatePath.name");
      if (dirty & 32)
        settingitem_changes.description = (_a2 = ctx2[5].t("modals.note.create.templatePath.description")) != null ? _a2 : "";
      if (dirty & 8234) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_54(ctx) {
  var _a;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: ctx[3],
      options: ctx[1].templates.map(func_1),
      placeholder: (_a = ctx[5].t("modals.note.create.templatePath.none")) != null ? _a : "",
      allowEmpty: true
    }
  });
  select.$on("change", ctx[9]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const select_changes = {};
      if (dirty & 8)
        select_changes.value = ctx2[3];
      if (dirty & 2)
        select_changes.options = ctx2[1].templates.map(func_1);
      if (dirty & 32)
        select_changes.placeholder = (_a2 = ctx2[5].t("modals.note.create.templatePath.none")) != null ? _a2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_if_block8(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[5].t("modals.note.create.readonly.title"),
      icon: "alert-triangle",
      variant: "danger",
      $$slots: { default: [create_default_slot_44] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 32)
        callout_changes.title = ctx2[5].t("modals.note.create.readonly.title");
      if (dirty & 8226) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_44(ctx) {
  let t_value = ctx[5].t("modals.note.create.readonly.message", { project: ctx[1].name }) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 34 && t_value !== (t_value = ctx2[5].t("modals.note.create.readonly.message", { project: ctx2[1].name }) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_34(ctx) {
  var _a, _b, _c;
  let settingitem0;
  let t0;
  let settingitem1;
  let t1;
  let t22;
  let if_block1_anchor;
  let current;
  settingitem0 = new SettingItem_default({
    props: {
      name: ctx[5].t("modals.note.create.name.name"),
      description: (_a = ctx[5].t("modals.note.create.name.description")) != null ? _a : "",
      $$slots: { default: [create_default_slot_72] },
      $$scope: { ctx }
    }
  });
  settingitem1 = new SettingItem_default({
    props: {
      name: ctx[5].t("modals.note.create.project.name"),
      description: (_b = ctx[5].t("modals.note.create.project.description")) != null ? _b : "",
      $$slots: { default: [create_default_slot_64] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ((_c = ctx[1].templates) == null ? void 0 : _c.length) && create_if_block_15(ctx);
  let if_block1 = ctx[1].dataview && create_if_block8(ctx);
  return {
    c() {
      create_component(settingitem0.$$.fragment);
      t0 = space();
      create_component(settingitem1.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t22 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(settingitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(settingitem1, target, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t22, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const settingitem0_changes = {};
      if (dirty & 32)
        settingitem0_changes.name = ctx2[5].t("modals.note.create.name.name");
      if (dirty & 32)
        settingitem0_changes.description = (_a2 = ctx2[5].t("modals.note.create.name.description")) != null ? _a2 : "";
      if (dirty & 8209) {
        settingitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem0.$set(settingitem0_changes);
      const settingitem1_changes = {};
      if (dirty & 32)
        settingitem1_changes.name = ctx2[5].t("modals.note.create.project.name");
      if (dirty & 32)
        settingitem1_changes.description = (_b2 = ctx2[5].t("modals.note.create.project.description")) != null ? _b2 : "";
      if (dirty & 8258) {
        settingitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem1.$set(settingitem1_changes);
      if ((_c2 = ctx2[1].templates) == null ? void 0 : _c2.length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t22.parentNode, t22);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1].dataview) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem0.$$.fragment, local);
      transition_in(settingitem1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(settingitem0.$$.fragment, local);
      transition_out(settingitem1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(settingitem1, detaching);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t22);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_default_slot_24(ctx) {
  let t_value = ctx[5].t("modals.note.create.create") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].t("modals.note.create.create") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_14(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      disabled: !!ctx[4] || !!ctx[1].dataview,
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[10]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 18)
        button_changes.disabled = !!ctx2[4] || !!ctx2[1].dataview;
      if (dirty & 8224) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot9(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 8315) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 8255) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment35(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[5].t("modals.note.create.title"),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 32)
        modallayout_changes.title = ctx2[5].t("modals.note.create.title");
      if (dirty & 8319) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
var func4 = (project) => ({ label: project.name, value: project.id });
var func_1 = (path4) => ({ label: path4, value: path4 });
function instance35($$self, $$props, $$invalidate) {
  let nameError;
  let $i18n;
  let $app;
  let $settings;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(11, $app = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(6, $settings = $$value));
  let { name } = $$props;
  let { project } = $$props;
  let { onSave } = $$props;
  let templatePath = "";
  function validateName(name2) {
    if (name2 === "") {
      return $i18n.t("modals.note.create.empty-name-error");
    }
    const existingFile = $app.vault.getAbstractFileByPath((0, import_obsidian18.normalizePath)(project.path + "/" + name2 + ".md"));
    if (existingFile instanceof import_obsidian18.TFile) {
      return $i18n.t("modals.note.create.name-taken-error");
    }
    if (!isValidPath(name2)) {
      return $i18n.t("modals.project.defaultName.invalid");
    }
    return "";
  }
  const input_handler = ({ detail: value }) => $$invalidate(0, name = value);
  const change_handler = ({ detail: id }) => {
    const res = $settings.projects.find((w2) => w2.id === id);
    if (res) {
      $$invalidate(1, project = res);
    }
  };
  const change_handler_1 = ({ detail: value }) => $$invalidate(3, templatePath = value);
  const click_handler = () => {
    onSave(name, templatePath, project);
  };
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("onSave" in $$props2)
      $$invalidate(2, onSave = $$props2.onSave);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(4, nameError = validateName(name));
    }
  };
  return [
    name,
    project,
    onSave,
    templatePath,
    nameError,
    $i18n,
    $settings,
    input_handler,
    change_handler,
    change_handler_1,
    click_handler
  ];
}
var CreateNote = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, { name: 0, project: 1, onSave: 2 });
  }
};
var CreateNote_default = CreateNote;

// src/modals/create-note-modal.ts
var CreateNoteModal = class extends import_obsidian21.Modal {
  constructor(app2, project, onSave) {
    super(app2);
    this.project = project;
    this.onSave = onSave;
  }
  onOpen() {
    var _a;
    this.component = new CreateNote_default({
      target: this.contentEl,
      props: {
        name: this.project.defaultName ? interpolateTemplate((_a = this.project.defaultName) != null ? _a : "", {
          date: (format2) => (0, import_moment3.default)().format(format2 || "YYYY-MM-DD"),
          time: (format2) => (0, import_moment3.default)().format(format2 || "HH:mm")
        }) : nextUniqueFileName(this.project.path, get_store_value(i18n).t("modals.note.create.untitled")),
        project: this.project,
        onSave: (name, templatePath, project) => {
          this.onSave(name, templatePath, project);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/modals/confirm-dialog.ts
var import_obsidian22 = __toModule(require("obsidian"));

// src/modals/components/ConfirmDialog.svelte
function create_default_slot_55(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t3, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_45(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_55] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 258) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_default_slot_35(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_25(ctx) {
  let t_value = ctx[5].t("modals.confirm.cancel") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].t("modals.confirm.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_15(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: ctx[2] === ctx[5].t("modals.confirm.delete") ? "destructive" : "primary",
      $$slots: { default: [create_default_slot_35] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[6]);
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[7]);
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & 36)
        button0_changes.variant = ctx2[2] === ctx2[5].t("modals.confirm.delete") ? "destructive" : "primary";
      if (dirty & 260) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 288) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_default_slot10(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_45] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 258) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 316) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment36(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[0],
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 1)
        modallayout_changes.title = ctx2[0];
      if (dirty & 318) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(5, $i18n = $$value));
  let { title } = $$props;
  let { message } = $$props;
  let { cta } = $$props;
  let { onConfirm } = $$props;
  let { onCancel } = $$props;
  const click_handler = () => {
    onConfirm();
  };
  const click_handler_1 = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onConfirm" in $$props2)
      $$invalidate(3, onConfirm = $$props2.onConfirm);
    if ("onCancel" in $$props2)
      $$invalidate(4, onCancel = $$props2.onCancel);
  };
  return [
    title,
    message,
    cta,
    onConfirm,
    onCancel,
    $i18n,
    click_handler,
    click_handler_1
  ];
}
var ConfirmDialog = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, {
      title: 0,
      message: 1,
      cta: 2,
      onConfirm: 3,
      onCancel: 4
    });
  }
};
var ConfirmDialog_default = ConfirmDialog;

// src/modals/confirm-dialog.ts
var ConfirmDialogModal = class extends import_obsidian22.Modal {
  constructor(app2, title, message, cta, onConfirm) {
    super(app2);
    this.title = title;
    this.message = message;
    this.cta = cta;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    this.component = new ConfirmDialog_default({
      target: this.contentEl,
      props: {
        title: this.title,
        message: this.message,
        cta: this.cta,
        onConfirm: () => {
          this.onConfirm();
          this.close();
        },
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/app/toolbar/ProjectSelect.svelte
var import_obsidian23 = __toModule(require("obsidian"));
function add_css17(target) {
  append_styles(target, "svelte-h4e1e6", "span.svelte-h4e1e6{display:flex;align-items:center;gap:4px}");
}
function create_if_block9(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: { icon: "more-vertical", size: "sm" }
  });
  iconbutton.$on("click", ctx[7]);
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_fragment37(ctx) {
  var _a, _b;
  let span;
  let select;
  let t3;
  let current;
  select = new Select_default({
    props: {
      value: (_a = ctx[0]) != null ? _a : "",
      options: ctx[1].map(func5),
      placeholder: (_b = ctx[4].t("toolbar.projects.none")) != null ? _b : ""
    }
  });
  select.$on("change", ctx[6]);
  let if_block = ctx[1].length && create_if_block9(ctx);
  return {
    c() {
      span = element("span");
      create_component(select.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "svelte-h4e1e6");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(select, span, null);
      append(span, t3);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      const select_changes = {};
      if (dirty & 1)
        select_changes.value = (_a2 = ctx2[0]) != null ? _a2 : "";
      if (dirty & 2)
        select_changes.options = ctx2[1].map(func5);
      if (dirty & 16)
        select_changes.placeholder = (_b2 = ctx2[4].t("toolbar.projects.none")) != null ? _b2 : "";
      select.$set(select_changes);
      if (ctx2[1].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
}
var func5 = (project) => ({ label: project.name, value: project.id });
function instance37($$self, $$props, $$invalidate) {
  let project;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(4, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(5, $app = $$value));
  let { projectId } = $$props;
  let { projects } = $$props;
  let { onProjectChange } = $$props;
  const change_handler = ({ detail: value }) => onProjectChange(value);
  const click_handler = (event) => {
    const menu = new import_obsidian23.Menu();
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.edit.short-title")).setIcon("edit").onClick(() => {
        if (project) {
          new CreateProjectModal($app, $i18n.t("modals.project.edit.title"), $i18n.t("modals.project.edit.cta"), settings.updateProject, project).open();
        }
      });
    });
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.delete.short-title")).setIcon("trash").onClick(() => {
        new ConfirmDialogModal($app, $i18n.t("modals.project.delete.title"), $i18n.t("modals.project.delete.message"), $i18n.t("modals.project.delete.cta"), () => {
          if (projectId) {
            settings.deleteProject(projectId);
          }
        }).open();
      });
    });
    menu.showAtMouseEvent(event);
  };
  $$self.$$set = ($$props2) => {
    if ("projectId" in $$props2)
      $$invalidate(0, projectId = $$props2.projectId);
    if ("projects" in $$props2)
      $$invalidate(1, projects = $$props2.projects);
    if ("onProjectChange" in $$props2)
      $$invalidate(2, onProjectChange = $$props2.onProjectChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        $$invalidate(3, project = projects.find((project2) => project2.id === projectId));
    }
  };
  return [
    projectId,
    projects,
    onProjectChange,
    project,
    $i18n,
    $app,
    change_handler,
    click_handler
  ];
}
var ProjectSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      projectId: 0,
      projects: 1,
      onProjectChange: 2
    }, add_css17);
  }
};
var ProjectSelect_default = ProjectSelect;

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on2(el, event, fn3) {
  el.addEventListener(event, fn3, !IE11OrLess && captureMode);
}
function off(el, event, fn3) {
  el.removeEventListener(event, fn3, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_24) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
    if (iterator) {
      for (; i2 < n2; i2++) {
        iterator(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left2 /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom2 = top2 + height;
      right2 = left2 + width;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i2 = 0, children2 = el.children;
  while (i2 < children2.length) {
    if (children2[i2].style.display !== "none" && children2[i2] !== Sortable.ghost && (includeDragEl || children2[i2] !== Sortable.dragged) && closest(children2[i2], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children2[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
        return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y2) {
  el.scrollLeft += x2;
  el.scrollTop += y2;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children2 = [].slice.call(this.el.children);
      children2.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin2) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin2)) {
        plugin2[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin2.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin2.pluginName, " more than once");
      }
    });
    plugins.push(plugin2);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (sortable[plugin2.pluginName][eventNameGlobal]) {
        sortable[plugin2.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin2.pluginName] && sortable[plugin2.pluginName][eventName]) {
        sortable[plugin2.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin2) {
      var pluginName = plugin2.pluginName;
      if (!sortable.options[pluginName] && !plugin2.initializeByDefault)
        return;
      var initialized = new plugin2(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin2) {
      if (typeof plugin2.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin2.eventProperties.call(sortable[plugin2.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin2) {
      if (!sortable[plugin2.pluginName])
        return;
      if (plugin2.optionListeners && typeof plugin2.optionListeners[name] === "function") {
        modifiedValue = plugin2.optionListeners[name].call(sortable[plugin2.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof2(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event[i2] = evt[i2];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn3 in this) {
    if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
      this[fn3] = this[fn3].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on2(el, "pointerdown", this._onTapStart);
  } else {
    on2(el, "mousedown", this._onTapStart);
    on2(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on2(el, "dragover", this);
    on2(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on2(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on2(ownerDocument, "mouseup", _this._onDrop);
      on2(ownerDocument, "touchend", _this._onDrop);
      on2(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on2(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on2(ownerDocument, "touchend", _this._disableDelayedDrag);
        on2(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on2(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on2(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on2(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on2(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on2(document, "touchmove", this._onTouchMove);
      } else {
        on2(document, "mousemove", this._onTouchMove);
      }
    } else {
      on2(dragEl, "dragend", this);
      on2(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on2(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on2(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on2(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray() {
    var order2 = [], el, children2 = this.el.children, i2 = 0, n2 = children2.length, options = this.options;
    for (; i2 < n2; i2++) {
      el = children2[i2];
      if (closest(el, options.draggable, this.el, false)) {
        order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i2) {
      var el = rootEl2.children[i2];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
  while (i2--) {
    sum += str.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn3) {
  return setTimeout(fn3, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on2(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on: on2,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element2) {
  return element2[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin2) {
    if (!plugin2.prototype || !plugin2.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin2));
    }
    if (plugin2.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin2.utils);
    PluginManager.mount(plugin2);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn3 in this) {
      if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
        this[fn3] = this[fn3].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on2(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on2(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on2(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on2(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// src/app/toolbar/ViewItemList.svelte
function add_css18(target) {
  append_styles(target, "svelte-1ow449f", "div.svelte-1ow449f{display:flex;justify-content:center;gap:var(--size-4-1);min-width:min-content}section.svelte-1ow449f{flex:1;overflow-x:auto}section.svelte-1ow449f::-webkit-scrollbar{display:none}");
}
function create_fragment38(ctx) {
  let section;
  let div;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      section = element("section");
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1ow449f");
      attr(section, "class", "svelte-1ow449f");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[4](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onSort } = $$props;
  let ref;
  let sortable;
  onMount(() => {
    sortable = sortable_esm_default.create(ref, {
      direction: () => "horizontal",
      animation: 100,
      dataIdAttr: "data-id",
      onSort: () => onSort(sortable.toArray())
    });
  });
  onDestroy(() => {
    sortable.destroy();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("onSort" in $$props2)
      $$invalidate(1, onSort = $$props2.onSort);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [ref, onSort, $$scope, slots, div_binding];
}
var ViewItemList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance38, create_fragment38, safe_not_equal, { onSort: 1 }, add_css18);
  }
};
var ViewItemList_default = ViewItemList;

// src/app/toolbar/ViewItem.svelte
function add_css19(target) {
  append_styles(target, "svelte-3t9vh7", "div.svelte-3t9vh7{display:inline-flex;align-items:center;gap:4px;height:1.8rem;padding:0 8px;min-width:min-content;font-size:var(--font-ui-small);border-radius:var(--radius-s);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;border:1px solid transparent}div.svelte-3t9vh7:hover{background-color:var(--background-modifier-hover)}.active.svelte-3t9vh7{background-color:var(--background-modifier-hover)}.error.svelte-3t9vh7{border:1px solid var(--background-modifier-error)}");
}
function create_if_block_22(ctx) {
  let icon_1;
  let current;
  icon_1 = new Icon_default({ props: { name: ctx[3] } });
  return {
    c() {
      create_component(icon_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & 8)
        icon_1_changes.name = ctx2[3];
      icon_1.$set(icon_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon_1, detaching);
    }
  };
}
function create_else_block3(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_if_block_16(ctx) {
  let textinput;
  let updating_ref;
  let updating_value;
  let current;
  function textinput_ref_binding(value) {
    ctx[13](value);
  }
  function textinput_value_binding(value) {
    ctx[14](value);
  }
  let textinput_props = {
    noPadding: true,
    embed: true,
    width: ctx[0].length + "ch"
  };
  if (ctx[5] !== void 0) {
    textinput_props.ref = ctx[5];
  }
  if (ctx[0] !== void 0) {
    textinput_props.value = ctx[0];
  }
  textinput = new TextInput_default({ props: textinput_props });
  binding_callbacks.push(() => bind(textinput, "ref", textinput_ref_binding));
  binding_callbacks.push(() => bind(textinput, "value", textinput_value_binding));
  textinput.$on("keydown", ctx[15]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.width = ctx2[0].length + "ch";
      if (!updating_ref && dirty & 32) {
        updating_ref = true;
        textinput_changes.ref = ctx2[5];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_value && dirty & 1) {
        updating_value = true;
        textinput_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block10(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: {
      icon: "cross",
      size: "sm",
      nopadding: true
    }
  });
  iconbutton.$on("click", ctx[16]);
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_fragment39(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_22(ctx);
  const if_block_creators = [create_if_block_16, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = ctx[7] && ctx[2] && create_if_block10(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "data-id", ctx[1]);
      attr(div, "class", "svelte-3t9vh7");
      toggle_class(div, "active", ctx[2]);
      toggle_class(div, "error", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "mouseenter", ctx[17]),
          listen(div, "mouseleave", ctx[18]),
          listen(div, "focus", ctx[19]),
          listen(div, "blur", ctx[20]),
          listen(div, "dblclick", ctx[21]),
          listen(div, "mousedown", ctx[12]),
          action_destroyer(useClickOutside_action = useClickOutside2.call(null, div, ctx[22]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, t1);
      }
      if (ctx2[7] && ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 132) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 2) {
        attr(div, "data-id", ctx2[1]);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 16)
        useClickOutside_action.update.call(null, ctx2[22]);
      if (!current || dirty & 4) {
        toggle_class(div, "active", ctx2[2]);
      }
      if (!current || dirty & 256) {
        toggle_class(div, "error", ctx2[8]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let error2;
  let { label } = $$props;
  let { id } = $$props;
  let { active = false } = $$props;
  let { icon = "" } = $$props;
  let { onValidate } = $$props;
  let fallback = label;
  function rollback() {
    $$invalidate(0, label = fallback);
  }
  let hovering = false;
  let editing = false;
  let inputRef;
  const dispatch = createEventDispatcher();
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function textinput_ref_binding(value) {
    inputRef = value;
    $$invalidate(5, inputRef);
  }
  function textinput_value_binding(value) {
    label = value;
    $$invalidate(0, label);
  }
  const keydown_handler = (event) => {
    if (event.key === "Enter") {
      $$invalidate(4, editing = false);
      if (!error2) {
        $$invalidate(6, fallback = label);
        dispatch("rename", label);
      } else {
        rollback();
      }
    }
  };
  const click_handler = () => dispatch("delete");
  const mouseenter_handler = () => $$invalidate(7, hovering = true);
  const mouseleave_handler = () => $$invalidate(7, hovering = false);
  const focus_handler = () => $$invalidate(7, hovering = true);
  const blur_handler = () => {
    $$invalidate(7, hovering = false);
    $$invalidate(4, editing = false);
    rollback();
  };
  const dblclick_handler = () => $$invalidate(4, editing = true);
  const useClickOutside_function = () => {
    $$invalidate(4, editing = false);
    rollback();
  };
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("icon" in $$props2)
      $$invalidate(3, icon = $$props2.icon);
    if ("onValidate" in $$props2)
      $$invalidate(11, onValidate = $$props2.onValidate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 48) {
      $:
        if (inputRef && editing) {
          inputRef.focus();
          inputRef.select();
        }
    }
    if ($$self.$$.dirty & 2049) {
      $:
        $$invalidate(8, error2 = !onValidate(label));
    }
  };
  return [
    label,
    id,
    active,
    icon,
    editing,
    inputRef,
    fallback,
    hovering,
    error2,
    rollback,
    dispatch,
    onValidate,
    mousedown_handler,
    textinput_ref_binding,
    textinput_value_binding,
    keydown_handler,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler,
    dblclick_handler,
    useClickOutside_function
  ];
}
var ViewItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      label: 0,
      id: 1,
      active: 2,
      icon: 3,
      onValidate: 11
    }, add_css19);
  }
};
var ViewItem_default = ViewItem;

// src/app/toolbar/ViewSelect.svelte
function get_each_context5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_each_block5(ctx) {
  let viewitem;
  let current;
  function func7(...args) {
    return ctx[8](ctx[13], ...args);
  }
  function mousedown_handler() {
    return ctx[9](ctx[13]);
  }
  function rename_handler(...args) {
    return ctx[10](ctx[13], ...args);
  }
  function delete_handler() {
    return ctx[11](ctx[13]);
  }
  viewitem = new ViewItem_default({
    props: {
      id: ctx[13].id,
      active: ctx[0] === ctx[13].id,
      label: ctx[13].name,
      icon: ctx[7](ctx[13].type),
      onValidate: func7
    }
  });
  viewitem.$on("mousedown", mousedown_handler);
  viewitem.$on("rename", rename_handler);
  viewitem.$on("delete", delete_handler);
  return {
    c() {
      create_component(viewitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const viewitem_changes = {};
      if (dirty & 2)
        viewitem_changes.id = ctx[13].id;
      if (dirty & 3)
        viewitem_changes.active = ctx[0] === ctx[13].id;
      if (dirty & 2)
        viewitem_changes.label = ctx[13].name;
      if (dirty & 2)
        viewitem_changes.icon = ctx[7](ctx[13].type);
      if (dirty & 66)
        viewitem_changes.onValidate = func7;
      viewitem.$set(viewitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewitem, detaching);
    }
  };
}
function create_key_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block5(get_each_context5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 223) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot11(ctx) {
  let previous_key = ctx[1];
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2 && safe_not_equal(previous_key, previous_key = ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_fragment40(ctx) {
  let viewitemlist;
  let current;
  viewitemlist = new ViewItemList_default({
    props: {
      onSort: ctx[5],
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(viewitemlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewitemlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const viewitemlist_changes = {};
      if (dirty & 32)
        viewitemlist_changes.onSort = ctx2[5];
      if (dirty & 65631) {
        viewitemlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      viewitemlist.$set(viewitemlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewitemlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewitemlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewitemlist, detaching);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let $customViews;
  component_subscribe($$self, customViews, ($$value) => $$invalidate(12, $customViews = $$value));
  let { viewId } = $$props;
  let { views } = $$props;
  let { onViewChange } = $$props;
  let { onViewDelete } = $$props;
  let { onViewRename } = $$props;
  let { onViewSort } = $$props;
  let { viewExists } = $$props;
  function iconFromViewType(type) {
    var _a, _b;
    return (_b = (_a = $customViews[type]) === null || _a === void 0 ? void 0 : _a.getIcon()) !== null && _b !== void 0 ? _b : "";
  }
  const func7 = (v2, name) => {
    if (name === v2.name) {
      return true;
    }
    return name !== "" && !viewExists(name);
  };
  const mousedown_handler = (v2) => onViewChange(v2.id);
  const rename_handler = (v2, { detail: name }) => {
    onViewRename(v2.id, name);
  };
  const delete_handler = (v2) => {
    onViewDelete(v2.id);
  };
  $$self.$$set = ($$props2) => {
    if ("viewId" in $$props2)
      $$invalidate(0, viewId = $$props2.viewId);
    if ("views" in $$props2)
      $$invalidate(1, views = $$props2.views);
    if ("onViewChange" in $$props2)
      $$invalidate(2, onViewChange = $$props2.onViewChange);
    if ("onViewDelete" in $$props2)
      $$invalidate(3, onViewDelete = $$props2.onViewDelete);
    if ("onViewRename" in $$props2)
      $$invalidate(4, onViewRename = $$props2.onViewRename);
    if ("onViewSort" in $$props2)
      $$invalidate(5, onViewSort = $$props2.onViewSort);
    if ("viewExists" in $$props2)
      $$invalidate(6, viewExists = $$props2.viewExists);
  };
  return [
    viewId,
    views,
    onViewChange,
    onViewDelete,
    onViewRename,
    onViewSort,
    viewExists,
    iconFromViewType,
    func7,
    mousedown_handler,
    rename_handler,
    delete_handler
  ];
}
var ViewSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      viewId: 0,
      views: 1,
      onViewChange: 2,
      onViewDelete: 3,
      onViewRename: 4,
      onViewSort: 5,
      viewExists: 6
    });
  }
};
var ViewSelect_default = ViewSelect;

// src/app/toolbar/Toolbar.svelte
function add_css20(target) {
  append_styles(target, "svelte-odv2ec", "div.svelte-odv2ec{background-color:var(--tab-background-active);display:flex;align-items:center;padding:var(--size-4-2);gap:8px;border-bottom:1px solid var(--background-modifier-border);justify-content:space-between}");
}
function create_if_block11(ctx) {
  let viewselect;
  let current;
  viewselect = new ViewSelect_default({
    props: {
      viewId: ctx[3],
      views: ctx[6],
      viewExists: ctx[11],
      onViewSort: ctx[12],
      onViewRename: ctx[13],
      onViewChange: ctx[4],
      onViewDelete: ctx[14]
    }
  });
  return {
    c() {
      create_component(viewselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewselect_changes = {};
      if (dirty & 8)
        viewselect_changes.viewId = ctx2[3];
      if (dirty & 64)
        viewselect_changes.views = ctx2[6];
      if (dirty & 32)
        viewselect_changes.viewExists = ctx2[11];
      if (dirty & 2)
        viewselect_changes.onViewSort = ctx2[12];
      if (dirty & 2)
        viewselect_changes.onViewRename = ctx2[13];
      if (dirty & 16)
        viewselect_changes.onViewChange = ctx2[4];
      if (dirty & 386)
        viewselect_changes.onViewDelete = ctx2[14];
      viewselect.$set(viewselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewselect, detaching);
    }
  };
}
function create_default_slot12(ctx) {
  let t0_value = ctx[8].t("toolbar.new") + "";
  let t0;
  let t1;
  let icon;
  let current;
  icon = new Icon_default({
    props: { accent: true, name: "chevron-down" }
  });
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 256) && t0_value !== (t0_value = ctx2[8].t("toolbar.new") + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment41(ctx) {
  let div;
  let projectselect;
  let t0;
  let t1;
  let button;
  let current;
  projectselect = new ProjectSelect_default({
    props: {
      projectId: ctx[1],
      projects: ctx[0],
      onProjectChange: ctx[2]
    }
  });
  let if_block = ctx[5] && create_if_block11(ctx);
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[15]);
  return {
    c() {
      div = element("div");
      create_component(projectselect.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(button.$$.fragment);
      attr(div, "class", "svelte-odv2ec");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(projectselect, div, null);
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const projectselect_changes = {};
      if (dirty & 2)
        projectselect_changes.projectId = ctx2[1];
      if (dirty & 1)
        projectselect_changes.projects = ctx2[0];
      if (dirty & 4)
        projectselect_changes.onProjectChange = ctx2[2];
      projectselect.$set(projectselect_changes);
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const button_changes = {};
      if (dirty & 65792) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(projectselect.$$.fragment, local);
      transition_in(if_block);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(projectselect.$$.fragment, local);
      transition_out(if_block);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(projectselect);
      if (if_block)
        if_block.d();
      destroy_component(button);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let project;
  let views;
  let $app;
  let $i18n;
  let $api;
  component_subscribe($$self, app, ($$value) => $$invalidate(7, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(8, $i18n = $$value));
  component_subscribe($$self, api, ($$value) => $$invalidate(9, $api = $$value));
  var _a;
  let { projects } = $$props;
  let { projectId } = $$props;
  let { onProjectChange } = $$props;
  let { viewId } = $$props;
  let { onViewChange } = $$props;
  const func7 = (name) => !!(project == null ? void 0 : project.views.find((view2) => view2.name === name));
  const func_13 = (viewIds) => {
    if (projectId) {
      settings.sortViews(projectId, viewIds);
    }
  };
  const func_2 = (viewId2, name) => {
    if (projectId) {
      settings.renameView(projectId, viewId2, name);
    }
  };
  const func_3 = (viewId2) => {
    new ConfirmDialogModal($app, $i18n.t("modals.view.delete.title"), $i18n.t("modals.view.delete.message"), $i18n.t("modals.view.delete.cta"), () => {
      if (projectId) {
        settings.deleteView(projectId, viewId2);
      }
    }).open();
  };
  const click_handler = (event) => {
    const menu = new import_obsidian25.Menu();
    menu.addItem((item) => {
      item.setTitle($i18n.t("modals.project.create.short-title")).setIcon("folder").onClick(() => {
        new CreateProjectModal($app, $i18n.t("modals.project.create.title"), $i18n.t("modals.project.create.cta"), (project2) => {
          settings.addProject(project2);
          onProjectChange(project2.id);
        }, createProject()).open();
      });
    });
    if (project) {
      menu.addItem((item) => {
        item.setTitle($i18n.t("modals.view.create.short-title")).setIcon("table").onClick(() => {
          if (project) {
            new AddViewModal($app, project, (projectId2, view2) => {
              settings.addView(projectId2, view2);
              onViewChange(view2.id);
            }).open();
          }
        });
      });
      menu.addItem((item) => {
        item.setTitle($i18n.t("modals.note.create.short-title")).setIcon("file").onClick(() => {
          if (project) {
            new CreateNoteModal($app, project, (name, templatePath, project2) => {
              $api.createNote(createDataRecord(name, project2), templatePath);
            }).open();
          }
        });
      });
    }
    menu.showAtMouseEvent(event);
  };
  $$self.$$set = ($$props2) => {
    if ("projects" in $$props2)
      $$invalidate(0, projects = $$props2.projects);
    if ("projectId" in $$props2)
      $$invalidate(1, projectId = $$props2.projectId);
    if ("onProjectChange" in $$props2)
      $$invalidate(2, onProjectChange = $$props2.onProjectChange);
    if ("viewId" in $$props2)
      $$invalidate(3, viewId = $$props2.viewId);
    if ("onViewChange" in $$props2)
      $$invalidate(4, onViewChange = $$props2.onViewChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $:
        $$invalidate(5, project = projects.find((project2) => project2.id === projectId));
    }
    if ($$self.$$.dirty & 1056) {
      $:
        $$invalidate(6, views = $$invalidate(10, _a = project === null || project === void 0 ? void 0 : project.views) !== null && _a !== void 0 ? _a : []);
    }
  };
  return [
    projects,
    projectId,
    onProjectChange,
    viewId,
    onViewChange,
    project,
    views,
    $app,
    $i18n,
    $api,
    _a,
    func7,
    func_13,
    func_2,
    func_3,
    click_handler
  ];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment41, safe_not_equal, {
      projects: 0,
      projectId: 1,
      onProjectChange: 2,
      viewId: 3,
      onViewChange: 4
    }, add_css20);
  }
};
var Toolbar_default = Toolbar;

// src/app/AppContainer.svelte
function add_css21(target) {
  append_styles(target, "svelte-gr1f73", ".projects-container.svelte-gr1f73{display:flex;flex-direction:column;height:100%}.projects-main.svelte-gr1f73{flex:1;display:flex;flex-direction:column;min-height:0}");
}
var get_default_slot_changes2 = (dirty) => ({
  project: dirty & 8,
  view: dirty & 16
});
var get_default_slot_context2 = (ctx) => ({
  project: ctx[3],
  view: ctx[4]
});
function create_fragment42(ctx) {
  var _a, _b;
  let div1;
  let toolbar;
  let t3;
  let div0;
  let current;
  toolbar = new Toolbar_default({
    props: {
      projects: ctx[2],
      projectId: (_a = ctx[3]) == null ? void 0 : _a.id,
      onProjectChange: ctx[9],
      viewId: (_b = ctx[4]) == null ? void 0 : _b.id,
      onViewChange: ctx[10]
    }
  });
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], get_default_slot_context2);
  return {
    c() {
      div1 = element("div");
      create_component(toolbar.$$.fragment);
      t3 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "projects-main svelte-gr1f73");
      attr(div1, "class", "projects-container svelte-gr1f73");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(toolbar, div1, null);
      append(div1, t3);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      const toolbar_changes = {};
      if (dirty & 4)
        toolbar_changes.projects = ctx2[2];
      if (dirty & 8)
        toolbar_changes.projectId = (_a2 = ctx2[3]) == null ? void 0 : _a2.id;
      if (dirty & 1)
        toolbar_changes.onProjectChange = ctx2[9];
      if (dirty & 16)
        toolbar_changes.viewId = (_b2 = ctx2[4]) == null ? void 0 : _b2.id;
      if (dirty & 2)
        toolbar_changes.onViewChange = ctx2[10];
      toolbar.$set(toolbar_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 152)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[7], !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, get_default_slot_changes2), get_default_slot_context2);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(toolbar);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let selectedProject;
  let views;
  let selectedView;
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(6, $app = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { projects } = $$props;
  let { projectId } = $$props;
  let { viewId } = $$props;
  function resolveDataSource(project, app2) {
    return project.dataview ? new DataviewDataSource(app2, project) : new FrontMatterDataSource(app2, project);
  }
  const func7 = (id) => $$invalidate(0, projectId = id);
  const func_13 = (id) => $$invalidate(1, viewId = id);
  $$self.$$set = ($$props2) => {
    if ("projects" in $$props2)
      $$invalidate(2, projects = $$props2.projects);
    if ("projectId" in $$props2)
      $$invalidate(0, projectId = $$props2.projectId);
    if ("viewId" in $$props2)
      $$invalidate(1, viewId = $$props2.viewId);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 5) {
      $:
        $$invalidate(3, selectedProject = projects.find((project) => projectId === project.id) || projects[0]);
    }
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(5, views = (selectedProject === null || selectedProject === void 0 ? void 0 : selectedProject.views) || []);
    }
    if ($$self.$$.dirty & 34) {
      $:
        $$invalidate(4, selectedView = views.find((view2) => viewId === view2.id) || views[0]);
    }
    if ($$self.$$.dirty & 72) {
      $: {
        if (selectedProject) {
          dataSource.set(resolveDataSource(selectedProject, $app));
        }
      }
    }
  };
  return [
    projectId,
    viewId,
    projects,
    selectedProject,
    selectedView,
    views,
    $app,
    $$scope,
    slots,
    func7,
    func_13
  ];
}
var AppContainer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, { projects: 2, projectId: 0, viewId: 1 }, add_css21);
  }
};
var AppContainer_default = AppContainer;

// src/views/Custom/CustomView.svelte
function add_css22(target) {
  append_styles(target, "svelte-9xlp1d", "div.svelte-9xlp1d{width:100%;height:100%;overflow:auto}");
}
function create_fragment43(ctx) {
  let div;
  let useView_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "svelte-9xlp1d");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(useView_action = ctx[7].call(null, div, {
          view: ctx[0],
          dataProps: {
            data: ctx[4],
            viewApi: ctx[1],
            project: ctx[5],
            readonly: ctx[6]
          },
          config: ctx[2],
          onConfigChange: ctx[3]
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (useView_action && is_function(useView_action.update) && dirty & 127)
        useView_action.update.call(null, {
          view: ctx2[0],
          dataProps: {
            data: ctx2[4],
            viewApi: ctx2[1],
            project: ctx2[5],
            readonly: ctx2[6]
          },
          config: ctx2[2],
          onConfigChange: ctx2[3]
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let $customViews;
  component_subscribe($$self, customViews, ($$value) => $$invalidate(8, $customViews = $$value));
  let { view: view2 } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  let { frame } = $$props;
  let { project } = $$props;
  let { readonly } = $$props;
  function useView(node, props) {
    let viewId = props.view.id;
    let projectView = $customViews[props.view.type];
    if (projectView) {
      projectView.onOpen({
        contentEl: node,
        config: props.config,
        saveConfig: props.onConfigChange
      });
      projectView.onData(props.dataProps);
    }
    return {
      update(newprops) {
        const dirty = newprops.view.id !== viewId;
        if (dirty) {
          projectView === null || projectView === void 0 ? void 0 : projectView.onClose();
          node.empty();
          projectView = $customViews[newprops.view.type];
          if (projectView) {
            projectView.onOpen({
              contentEl: node,
              config: newprops.config,
              saveConfig: newprops.onConfigChange
            });
            projectView.onData(newprops.dataProps);
          }
          viewId = newprops.view.id;
        } else {
          projectView === null || projectView === void 0 ? void 0 : projectView.onData(newprops.dataProps);
        }
      },
      destroy() {
        projectView === null || projectView === void 0 ? void 0 : projectView.onClose();
      }
    };
  }
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view2 = $$props2.view);
    if ("api" in $$props2)
      $$invalidate(1, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(2, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(3, onConfigChange = $$props2.onConfigChange);
    if ("frame" in $$props2)
      $$invalidate(4, frame = $$props2.frame);
    if ("project" in $$props2)
      $$invalidate(5, project = $$props2.project);
    if ("readonly" in $$props2)
      $$invalidate(6, readonly = $$props2.readonly);
  };
  return [view2, api2, config, onConfigChange, frame, project, readonly, useView];
}
var CustomView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, not_equal, {
      view: 0,
      api: 1,
      config: 2,
      onConfigChange: 3,
      frame: 4,
      project: 5,
      readonly: 6
    }, add_css22);
  }
};
var CustomView_default = CustomView;

// src/views/View/View.svelte
function create_fragment44(ctx) {
  let customview;
  let current;
  customview = new CustomView_default({
    props: {
      frame: ctx[2],
      project: ctx[0],
      view: ctx[1],
      config: ctx[1].config,
      readonly: ctx[3],
      api: ctx[4],
      onConfigChange: ctx[5]
    }
  });
  return {
    c() {
      create_component(customview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(customview, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const customview_changes = {};
      if (dirty & 4)
        customview_changes.frame = ctx2[2];
      if (dirty & 1)
        customview_changes.project = ctx2[0];
      if (dirty & 2)
        customview_changes.view = ctx2[1];
      if (dirty & 2)
        customview_changes.config = ctx2[1].config;
      if (dirty & 8)
        customview_changes.readonly = ctx2[3];
      if (dirty & 16)
        customview_changes.api = ctx2[4];
      customview.$set(customview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(customview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(customview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(customview, detaching);
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let { project } = $$props;
  let { view: view2 } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { onConfigChange } = $$props;
  function handleConfigChange(config) {
    onConfigChange(project.id, view2.id, config);
  }
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
    if ("view" in $$props2)
      $$invalidate(1, view2 = $$props2.view);
    if ("frame" in $$props2)
      $$invalidate(2, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(4, api2 = $$props2.api);
    if ("onConfigChange" in $$props2)
      $$invalidate(6, onConfigChange = $$props2.onConfigChange);
  };
  return [project, view2, frame, readonly, api2, handleConfigChange, onConfigChange];
}
var View = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, {
      project: 0,
      view: 1,
      frame: 2,
      readonly: 3,
      api: 4,
      onConfigChange: 6
    });
  }
};
var View_default = View;

// src/app/App.svelte
function create_catch_block(ctx) {
  let div;
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[14].name,
      icon: "zap",
      variant: "danger",
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(callout.$$.fragment);
      set_style(div, "padding", "var(--size-4-3)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(callout, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 8)
        callout_changes.title = ctx2[14].name;
      if (dirty & 32776) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(callout);
    }
  };
}
function create_default_slot_26(ctx) {
  let t_value = ctx[14].message + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[14].message + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_16(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "body",
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 32776) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_then_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[12] && ctx[13] && ctx[0] && create_if_block12(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[12] && ctx2[13] && ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 12289) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block12(ctx) {
  let view2;
  let current;
  view2 = new View_default({
    props: {
      project: ctx[12],
      view: ctx[13],
      readonly: ctx[0].readonly(),
      api: new ViewApi(ctx[5], ctx[0], ctx[6]),
      onConfigChange: settings.updateViewConfig,
      frame: ctx[7]
    }
  });
  return {
    c() {
      create_component(view2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(view2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const view_changes = {};
      if (dirty & 4096)
        view_changes.project = ctx2[12];
      if (dirty & 8192)
        view_changes.view = ctx2[13];
      if (dirty & 1)
        view_changes.readonly = ctx2[0].readonly();
      if (dirty & 97)
        view_changes.api = new ViewApi(ctx2[5], ctx2[0], ctx2[6]);
      if (dirty & 128)
        view_changes.frame = ctx2[7];
      view2.$set(view_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(view2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(view2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(view2, detaching);
    }
  };
}
function create_pending_block(ctx) {
  let loading;
  let current;
  loading = new Loading_default({});
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function create_default_slot13(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    error: 14,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[3], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 8 && promise !== (promise = ctx[3]) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment45(ctx) {
  let appcontainer;
  let updating_projectId;
  let updating_viewId;
  let current;
  function appcontainer_projectId_binding(value) {
    ctx[9](value);
  }
  function appcontainer_viewId_binding(value) {
    ctx[10](value);
  }
  let appcontainer_props = {
    projects: ctx[4],
    $$slots: {
      default: [
        create_default_slot13,
        ({ project, view: view2 }) => ({ 12: project, 13: view2 }),
        ({ project, view: view2 }) => (project ? 4096 : 0) | (view2 ? 8192 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    appcontainer_props.projectId = ctx[1];
  }
  if (ctx[2] !== void 0) {
    appcontainer_props.viewId = ctx[2];
  }
  appcontainer = new AppContainer_default({ props: appcontainer_props });
  binding_callbacks.push(() => bind(appcontainer, "projectId", appcontainer_projectId_binding));
  binding_callbacks.push(() => bind(appcontainer, "viewId", appcontainer_viewId_binding));
  return {
    c() {
      create_component(appcontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(appcontainer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const appcontainer_changes = {};
      if (dirty & 16)
        appcontainer_changes.projects = ctx2[4];
      if (dirty & 45289) {
        appcontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_projectId && dirty & 2) {
        updating_projectId = true;
        appcontainer_changes.projectId = ctx2[1];
        add_flush_callback(() => updating_projectId = false);
      }
      if (!updating_viewId && dirty & 4) {
        updating_viewId = true;
        appcontainer_changes.viewId = ctx2[2];
        add_flush_callback(() => updating_viewId = false);
      }
      appcontainer.$set(appcontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(appcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(appcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(appcontainer, detaching);
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let projects;
  let $app;
  let $i18n;
  let $dataSource;
  let $settings;
  let $api;
  let $dataFrame;
  component_subscribe($$self, app, ($$value) => $$invalidate(5, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(11, $i18n = $$value));
  component_subscribe($$self, dataSource, ($$value) => $$invalidate(0, $dataSource = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(8, $settings = $$value));
  component_subscribe($$self, api, ($$value) => $$invalidate(6, $api = $$value));
  component_subscribe($$self, dataFrame, ($$value) => $$invalidate(7, $dataFrame = $$value));
  let projectId;
  let viewId;
  let querying;
  onMount(() => {
    if (!projects.length) {
      new OnboardingModal($app, () => {
        new CreateProjectModal($app, $i18n.t("modals.project.create.title"), $i18n.t("modals.project.create.cta"), settings.addProject, createProject()).open();
      }, () => {
        createDemoProject($app.vault);
      }).open();
    }
  });
  function appcontainer_projectId_binding(value) {
    projectId = value;
    $$invalidate(1, projectId);
  }
  function appcontainer_viewId_binding(value) {
    viewId = value;
    $$invalidate(2, viewId);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(4, { projects } = $settings, projects);
    }
    if ($$self.$$.dirty & 1) {
      $: {
        $$invalidate(3, querying = (() => __awaiter(void 0, void 0, void 0, function* () {
          if ($dataSource) {
            dataFrame.set(yield $dataSource.queryAll());
          }
        }))());
      }
    }
  };
  return [
    $dataSource,
    projectId,
    viewId,
    querying,
    projects,
    $app,
    $api,
    $dataFrame,
    $settings,
    appcontainer_projectId_binding,
    appcontainer_viewId_binding
  ];
}
var App8 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, {});
  }
};
var App_default = App8;

// src/custom-view-api.ts
var ProjectView = class {
  onData(result) {
    return __async(this, null, function* () {
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
    });
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
};

// src/views/Gallery/GalleryView.svelte
var import_path = __toModule(require("path"));

// src/components/Field/Field.svelte
function add_css23(target) {
  append_styles(target, "svelte-uhe0sw", "div.svelte-uhe0sw{display:flex;align-items:center;justify-content:flex-end;gap:var(--spacing-md)}");
}
function create_default_slot14(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment46(ctx) {
  let div;
  let typography;
  let t3;
  let current;
  typography = new Typography_default({
    props: {
      variant: "label",
      nomargin: true,
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div = element("div");
      create_component(typography.$$.fragment);
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-uhe0sw");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(typography, div, null);
      append(div, t3);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography_changes = {};
      if (dirty & 5) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(typography);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [name, slots, $$scope];
}
var Field = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, { name: 0 }, add_css23);
  }
};
var Field_default = Field;

// src/components/HorizontalGroup/HorizontalGroup.svelte
function add_css24(target) {
  append_styles(target, "svelte-j9o14g", "div.svelte-j9o14g{display:flex;gap:8px}.padding.svelte-j9o14g{padding:8px}.fullWidth.svelte-j9o14g{width:100%;justify-content:space-between}");
}
function create_fragment47(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "style", div_style_value = `align-items: ${ctx[1]}`);
      attr(div, "class", "svelte-j9o14g");
      toggle_class(div, "padding", ctx[2]);
      toggle_class(div, "fullWidth", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 2 && div_style_value !== (div_style_value = `align-items: ${ctx2[1]}`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & 4) {
        toggle_class(div, "padding", ctx2[2]);
      }
      if (!current || dirty & 1) {
        toggle_class(div, "fullWidth", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { fullWidth = false } = $$props;
  let { alignItems = "center" } = $$props;
  let { padding = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fullWidth" in $$props2)
      $$invalidate(0, fullWidth = $$props2.fullWidth);
    if ("alignItems" in $$props2)
      $$invalidate(1, alignItems = $$props2.alignItems);
    if ("padding" in $$props2)
      $$invalidate(2, padding = $$props2.padding);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [fullWidth, alignItems, padding, $$scope, slots];
}
var HorizontalGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, { fullWidth: 0, alignItems: 1, padding: 2 }, add_css24);
  }
};
var HorizontalGroup_default = HorizontalGroup;

// src/components/ToolBar/ToolBar.svelte
function add_css25(target) {
  append_styles(target, "svelte-s13j7l", "div.svelte-s13j7l{display:flex;align-items:center;padding:var(--spacing-md);background-color:var(--background-secondary);border-bottom:1px solid var(--background-modifier-border);justify-content:space-between}");
}
function create_fragment48(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-s13j7l");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var ToolBar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, {}, add_css25);
  }
};
var ToolBar_default = ToolBar;

// src/modals/components/CenterBox.svelte
function add_css26(target) {
  append_styles(target, "svelte-8ezeao", "div.svelte-8ezeao{width:100%;height:100%;display:flex;align-items:center;justify-content:center;flex:1}");
}
function create_fragment49(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-8ezeao");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var CenterBox = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance49, create_fragment49, safe_not_equal, {}, add_css26);
  }
};
var CenterBox_default = CenterBox;

// src/modals/edit-note-modal.ts
var import_obsidian31 = __toModule(require("obsidian"));

// src/modals/input-dialog.ts
var import_obsidian29 = __toModule(require("obsidian"));

// src/modals/components/InputDialog.svelte
function add_css27(target) {
  append_styles(target, "svelte-gwqplq", "input.svelte-gwqplq{width:100%}");
}
function create_default_slot_46(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "svelte-gwqplq");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[7](input);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[8]),
          listen(input, "focus", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_36(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t3, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_27(ctx) {
  let t_value = ctx[6].t("modals.input.cancel") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[6].t("modals.input.cancel") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_17(ctx) {
  let button0;
  let t3;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_36] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", ctx[10]);
  button1 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", ctx[11]);
  return {
    c() {
      create_component(button0.$$.fragment);
      t3 = space();
      create_component(button1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert(target, t3, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & 4100) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4160) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(button1, detaching);
    }
  };
}
function create_default_slot15(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_46] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 4129) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 4189) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment50(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[1],
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 2)
        modallayout_changes.title = ctx2[1];
      if (dirty & 4221) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  let { value } = $$props;
  let { message } = $$props;
  let { cta } = $$props;
  let { onSubmit } = $$props;
  let { onCancel } = $$props;
  let ref;
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(5, ref);
    });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const focus_handler = () => ref.select();
  const click_handler = () => {
    onSubmit(value);
  };
  const click_handler_1 = () => {
    onCancel();
  };
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("cta" in $$props2)
      $$invalidate(2, cta = $$props2.cta);
    if ("onSubmit" in $$props2)
      $$invalidate(3, onSubmit = $$props2.onSubmit);
    if ("onCancel" in $$props2)
      $$invalidate(4, onCancel = $$props2.onCancel);
  };
  return [
    value,
    message,
    cta,
    onSubmit,
    onCancel,
    ref,
    $i18n,
    input_binding,
    input_input_handler,
    focus_handler,
    click_handler,
    click_handler_1
  ];
}
var InputDialog = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      value: 0,
      message: 1,
      cta: 2,
      onSubmit: 3,
      onCancel: 4
    }, add_css27);
  }
};
var InputDialog_default = InputDialog;

// src/modals/input-dialog.ts
var InputDialogModal = class extends import_obsidian29.Modal {
  constructor(app2, message, cta, onSubmit, value) {
    super(app2);
    this.message = message;
    this.cta = cta;
    this.onSubmit = onSubmit;
    this.value = value;
  }
  onOpen() {
    var _a;
    this.component = new InputDialog_default({
      target: this.contentEl,
      props: {
        message: this.message,
        cta: this.cta,
        value: (_a = this.value) != null ? _a : "",
        onSubmit: (value) => {
          this.onSubmit(value);
          this.close();
        },
        onCancel: () => {
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/components/TagList/TagList.svelte
function add_css28(target) {
  append_styles(target, "svelte-8h9y9", "div.svelte-8h9y9{display:flex;align-items:center;gap:4px;overflow:hidden;padding:4px}.edit.svelte-8h9y9{flex-wrap:wrap}");
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function get_each_context6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_else_block4(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value_1 = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block13(ctx) {
  let t3;
  let iconbutton;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block6(get_each_context6(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  iconbutton = new IconButton_default({ props: { icon: "plus", nopadding: true } });
  iconbutton.$on("click", ctx[5]);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t3, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot_18(ctx) {
  let t_value = ctx[6] + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[6] + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_1(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot_18] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & 2049) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_default_slot16(ctx) {
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let iconbutton;
  let current;
  function click_handler() {
    return ctx[4](ctx[8]);
  }
  iconbutton = new IconButton_default({
    props: {
      icon: "cross",
      size: "xs",
      nopadding: true
    }
  });
  iconbutton.$on("click", click_handler);
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[6] + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block6(ctx) {
  let tag;
  let current;
  tag = new Tag_default({
    props: {
      $$slots: { default: [create_default_slot16] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tag.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tag, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tag_changes = {};
      if (dirty & 2053) {
        tag_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tag, detaching);
    }
  };
}
function create_fragment51(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block13, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "svelte-8h9y9");
      toggle_class(div, "edit", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & 2) {
        toggle_class(div, "edit", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(3, $app = $$value));
  let { values } = $$props;
  let { edit } = $$props;
  let { onChange = () => {
  } } = $$props;
  const click_handler = (i2) => {
    onChange(values.filter((_24, j2) => i2 !== j2));
  };
  const click_handler_1 = () => {
    new InputDialogModal($app, "Add list item", "Add", (value) => {
      onChange([...values, value]);
    }).open();
  };
  $$self.$$set = ($$props2) => {
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
  };
  return [values, edit, onChange, $app, click_handler, click_handler_1];
}
var TagList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment51, safe_not_equal, { values: 0, edit: 1, onChange: 2 }, add_css28);
  }
};
var TagList_default = TagList;

// src/components/FieldControl/FieldControl.svelte
function create_if_block_5(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: isLink(ctx[1]) ? ctx[1].linkText : ""
    }
  });
  textinput.$on("input", ctx[8]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 2)
        textinput_changes.value = isLink(ctx2[1]) ? ctx2[1].linkText : "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      edit: true,
      values: (_a = ctx[1]) != null ? _a : [],
      onChange: ctx[2]
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & 2)
        taglist_changes.values = (_a2 = ctx2[1]) != null ? _a2 : [];
      if (dirty & 4)
        taglist_changes.onChange = ctx2[2];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_if_block_32(ctx) {
  let dateinput;
  let current;
  dateinput = new DateInput_default({
    props: {
      value: isDate(ctx[1]) ? ctx[1] : null
    }
  });
  dateinput.$on("change", ctx[7]);
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dateinput_changes = {};
      if (dirty & 2)
        dateinput_changes.value = isDate(ctx2[1]) ? ctx2[1] : null;
      dateinput.$set(dateinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let numberinput;
  let current;
  numberinput = new NumberInput_default({
    props: {
      value: isNumber(ctx[1]) ? ctx[1] : null
    }
  });
  numberinput.$on("input", ctx[6]);
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (dirty & 2)
        numberinput_changes.value = isNumber(ctx2[1]) ? ctx2[1] : null;
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_if_block_17(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      value: isString(ctx[1]) ? ctx[1] : "",
      readonly: ctx[3]
    }
  });
  textinput.$on("input", ctx[5]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 2)
        textinput_changes.value = isString(ctx2[1]) ? ctx2[1] : "";
      if (dirty & 8)
        textinput_changes.readonly = ctx2[3];
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_if_block14(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: isBoolean(ctx[1]) ? ctx[1] : false
    }
  });
  switch_1.$on("check", ctx[4]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 2)
        switch_1_changes.checked = isBoolean(ctx2[1]) ? ctx2[1] : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_fragment52(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block14,
    create_if_block_17,
    create_if_block_23,
    create_if_block_32,
    create_if_block_4,
    create_if_block_5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 3)
      show_if = null;
    if (ctx2[0] === DataFieldType.Boolean)
      return 0;
    if (ctx2[0] === DataFieldType.String)
      return 1;
    if (ctx2[0] === DataFieldType.Number)
      return 2;
    if (ctx2[0] === DataFieldType.Date)
      return 3;
    if (show_if == null)
      show_if = !!(ctx2[0] === DataFieldType.List && isOptionalList(ctx2[1]));
    if (show_if)
      return 4;
    if (ctx2[0] === DataFieldType.Link)
      return 5;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance52($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { value } = $$props;
  let { onChange } = $$props;
  let { readonly = false } = $$props;
  const check_handler = ({ detail }) => onChange(detail);
  const input_handler = ({ detail: value2 }) => onChange(value2);
  const input_handler_1 = ({ detail: value2 }) => onChange(value2 !== null ? value2 : void 0);
  const change_handler = ({ detail: value2 }) => onChange(value2);
  const input_handler_2 = ({ detail: val }) => {
    if (isLink(value)) {
      onChange(__spreadProps(__spreadValues({}, value), { linkText: val }));
    }
  };
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
  };
  return [
    type,
    value,
    onChange,
    readonly,
    check_handler,
    input_handler,
    input_handler_1,
    change_handler,
    input_handler_2
  ];
}
var FieldControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      type: 0,
      value: 1,
      onChange: 2,
      readonly: 3
    });
  }
};
var FieldControl_default = FieldControl;

// src/modals/components/EditNote.svelte
function get_each_context7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_if_block15(ctx) {
  let callout;
  let current;
  callout = new Callout_default({
    props: {
      title: ctx[3].t("modals.note.edit.no-editable-fields.title"),
      icon: "info",
      variant: "info",
      $$slots: { default: [create_default_slot_56] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(callout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(callout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const callout_changes = {};
      if (dirty & 8)
        callout_changes.title = ctx2[3].t("modals.note.edit.no-editable-fields.title");
      if (dirty & 1032) {
        callout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      callout.$set(callout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(callout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(callout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(callout, detaching);
    }
  };
}
function create_default_slot_56(ctx) {
  let t_value = ctx[3].t("modals.note.edit.no-editable-fields.message") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].t("modals.note.edit.no-editable-fields.message") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_47(ctx) {
  let fieldcontrol;
  let t3;
  let current;
  function func7(...args) {
    return ctx[5](ctx[7], ...args);
  }
  fieldcontrol = new FieldControl_default({
    props: {
      value: ctx[0].values[ctx[7].name],
      onChange: func7,
      type: ctx[7].type
    }
  });
  return {
    c() {
      create_component(fieldcontrol.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(fieldcontrol, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const fieldcontrol_changes = {};
      if (dirty & 5)
        fieldcontrol_changes.value = ctx[0].values[ctx[7].name];
      if (dirty & 5)
        fieldcontrol_changes.onChange = func7;
      if (dirty & 4)
        fieldcontrol_changes.type = ctx[7].type;
      fieldcontrol.$set(fieldcontrol_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldcontrol.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldcontrol.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldcontrol, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block7(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[7].name,
      $$slots: { default: [create_default_slot_47] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & 4)
        settingitem_changes.name = ctx2[7].name;
      if (dirty & 1029) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_37(ctx) {
  let t3;
  let each_1_anchor;
  let current;
  let if_block = !ctx[2].length && create_if_block15(ctx);
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block7(get_each_context7(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[2].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t3.parentNode, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 5) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_28(ctx) {
  let t_value = ctx[3].t("modals.note.edit.save") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].t("modals.note.edit.save") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_19(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "primary",
      $$slots: { default: [create_default_slot_28] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[6]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 1032) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot17(ctx) {
  let modalcontent;
  let t3;
  let modalbuttongroup;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_37] },
      $$scope: { ctx }
    }
  });
  modalbuttongroup = new ModalButtonGroup_default({
    props: {
      $$slots: { default: [create_default_slot_19] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
      t3 = space();
      create_component(modalbuttongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      insert(target, t3, anchor);
      mount_component(modalbuttongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 1037) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
      const modalbuttongroup_changes = {};
      if (dirty & 1035) {
        modalbuttongroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbuttongroup.$set(modalbuttongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      transition_in(modalbuttongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      transition_out(modalbuttongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
      if (detaching)
        detach(t3);
      destroy_component(modalbuttongroup, detaching);
    }
  };
}
function create_fragment53(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: ctx[3].t("modals.note.edit.title"),
      $$slots: { default: [create_default_slot17] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 8)
        modallayout_changes.title = ctx2[3].t("modals.note.edit.title");
      if (dirty & 1039) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let editableFields;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(3, $i18n = $$value));
  let { fields } = $$props;
  let { record } = $$props;
  let { onSave } = $$props;
  const func7 = (field, value) => {
    $$invalidate(0, record = immer_esm_default(record, (draft) => {
      draft.values[field.name] = value;
    }));
  };
  const click_handler = () => {
    onSave(record);
  };
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(4, fields = $$props2.fields);
    if ("record" in $$props2)
      $$invalidate(0, record = $$props2.record);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, editableFields = fields.filter((field) => !field.derived));
    }
  };
  return [record, onSave, editableFields, $i18n, fields, func7, click_handler];
}
var EditNote = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment53, safe_not_equal, { fields: 4, record: 0, onSave: 1 });
  }
};
var EditNote_default = EditNote;

// src/modals/edit-note-modal.ts
var EditNoteModal = class extends import_obsidian31.Modal {
  constructor(app2, fields, onSave, defaults2) {
    super(app2);
    this.fields = fields;
    this.onSave = onSave;
    this.defaults = defaults2;
  }
  onOpen() {
    this.component = new EditNote_default({
      target: this.contentEl,
      props: {
        record: this.defaults,
        fields: this.fields,
        onSave: (record) => {
          this.onSave(record);
          this.close();
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/helpers.ts
function fieldToSelectableValue(field) {
  return {
    label: field.name,
    value: field.name
  };
}

// src/views/Gallery/components/Card/Card.svelte
function add_css29(target) {
  append_styles(target, "svelte-xq218h", "div.svelte-xq218h{background-color:var(--background-secondary);border-radius:var(--radius-s);border:1px solid var(--background-modifier-border);padding:0;margin:0}div.svelte-xq218h:hover{border:1px solid var(--background-modifier-border-hover)}");
}
function create_fragment54(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-xq218h");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance54, create_fragment54, safe_not_equal, {}, add_css29);
  }
};
var Card_default2 = Card;

// src/views/Gallery/components/Card/CardContent.svelte
function add_css30(target) {
  append_styles(target, "svelte-1rhoaa0", "div.svelte-1rhoaa0{padding:8px}");
}
function create_fragment55(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1rhoaa0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var CardContent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance55, create_fragment55, safe_not_equal, {}, add_css30);
  }
};
var CardContent_default = CardContent;

// src/views/Gallery/components/Card/CardMedia.svelte
function add_css31(target) {
  append_styles(target, "svelte-1ur9trs", "div.svelte-1ur9trs{height:180px;border-top-left-radius:4px;border-top-right-radius:4px;display:flex;align-items:center;justify-content:center;border-bottom:1px solid var(--background-modifier-border)}");
}
function create_fragment56(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-1ur9trs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance56($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots, click_handler];
}
var CardMedia = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance56, create_fragment56, safe_not_equal, {}, add_css31);
  }
};
var CardMedia_default = CardMedia;

// src/views/Gallery/components/Grid/Grid.svelte
function add_css32(target) {
  append_styles(target, "svelte-29f12s", "div.svelte-29f12s{display:grid;gap:24px;grid-template-columns:repeat(auto-fill, minmax(300px, 1fr))}");
}
function create_fragment57(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-29f12s");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Grid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance57, create_fragment57, safe_not_equal, {}, add_css32);
  }
};
var Grid_default = Grid;

// src/views/Gallery/components/Image/Image.svelte
function add_css33(target) {
  append_styles(target, "svelte-ol6m5s", "img.svelte-ol6m5s{width:100%;height:100%;border-top-left-radius:4px;border-top-right-radius:4px}");
}
function create_fragment58(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "alt", ctx[0]);
      if (!src_url_equal(img.src, img_src_value = ctx[1]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-ol6m5s");
      set_style(img, "object-fit", ctx[2], false);
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(img, "alt", ctx2[0]);
      }
      if (dirty & 2 && !src_url_equal(img.src, img_src_value = ctx2[1])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & 4) {
        set_style(img, "object-fit", ctx2[2], false);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function instance58($$self, $$props, $$invalidate) {
  let { alt } = $$props;
  let { src } = $$props;
  let { fit } = $$props;
  $$self.$$set = ($$props2) => {
    if ("alt" in $$props2)
      $$invalidate(0, alt = $$props2.alt);
    if ("src" in $$props2)
      $$invalidate(1, src = $$props2.src);
    if ("fit" in $$props2)
      $$invalidate(2, fit = $$props2.fit);
  };
  return [alt, src, fit];
}
var Image = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance58, create_fragment58, safe_not_equal, { alt: 0, src: 1, fit: 2 }, add_css33);
  }
};
var Image_default = Image;

// src/views/Gallery/GalleryView.svelte
function add_css34(target) {
  append_styles(target, "svelte-kexq1g", "div.svelte-kexq1g{height:100%;padding:24px;overflow:auto}");
}
function get_each_context8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function get_context(ctx) {
  const constants_0 = ctx[5](ctx[17]);
  ctx[20] = constants_0;
}
function create_default_slot_92(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      allowEmpty: true,
      value: (_b = (_a = ctx[1]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[0].map(fieldToSelectableValue),
      placeholder: (_c = ctx[4].t("views.gallery.fields.none")) != null ? _c : ""
    }
  });
  select.$on("change", ctx[14]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & 2)
        select_changes.value = (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & 1)
        select_changes.options = ctx2[0].map(fieldToSelectableValue);
      if (dirty & 16)
        select_changes.placeholder = (_c2 = ctx2[4].t("views.gallery.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_82(ctx) {
  let field;
  let current;
  field = new Field_default({
    props: {
      name: ctx[4].t("views.gallery.fields.cover"),
      $$slots: { default: [create_default_slot_92] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 16)
        field_changes.name = ctx2[4].t("views.gallery.fields.cover");
      if (dirty & 2097171) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_default_slot_73(ctx) {
  let p2;
  let t3;
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_82] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      p2 = element("p");
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & 2097171) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_else_block_1(ctx) {
  let centerbox;
  let current;
  centerbox = new CenterBox_default({
    props: {
      $$slots: { default: [create_default_slot_57] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(centerbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(centerbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const centerbox_changes = {};
      if (dirty & 2097168) {
        centerbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      centerbox.$set(centerbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(centerbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(centerbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(centerbox, detaching);
    }
  };
}
function create_if_block16(ctx) {
  let div;
  let grid;
  let current;
  grid = new Grid_default({
    props: {
      $$slots: { default: [create_default_slot18] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(grid.$$.fragment);
      attr(div, "class", "svelte-kexq1g");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(grid, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const grid_changes = {};
      if (dirty & 2097164) {
        grid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid.$set(grid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(grid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(grid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(grid);
    }
  };
}
function create_default_slot_65(ctx) {
  let t_value = ctx[4].t("views.gallery.empty") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].t("views.gallery.empty") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_57(ctx) {
  let typography;
  let current;
  typography = new Typography_default({
    props: {
      variant: "h5",
      $$slots: { default: [create_default_slot_65] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(typography.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typography, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typography_changes = {};
      if (dirty & 2097168) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typography, detaching);
    }
  };
}
function create_else_block5(ctx) {
  let icon;
  let current;
  icon = new Icon_default({ props: { name: "image", size: "lg" } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_18(ctx) {
  let image;
  let current;
  image = new Image_default({
    props: {
      alt: "Title",
      src: ctx[20],
      fit: "cover"
    }
  });
  return {
    c() {
      create_component(image.$$.fragment);
    },
    m(target, anchor) {
      mount_component(image, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const image_changes = {};
      if (dirty & 4)
        image_changes.src = ctx2[20];
      image.$set(image_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(image, detaching);
    }
  };
}
function create_default_slot_48(ctx) {
  get_context(ctx);
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_18, create_else_block5];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[20])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      get_context(ctx2);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_38(ctx) {
  let t_value = ctx[6](ctx[17]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[6](ctx2[17]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_29(ctx) {
  let internallink;
  let current;
  function open_handler(...args) {
    return ctx[16](ctx[17], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[17].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_38] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 4)
        internallink_changes.linkText = ctx[17].id;
      if (dirty & 2097156) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
    }
  };
}
function create_default_slot_110(ctx) {
  let cardmedia;
  let t0;
  let cardcontent;
  let t1;
  let current;
  function click_handler(...args) {
    return ctx[15](ctx[17], ...args);
  }
  cardmedia = new CardMedia_default({
    props: {
      $$slots: { default: [create_default_slot_48] },
      $$scope: { ctx }
    }
  });
  cardmedia.$on("click", click_handler);
  cardcontent = new CardContent_default({
    props: {
      $$slots: { default: [create_default_slot_29] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(cardmedia.$$.fragment);
      t0 = space();
      create_component(cardcontent.$$.fragment);
      t1 = space();
    },
    m(target, anchor) {
      mount_component(cardmedia, target, anchor);
      insert(target, t0, anchor);
      mount_component(cardcontent, target, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const cardmedia_changes = {};
      if (dirty & 2097156) {
        cardmedia_changes.$$scope = { dirty, ctx };
      }
      cardmedia.$set(cardmedia_changes);
      const cardcontent_changes = {};
      if (dirty & 2097164) {
        cardcontent_changes.$$scope = { dirty, ctx };
      }
      cardcontent.$set(cardcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardmedia.$$.fragment, local);
      transition_in(cardcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardmedia.$$.fragment, local);
      transition_out(cardcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cardmedia, detaching);
      if (detaching)
        detach(t0);
      destroy_component(cardcontent, detaching);
      if (detaching)
        detach(t1);
    }
  };
}
function create_each_block8(ctx) {
  let card;
  let current;
  card = new Card_default2({
    props: {
      $$slots: { default: [create_default_slot_110] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const card_changes = {};
      if (dirty & 2097164) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot18(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block8(get_each_context8(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 364) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block8(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment59(ctx) {
  let toolbar;
  let t3;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot_73] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block16, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].length)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(toolbar.$$.fragment);
      t3 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      insert(target, t3, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const toolbar_changes = {};
      if (dirty & 2097171) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
      if (detaching)
        detach(t3);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance59($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let textFields;
  let coverField;
  let $app;
  let $i18n;
  component_subscribe($$self, app, ($$value) => $$invalidate(3, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(4, $i18n = $$value));
  let { frame } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  let { api: api2 } = $$props;
  function getCoverRealPath(record) {
    if (!coverField) {
      return null;
    }
    const coverPath = record.values[coverField.name];
    if (!coverPath || !isString(coverPath)) {
      return null;
    }
    if (coverPath.startsWith("http://") || coverPath.startsWith("https://")) {
      return coverPath;
    }
    const file = $app.metadataCache.getFirstLinkpathDest(coverPath, "");
    if (file) {
      if (["png", "jpg", "jpeg", "gif", "bmp", "svg"].includes(file.extension)) {
        return $app.vault.getResourcePath(file);
      }
    }
    return null;
  }
  function getDisplayName(record) {
    const basename = import_path.default.basename(record.id);
    return basename.slice(0, basename.lastIndexOf("."));
  }
  function handleCoverFieldChange(coverField2) {
    onConfigChange(Object.assign(Object.assign({}, config), { coverField: coverField2 }));
  }
  function handleRecordClick(record) {
    new EditNoteModal($app, fields, (record2) => api2.updateRecord(record2, fields), record).open();
  }
  const change_handler = ({ detail }) => handleCoverFieldChange(detail);
  const click_handler = (record, event) => {
    if (event.metaKey || event.ctrlKey) {
      $app.workspace.openLinkText(record.id, "", true);
    } else {
      handleRecordClick(record);
    }
  };
  const open_handler = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      handleRecordClick(record);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("frame" in $$props2)
      $$invalidate(9, frame = $$props2.frame);
    if ("config" in $$props2)
      $$invalidate(10, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(11, onConfigChange = $$props2.onConfigChange);
    if ("api" in $$props2)
      $$invalidate(12, api2 = $$props2.api);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(13, { fields, records } = frame, fields, ($$invalidate(2, records), $$invalidate(9, frame)));
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(0, textFields = fields.filter((field) => field.type === DataFieldType.String));
    }
    if ($$self.$$.dirty & 1025) {
      $:
        $$invalidate(1, coverField = textFields.find((field) => (config === null || config === void 0 ? void 0 : config.coverField) === field.name));
    }
  };
  return [
    textFields,
    coverField,
    records,
    $app,
    $i18n,
    getCoverRealPath,
    getDisplayName,
    handleCoverFieldChange,
    handleRecordClick,
    frame,
    config,
    onConfigChange,
    api2,
    fields,
    change_handler,
    click_handler,
    open_handler
  ];
}
var GalleryView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance59, create_fragment59, safe_not_equal, {
      frame: 9,
      config: 10,
      onConfigChange: 11,
      api: 12
    }, add_css34);
  }
};
var GalleryView_default = GalleryView;

// src/views/Gallery/gallery-view.ts
var GalleryView2 = class extends ProjectView {
  getViewType() {
    return "gallery";
  }
  getDisplayName() {
    return "Gallery";
  }
  getIcon() {
    return "layout-grid";
  }
  onData(result) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.view && this.props) {
        this.view = new GalleryView_default({
          target: this.props.contentEl,
          props: {
            frame: (_a = result.data) != null ? _a : { fields: [], records: [] },
            api: result.viewApi,
            project: result.project,
            readonly: result.readonly,
            config: this.props.config,
            onConfigChange: this.props.saveConfig
          }
        });
      } else {
        (_b = this.view) == null ? void 0 : _b.$set({
          frame: result.data,
          api: result.viewApi,
          project: result.project,
          readonly: result.readonly
        });
      }
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.props = props;
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/views/Calendar/CalendarView.svelte
var import_dayjs7 = __toModule(require_dayjs_min());

// src/views/Calendar/components/CalendarDay/CalendarDay.svelte
var import_path2 = __toModule(require("path"));
var import_obsidian33 = __toModule(require("obsidian"));

// src/views/Calendar/components/Table/Table.svelte
function add_css35(target) {
  append_styles(target, "svelte-dafndf", "table.svelte-dafndf{border-collapse:collapse;border-spacing:0;table-layout:fixed;overflow:auto}.grow.svelte-dafndf{height:100%}");
}
function create_fragment60(ctx) {
  let table;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      table = element("table");
      if (default_slot)
        default_slot.c();
      attr(table, "class", "svelte-dafndf");
      toggle_class(table, "grow", ctx[0]);
    },
    m(target, anchor) {
      insert(target, table, anchor);
      if (default_slot) {
        default_slot.m(table, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        toggle_class(table, "grow", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance60($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { grow = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("grow" in $$props2)
      $$invalidate(0, grow = $$props2.grow);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [grow, $$scope, slots];
}
var Table = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance60, create_fragment60, safe_not_equal, { grow: 0 }, add_css35);
  }
};
var Table_default = Table;

// src/views/Calendar/components/Table/TableBody.svelte
function create_fragment61(ctx) {
  let tbody;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tbody);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance61($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableBody = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance61, create_fragment61, safe_not_equal, {});
  }
};
var TableBody_default = TableBody;

// src/views/Calendar/components/Table/TableCell.svelte
function add_css36(target) {
  append_styles(target, "svelte-1u8ro2d", "td.svelte-1u8ro2d{vertical-align:top;box-sizing:border-box;padding:0;border:1px solid var(--background-modifier-border);height:calc(100% / 5)}td.svelte-1u8ro2d:first-of-type{border-left:1px solid var(--background-modifier-border)}td.svelte-1u8ro2d:last-of-type{border-right:1px solid var(--background-modifier-border)}");
}
function create_fragment62(ctx) {
  let td;
  let td_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      attr(td, "colspan", ctx[0]);
      attr(td, "style", td_style_value = `width: ${ctx[1]}`);
      attr(td, "class", "svelte-1u8ro2d");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(td, "dblclick", ctx[4]),
          listen(td, "mousedown", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(td, "colspan", ctx2[0]);
      }
      if (!current || dirty & 2 && td_style_value !== (td_style_value = `width: ${ctx2[1]}`)) {
        attr(td, "style", td_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance62($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { colspan = null } = $$props;
  let { width } = $$props;
  function dblclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("colspan" in $$props2)
      $$invalidate(0, colspan = $$props2.colspan);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [colspan, width, $$scope, slots, dblclick_handler, mousedown_handler];
}
var TableCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance62, create_fragment62, safe_not_equal, { colspan: 0, width: 1 }, add_css36);
  }
};
var TableCell_default = TableCell;

// src/views/Calendar/components/Table/TableColumnHeaderCell.svelte
function add_css37(target) {
  append_styles(target, "svelte-fwcz0t", "div.svelte-fwcz0t{display:flex;align-items:center;width:100%;justify-content:space-between;gap:1rem}th.svelte-fwcz0t{background:var(--background-secondary);border:1px solid var(--background-modifier-border);border-top:0;border-left:0;text-align:center;font-weight:500;min-width:100px;vertical-align:top;position:sticky !important;top:0;padding:0.3em}th.svelte-fwcz0t:first-child{min-width:5ch}.nopadding.svelte-fwcz0t{padding:0}");
}
function create_fragment63(ctx) {
  let th;
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      th = element("th");
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-fwcz0t");
      attr(th, "scope", "col");
      attr(th, "class", "svelte-fwcz0t");
      toggle_class(th, "nopadding", ctx[0]);
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(th, "mousedown", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[1], !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        toggle_class(th, "nopadding", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(th);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance63($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { nopadding = false } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("nopadding" in $$props2)
      $$invalidate(0, nopadding = $$props2.nopadding);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [nopadding, $$scope, slots, mousedown_handler];
}
var TableColumnHeaderCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance63, create_fragment63, safe_not_equal, { nopadding: 0 }, add_css37);
  }
};
var TableColumnHeaderCell_default = TableColumnHeaderCell;

// src/views/Calendar/components/Table/TableHead.svelte
function create_fragment64(ctx) {
  let thead;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(thead);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance64($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableHead = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance64, create_fragment64, safe_not_equal, {});
  }
};
var TableHead_default = TableHead;

// src/views/Calendar/components/Table/TableRow.svelte
function create_fragment65(ctx) {
  let tr;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance65($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TableRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance65, create_fragment65, safe_not_equal, {});
  }
};
var TableRow_default = TableRow;

// src/views/Calendar/components/CalendarDay/CalendarDate.svelte
var import_dayjs5 = __toModule(require_dayjs_min());
function add_css38(target) {
  append_styles(target, "svelte-vn6kio", "span.svelte-vn6kio{padding:0.2em 0.4em;border-radius:4px}.today.svelte-vn6kio{background:var(--interactive-accent);display:inline-block;color:var(--text-on-accent)}");
}
function create_fragment66(ctx) {
  let span;
  let t_value = ctx[0].date() + "";
  let t3;
  return {
    c() {
      span = element("span");
      t3 = text(t_value);
      attr(span, "class", "svelte-vn6kio");
      toggle_class(span, "today", ctx[1]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].date() + ""))
        set_data(t3, t_value);
      if (dirty & 2) {
        toggle_class(span, "today", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance66($$self, $$props, $$invalidate) {
  let today;
  let { date } = $$props;
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(1, today = date.startOf("day").isSame((0, import_dayjs5.default)().startOf("day")));
    }
  };
  return [date, today];
}
var CalendarDate = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance66, create_fragment66, safe_not_equal, { date: 0 }, add_css38);
  }
};
var CalendarDate_default = CalendarDate;

// src/views/Calendar/components/CalendarDay/CalendarEntry.svelte
function add_css39(target) {
  append_styles(target, "svelte-91gd83", "div.svelte-91gd83{border-radius:4px;border:1px solid var(--background-modifier-border);background-color:var(--background-secondary);padding:0.2em 0.4em;font-size:var(--font-ui-small);width:100%;display:grid;grid-template-columns:auto 1fr}div.svelte-91gd83:hover{border:1px solid var(--background-modifier-border-hover)}span.svelte-91gd83{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}");
}
function create_if_block_19(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox_default({ props: { checked: false } });
  checkbox.$on("check", ctx[7]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_if_block17(ctx) {
  let checkbox;
  let updating_checked;
  let current;
  function checkbox_checked_binding(value) {
    ctx[5](value);
  }
  let checkbox_props = {};
  if (ctx[0] !== void 0) {
    checkbox_props.checked = ctx[0];
  }
  checkbox = new Checkbox_default({ props: checkbox_props });
  binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
  checkbox.$on("check", ctx[6]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (!updating_checked && dirty & 1) {
        updating_checked = true;
        checkbox_changes.checked = ctx2[0];
        add_flush_callback(() => updating_checked = false);
      }
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_fragment67(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t3;
  let span;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block17, create_if_block_19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] !== void 0 && ctx2[0] !== null)
      return 0;
    if (ctx2[0] === null && ctx2[1])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(span, "class", "svelte-91gd83");
      attr(div, "class", "svelte-91gd83");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t3);
      append(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[4]),
          listen(div, "mouseenter", ctx[8]),
          listen(div, "mouseleave", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, t3);
        } else {
          if_block = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance67($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { checked = void 0 } = $$props;
  let hover = false;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function checkbox_checked_binding(value) {
    checked = value;
    $$invalidate(0, checked);
  }
  function check_handler(event) {
    bubble.call(this, $$self, event);
  }
  function check_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  const mouseenter_handler = () => $$invalidate(1, hover = true);
  const mouseleave_handler = () => $$invalidate(1, hover = false);
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [
    checked,
    hover,
    $$scope,
    slots,
    click_handler,
    checkbox_checked_binding,
    check_handler,
    check_handler_1,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var CalendarEntry = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance67, create_fragment67, safe_not_equal, { checked: 0 }, add_css39);
  }
};
var CalendarEntry_default = CalendarEntry;

// src/views/Calendar/components/CalendarDay/CalendarDay.svelte
function add_css40(target) {
  append_styles(target, "svelte-3iqnfr", "div.svelte-3iqnfr{padding:4px;height:100%;display:flex;flex-direction:column;gap:4px;align-items:start;overflow:scroll}.weekend.svelte-3iqnfr{background-color:var(--background-secondary)}");
}
function get_each_context9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_if_block18(ctx) {
  let calendarentry;
  let current;
  function check_handler(...args) {
    return ctx[10](ctx[14], ...args);
  }
  function click_handler() {
    return ctx[11](ctx[14]);
  }
  calendarentry = new CalendarEntry_default({
    props: {
      checked: ctx[2] !== void 0 ? asOptionalBoolean(ctx[14][1].values[ctx[2]]) : void 0,
      $$slots: { default: [create_default_slot_111] },
      $$scope: { ctx }
    }
  });
  calendarentry.$on("check", check_handler);
  calendarentry.$on("click", click_handler);
  return {
    c() {
      create_component(calendarentry.$$.fragment);
    },
    m(target, anchor) {
      mount_component(calendarentry, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const calendarentry_changes = {};
      if (dirty & 6)
        calendarentry_changes.checked = ctx[2] !== void 0 ? asOptionalBoolean(ctx[14][1].values[ctx[2]]) : void 0;
      if (dirty & 131210) {
        calendarentry_changes.$$scope = { dirty, ctx };
      }
      calendarentry.$set(calendarentry_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(calendarentry.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(calendarentry.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(calendarentry, detaching);
    }
  };
}
function create_default_slot_210(ctx) {
  let t_value = ctx[8](ctx[14][1]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[8](ctx2[14][1]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_111(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler(...args) {
    return ctx[9](ctx[14], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[14][1].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_210] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 2)
        internallink_changes.linkText = ctx[14][1].id;
      if (dirty & 131074) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block9(ctx) {
  let show_if = ctx[8](ctx[14][1]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block18(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = ctx2[8](ctx2[14][1]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot19(ctx) {
  let div;
  let calendardate;
  let t3;
  let current;
  calendardate = new CalendarDate_default({ props: { date: ctx[0] } });
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block9(get_each_context9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      create_component(calendardate.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "svelte-3iqnfr");
      toggle_class(div, "weekend", ctx[0].day() === 0 || ctx[0].day() === 6);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(calendardate, div, null);
      append(div, t3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const calendardate_changes = {};
      if (dirty & 1)
        calendardate_changes.date = ctx2[0];
      calendardate.$set(calendardate_changes);
      if (dirty & 430) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 1) {
        toggle_class(div, "weekend", ctx2[0].day() === 0 || ctx2[0].day() === 6);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(calendardate.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(calendardate.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(calendardate);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment68(ctx) {
  let tablecell;
  let current;
  tablecell = new TableCell_default({
    props: {
      width: "calc(100% / 7)",
      $$slots: { default: [create_default_slot19] },
      $$scope: { ctx }
    }
  });
  tablecell.$on("dblclick", ctx[12]);
  tablecell.$on("mousedown", ctx[13]);
  return {
    c() {
      create_component(tablecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablecell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const tablecell_changes = {};
      if (dirty & 131247) {
        tablecell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecell.$set(tablecell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablecell, detaching);
    }
  };
}
function asOptionalBoolean(value) {
  if (typeof value === "boolean") {
    return value;
  }
  return null;
}
function instance68($$self, $$props, $$invalidate) {
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(6, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(7, $app = $$value));
  let { date } = $$props;
  let { records } = $$props;
  let { checkField } = $$props;
  let { onEntryClick } = $$props;
  let { onEntryAdd } = $$props;
  let { onRecordUpdate } = $$props;
  function getDisplayName(record) {
    const basename = import_path2.default.basename(record.id);
    return basename.slice(0, basename.lastIndexOf("."));
  }
  const open_handler = (recordPair, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onEntryClick(recordPair[0]);
    }
  };
  const check_handler = (recordPair, { detail: checked }) => {
    if (checkField) {
      onRecordUpdate(__spreadProps(__spreadValues({}, recordPair[1]), {
        values: __spreadProps(__spreadValues({}, recordPair[1].values), {
          [checkField]: checked
        })
      }));
    }
  };
  const click_handler = (recordPair) => {
    onEntryClick(recordPair[0]);
  };
  const dblclick_handler = () => onEntryAdd();
  const mousedown_handler = (event) => {
    if (event.button === 2) {
      const menu = new import_obsidian33.Menu();
      menu.addItem((item) => {
        item.setTitle($i18n.t("views.calendar.new-note")).setIcon("file").onClick(onEntryAdd);
      });
      menu.showAtMouseEvent(event);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("records" in $$props2)
      $$invalidate(1, records = $$props2.records);
    if ("checkField" in $$props2)
      $$invalidate(2, checkField = $$props2.checkField);
    if ("onEntryClick" in $$props2)
      $$invalidate(3, onEntryClick = $$props2.onEntryClick);
    if ("onEntryAdd" in $$props2)
      $$invalidate(4, onEntryAdd = $$props2.onEntryAdd);
    if ("onRecordUpdate" in $$props2)
      $$invalidate(5, onRecordUpdate = $$props2.onRecordUpdate);
  };
  return [
    date,
    records,
    checkField,
    onEntryClick,
    onEntryAdd,
    onRecordUpdate,
    $i18n,
    $app,
    getDisplayName,
    open_handler,
    check_handler,
    click_handler,
    dblclick_handler,
    mousedown_handler
  ];
}
var CalendarDay = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance68, create_fragment68, safe_not_equal, {
      date: 0,
      records: 1,
      checkField: 2,
      onEntryClick: 3,
      onEntryAdd: 4,
      onRecordUpdate: 5
    }, add_css40);
  }
};
var CalendarDay_default = CalendarDay;

// src/views/Calendar/components/Navigation/Navigation.svelte
function add_css41(target) {
  append_styles(target, "svelte-1u5a4vj", "div.svelte-1u5a4vj{display:flex;gap:4px;align-items:center}");
}
function create_default_slot20(ctx) {
  let t_value = ctx[3].t("views.calendar.today") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].t("views.calendar.today") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment69(ctx) {
  let div;
  let iconbutton0;
  let t0;
  let button;
  let t1;
  let iconbutton1;
  let current;
  iconbutton0 = new IconButton_default({ props: { icon: "chevron-left" } });
  iconbutton0.$on("click", function() {
    if (is_function(ctx[1]))
      ctx[1].apply(this, arguments);
  });
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot20] },
      $$scope: { ctx }
    }
  });
  button.$on("click", function() {
    if (is_function(ctx[2]))
      ctx[2].apply(this, arguments);
  });
  iconbutton1 = new IconButton_default({ props: { icon: "chevron-right" } });
  iconbutton1.$on("click", function() {
    if (is_function(ctx[0]))
      ctx[0].apply(this, arguments);
  });
  return {
    c() {
      div = element("div");
      create_component(iconbutton0.$$.fragment);
      t0 = space();
      create_component(button.$$.fragment);
      t1 = space();
      create_component(iconbutton1.$$.fragment);
      attr(div, "class", "svelte-1u5a4vj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(iconbutton0, div, null);
      append(div, t0);
      mount_component(button, div, null);
      append(div, t1);
      mount_component(iconbutton1, div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & 24) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton0.$$.fragment, local);
      transition_in(button.$$.fragment, local);
      transition_in(iconbutton1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton0.$$.fragment, local);
      transition_out(button.$$.fragment, local);
      transition_out(iconbutton1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(iconbutton0);
      destroy_component(button);
      destroy_component(iconbutton1);
    }
  };
}
function instance69($$self, $$props, $$invalidate) {
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(3, $i18n = $$value));
  let { onNext } = $$props;
  let { onPrevious } = $$props;
  let { onToday } = $$props;
  $$self.$$set = ($$props2) => {
    if ("onNext" in $$props2)
      $$invalidate(0, onNext = $$props2.onNext);
    if ("onPrevious" in $$props2)
      $$invalidate(1, onPrevious = $$props2.onPrevious);
    if ("onToday" in $$props2)
      $$invalidate(2, onToday = $$props2.onToday);
  };
  return [onNext, onPrevious, onToday, $i18n];
}
var Navigation = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance69, create_fragment69, safe_not_equal, { onNext: 0, onPrevious: 1, onToday: 2 }, add_css41);
  }
};
var Navigation_default = Navigation;

// src/views/Calendar/calendar.ts
var import_dayjs6 = __toModule(require_dayjs_min());
function isCalendarInterval(value) {
  switch (value) {
    case "month":
    case "2weeks":
    case "week":
    case "3days":
    case "day":
      return true;
    default:
      return false;
  }
}
function addInterval(date, interval) {
  switch (interval) {
    case "month":
      return date.add(1, "month");
    case "2weeks":
      return date.add(2, "week");
    case "week":
      return date.add(1, "week");
    case "3days":
      return date.add(1, "day");
    case "day":
      return date.add(1, "day");
  }
}
function subtractInterval(date, interval) {
  switch (interval) {
    case "month":
      return date.subtract(1, "month");
    case "2weeks":
      return date.subtract(2, "week");
    case "week":
      return date.subtract(1, "week");
    case "3days":
      return date.subtract(1, "day");
    case "day":
      return date.subtract(1, "day");
  }
}
function groupRecordsByField(records, field) {
  const res = {};
  records.forEach((record, i2) => {
    var _a;
    const dateValue = record.values[field];
    const start2 = dateValue ? isDate(dateValue) ? (0, import_dayjs6.default)(dateValue) : null : null;
    if (start2) {
      const dateStr = start2.format("YYYY-MM-DD");
      if (!(dateStr in res)) {
        res[dateStr] = [];
      }
      (_a = res[dateStr]) == null ? void 0 : _a.push([i2, record]);
    }
  });
  return res;
}
function computeDateInterval(anchor, interval) {
  switch (interval) {
    case "month":
      return [
        anchor.startOf("month").startOf("isoWeek"),
        anchor.endOf("month").endOf("isoWeek")
      ];
    case "2weeks":
      return [
        anchor.startOf("isoWeek"),
        anchor.add(1, "week").endOf("isoWeek")
      ];
    case "week":
      return [anchor.startOf("isoWeek"), anchor.endOf("isoWeek")];
    case "3days":
      return [anchor, anchor.add(2, "days")];
    case "day":
      return [anchor, anchor];
  }
}
function generateTitle(dateInterval) {
  if (dateInterval[0].startOf("day").isSame(dateInterval[1].startOf("day"))) {
    return get_store_value(i18n).t("views.calendar.date", {
      value: dateInterval[0],
      formatParams: {
        value: { year: "numeric", month: "long", day: "numeric" }
      }
    });
  }
  return get_store_value(i18n).t("views.calendar.interval", {
    from: dateInterval[0],
    to: dateInterval[1],
    formatParams: {
      from: { month: "short", day: "numeric" },
      to: { month: "short", day: "numeric" }
    }
  });
}
function generateDates(dateInterval) {
  const dates = [];
  const numDays = dateInterval[1].diff(dateInterval[0], "days");
  for (let i2 = 0; i2 <= numDays; i2++) {
    dates.push(dateInterval[0].add(i2, "day"));
  }
  return dates;
}
function chunkDates(dates, chunks) {
  const chunkedDates = [];
  let rest = dates;
  while (rest.length) {
    const chunked = take(rest, chunks);
    chunkedDates.push(chunked);
    rest = rest.slice(chunked.length);
  }
  return chunkedDates;
}
function take(arr, num) {
  const buffer = [];
  for (let i2 = 0; i2 < num && i2 < arr.length; i2++) {
    const el = arr[i2];
    if (el) {
      buffer.push(el);
    }
  }
  return buffer;
}

// src/views/Calendar/CalendarView.svelte
function add_css42(target) {
  append_styles(target, "svelte-1frn4ka", "div.svelte-1frn4ka{display:flex;flex-direction:column;height:100%}div.svelte-1frn4ka:last-child{flex:2}");
}
function get_each_context10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i2];
  return child_ctx;
}
function get_each_context_12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i2];
  return child_ctx;
}
function create_default_slot_102(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[13]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8192)
        set_data(t3, ctx2[13]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_93(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[5]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[9].map(fieldToSelectableValue),
      placeholder: (_c = ctx[10].t("views.calendar.fields.none")) != null ? _c : ""
    }
  });
  select.$on("change", ctx[31]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & 32)
        select_changes.value = (_b2 = (_a2 = ctx2[5]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & 512)
        select_changes.options = ctx2[9].map(fieldToSelectableValue);
      if (dirty[0] & 1024)
        select_changes.placeholder = (_c2 = ctx2[10].t("views.calendar.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_83(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      allowEmpty: true,
      value: (_b = (_a = ctx[15]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[16].map(fieldToSelectableValue),
      placeholder: (_c = ctx[10].t("views.calendar.fields.none")) != null ? _c : ""
    }
  });
  select.$on("change", ctx[32]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty[0] & 32768)
        select_changes.value = (_b2 = (_a2 = ctx2[15]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty[0] & 65536)
        select_changes.options = ctx2[16].map(fieldToSelectableValue);
      if (dirty[0] & 1024)
        select_changes.placeholder = (_c2 = ctx2[10].t("views.calendar.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_74(ctx) {
  var _a, _b;
  let field0;
  let t0;
  let field1;
  let t1;
  let select;
  let current;
  field0 = new Field_default({
    props: {
      name: ctx[10].t("views.calendar.fields.date"),
      $$slots: { default: [create_default_slot_93] },
      $$scope: { ctx }
    }
  });
  field1 = new Field_default({
    props: {
      name: ctx[10].t("views.calendar.fields.check"),
      $$slots: { default: [create_default_slot_83] },
      $$scope: { ctx }
    }
  });
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[3]) == null ? void 0 : _a.interval) != null ? _b : "week",
      options: [
        {
          label: ctx[10].t("views.calendar.intervals.month", { count: 1 }),
          value: "month"
        },
        {
          label: ctx[10].t("views.calendar.intervals.weekWithCount", { count: 2 }),
          value: "2weeks"
        },
        {
          label: ctx[10].t("views.calendar.intervals.week", { count: 1 }),
          value: "week"
        },
        {
          label: ctx[10].t("views.calendar.intervals.dayWithCount", { count: 3 }),
          value: "3days"
        },
        {
          label: ctx[10].t("views.calendar.intervals.day", { count: 1 }),
          value: "day"
        }
      ]
    }
  });
  select.$on("change", ctx[33]);
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const field0_changes = {};
      if (dirty[0] & 1024)
        field0_changes.name = ctx2[10].t("views.calendar.fields.date");
      if (dirty[0] & 1568 | dirty[1] & 32768) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & 1024)
        field1_changes.name = ctx2[10].t("views.calendar.fields.check");
      if (dirty[0] & 99328 | dirty[1] & 32768) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const select_changes = {};
      if (dirty[0] & 8)
        select_changes.value = (_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.interval) != null ? _b2 : "week";
      if (dirty[0] & 1024)
        select_changes.options = [
          {
            label: ctx2[10].t("views.calendar.intervals.month", { count: 1 }),
            value: "month"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.weekWithCount", { count: 2 }),
            value: "2weeks"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.week", { count: 1 }),
            value: "week"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.dayWithCount", { count: 3 }),
            value: "3days"
          },
          {
            label: ctx2[10].t("views.calendar.intervals.day", { count: 1 }),
            value: "day"
          }
        ];
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_66(ctx) {
  let navigation;
  let t0;
  let typography;
  let t1;
  let horizontalgroup;
  let current;
  navigation = new Navigation_default({
    props: {
      onNext: ctx[28],
      onPrevious: ctx[29],
      onToday: ctx[30]
    }
  });
  typography = new Typography_default({
    props: {
      variant: "h2",
      nomargin: true,
      $$slots: { default: [create_default_slot_102] },
      $$scope: { ctx }
    }
  });
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_74] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(navigation.$$.fragment);
      t0 = space();
      create_component(typography.$$.fragment);
      t1 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(navigation, target, anchor);
      insert(target, t0, anchor);
      mount_component(typography, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const navigation_changes = {};
      if (dirty[0] & 144)
        navigation_changes.onNext = ctx2[28];
      if (dirty[0] & 144)
        navigation_changes.onPrevious = ctx2[29];
      if (dirty[0] & 16)
        navigation_changes.onToday = ctx2[30];
      navigation.$set(navigation_changes);
      const typography_changes = {};
      if (dirty[0] & 8192 | dirty[1] & 32768) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      const horizontalgroup_changes = {};
      if (dirty[0] & 99880 | dirty[1] & 32768) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigation.$$.fragment, local);
      transition_in(typography.$$.fragment, local);
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigation.$$.fragment, local);
      transition_out(typography.$$.fragment, local);
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(navigation, detaching);
      if (detaching)
        detach(t0);
      destroy_component(typography, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_default_slot_58(ctx) {
  let t_value = ctx[43] + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048 && t_value !== (t_value = ctx2[43] + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_2(ctx) {
  let tablecolumnheadercell;
  let current;
  tablecolumnheadercell = new TableColumnHeaderCell_default({
    props: {
      $$slots: { default: [create_default_slot_58] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablecolumnheadercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablecolumnheadercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablecolumnheadercell_changes = {};
      if (dirty[0] & 2048 | dirty[1] & 32768) {
        tablecolumnheadercell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecolumnheadercell.$set(tablecolumnheadercell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablecolumnheadercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablecolumnheadercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablecolumnheadercell, detaching);
    }
  };
}
function create_default_slot_49(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[11];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048) {
        each_value_2 = ctx2[11];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_39(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      $$slots: { default: [create_default_slot_49] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty[0] & 2048 | dirty[1] & 32768) {
        tablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablerow.$set(tablerow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  var _a;
  let calendarday;
  let current;
  function func_5() {
    return ctx[36](ctx[40]);
  }
  calendarday = new CalendarDay_default({
    props: {
      date: ctx[40],
      checkField: (_a = ctx[15]) == null ? void 0 : _a.name,
      onRecordUpdate: ctx[34],
      records: ctx[14][ctx[40].format("YYYY-MM-DD")] || [],
      onEntryClick: ctx[35],
      onEntryAdd: func_5
    }
  });
  return {
    c() {
      create_component(calendarday.$$.fragment);
    },
    m(target, anchor) {
      mount_component(calendarday, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const calendarday_changes = {};
      if (dirty[0] & 4096)
        calendarday_changes.date = ctx[40];
      if (dirty[0] & 32768)
        calendarday_changes.checkField = (_a2 = ctx[15]) == null ? void 0 : _a2.name;
      if (dirty[0] & 260)
        calendarday_changes.onRecordUpdate = ctx[34];
      if (dirty[0] & 20480)
        calendarday_changes.records = ctx[14][ctx[40].format("YYYY-MM-DD")] || [];
      if (dirty[0] & 324)
        calendarday_changes.onEntryClick = ctx[35];
      if (dirty[0] & 135207)
        calendarday_changes.onEntryAdd = func_5;
      calendarday.$set(calendarday_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(calendarday.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(calendarday.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(calendarday, detaching);
    }
  };
}
function create_default_slot_211(ctx) {
  let t3;
  let current;
  let each_value_1 = ctx[37];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_12(get_each_context_12(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t3, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 184679) {
        each_value_1 = ctx2[37];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_12(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t3.parentNode, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block10(ctx) {
  let tablerow;
  let current;
  tablerow = new TableRow_default({
    props: {
      $$slots: { default: [create_default_slot_211] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablerow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablerow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablerow_changes = {};
      if (dirty[0] & 184679 | dirty[1] & 32768) {
        tablerow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablerow.$set(tablerow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablerow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablerow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablerow, detaching);
    }
  };
}
function create_default_slot_112(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block10(get_each_context10(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 184679) {
        each_value = ctx2[12];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block10(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot21(ctx) {
  let tablehead;
  let t3;
  let tablebody;
  let current;
  tablehead = new TableHead_default({
    props: {
      $$slots: { default: [create_default_slot_39] },
      $$scope: { ctx }
    }
  });
  tablebody = new TableBody_default({
    props: {
      $$slots: { default: [create_default_slot_112] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablehead.$$.fragment);
      t3 = space();
      create_component(tablebody.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablehead, target, anchor);
      insert(target, t3, anchor);
      mount_component(tablebody, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablehead_changes = {};
      if (dirty[0] & 2048 | dirty[1] & 32768) {
        tablehead_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablehead.$set(tablehead_changes);
      const tablebody_changes = {};
      if (dirty[0] & 184679 | dirty[1] & 32768) {
        tablebody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablebody.$set(tablebody_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablehead.$$.fragment, local);
      transition_in(tablebody.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablehead.$$.fragment, local);
      transition_out(tablebody.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablehead, detaching);
      if (detaching)
        detach(t3);
      destroy_component(tablebody, detaching);
    }
  };
}
function create_fragment70(ctx) {
  let div;
  let toolbar;
  let t3;
  let table;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot_66] },
      $$scope: { ctx }
    }
  });
  table = new Table_default({
    props: {
      grow: true,
      $$slots: { default: [create_default_slot21] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t3 = space();
      create_component(table.$$.fragment);
      attr(div, "class", "svelte-1frn4ka");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(toolbar, div, null);
      append(div, t3);
      mount_component(table, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const toolbar_changes = {};
      if (dirty[0] & 108216 | dirty[1] & 32768) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      const table_changes = {};
      if (dirty[0] & 186727 | dirty[1] & 32768) {
        table_changes.$$scope = { dirty, ctx: ctx2 };
      }
      table.$set(table_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(toolbar);
      destroy_component(table);
    }
  };
}
function instance70($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let dateFields;
  let dateField;
  let booleanFields;
  let booleanField;
  let interval;
  let dateInterval;
  let groupedRecords;
  let title;
  let dates;
  let numColumns;
  let weeks;
  let weekDays;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(10, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(17, $app = $$value));
  var _a, _b;
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  let anchorDate = (0, import_dayjs7.default)();
  function handleIntervalChange(interval2) {
    if (isCalendarInterval(interval2)) {
      onConfigChange(Object.assign(Object.assign({}, config), { interval: interval2 }));
    }
  }
  function handleDateFieldChange(dateField2) {
    onConfigChange(Object.assign(Object.assign({}, config), { dateField: dateField2 }));
  }
  function handleCheckFieldChange(checkField) {
    onConfigChange(Object.assign(Object.assign({}, config), { checkField }));
  }
  const func7 = () => $$invalidate(4, anchorDate = addInterval(anchorDate, interval));
  const func_13 = () => $$invalidate(4, anchorDate = subtractInterval(anchorDate, interval));
  const func_2 = () => $$invalidate(4, anchorDate = (0, import_dayjs7.default)());
  const change_handler = ({ detail }) => handleDateFieldChange(detail);
  const change_handler_1 = ({ detail }) => handleCheckFieldChange(detail);
  const change_handler_2 = ({ detail }) => handleIntervalChange(detail);
  const func_3 = (record) => {
    api2.updateRecord(record, fields);
  };
  const func_4 = (id) => {
    new EditNoteModal(get_store_value(app), fields, (record) => {
      api2.updateRecord(record, fields);
    }, records[id]).open();
  };
  const func_5 = (date) => {
    if (dateField && !readonly) {
      new CreateNoteModal($app, project, (name, templatePath) => {
        if (dateField) {
          api2.addRecord(createDataRecord(name, project, { [dateField.name]: date.toDate() }), templatePath);
        }
      }).open();
    }
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(21, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(2, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(22, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2097152) {
      $:
        $$invalidate(8, { fields, records } = frame, fields, ($$invalidate(6, records), $$invalidate(21, frame)));
    }
    if ($$self.$$.dirty[0] & 256) {
      $:
        $$invalidate(9, dateFields = fields.filter((field) => field.type === DataFieldType.Date));
    }
    if ($$self.$$.dirty[0] & 8389128) {
      $:
        $$invalidate(5, dateField = $$invalidate(23, _a = dateFields.find((field) => (config === null || config === void 0 ? void 0 : config.dateField) === field.name)) !== null && _a !== void 0 ? _a : dateFields[0]);
    }
    if ($$self.$$.dirty[0] & 256) {
      $:
        $$invalidate(16, booleanFields = fields.filter((field) => field.type === DataFieldType.Boolean));
    }
    if ($$self.$$.dirty[0] & 264) {
      $:
        $$invalidate(15, booleanField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.checkField) === field.name));
    }
    if ($$self.$$.dirty[0] & 16777224) {
      $:
        $$invalidate(7, interval = $$invalidate(24, _b = config === null || config === void 0 ? void 0 : config.interval) !== null && _b !== void 0 ? _b : "week");
    }
    if ($$self.$$.dirty[0] & 144) {
      $:
        $$invalidate(27, dateInterval = computeDateInterval(anchorDate, interval));
    }
    if ($$self.$$.dirty[0] & 96) {
      $:
        $$invalidate(14, groupedRecords = dateField ? groupRecordsByField(records, dateField.name) : {});
    }
    if ($$self.$$.dirty[0] & 134217728) {
      $:
        $$invalidate(13, title = dateInterval ? generateTitle(dateInterval) : "");
    }
    if ($$self.$$.dirty[0] & 134217728) {
      $:
        $$invalidate(26, dates = dateInterval ? generateDates(dateInterval) : []);
    }
    if ($$self.$$.dirty[0] & 67108864) {
      $:
        $$invalidate(25, numColumns = Math.min(dates.length, 7));
    }
    if ($$self.$$.dirty[0] & 100663296) {
      $:
        $$invalidate(12, weeks = chunkDates(dates, numColumns));
    }
    if ($$self.$$.dirty[0] & 100664320) {
      $:
        $$invalidate(11, weekDays = dates.slice(0, numColumns).map((date) => $i18n.t("views.calendar.weekday", {
          value: date.toDate(),
          formatParams: { value: { weekday: "short" } }
        })));
    }
  };
  return [
    project,
    readonly,
    api2,
    config,
    anchorDate,
    dateField,
    records,
    interval,
    fields,
    dateFields,
    $i18n,
    weekDays,
    weeks,
    title,
    groupedRecords,
    booleanField,
    booleanFields,
    $app,
    handleIntervalChange,
    handleDateFieldChange,
    handleCheckFieldChange,
    frame,
    onConfigChange,
    _a,
    _b,
    numColumns,
    dates,
    dateInterval,
    func7,
    func_13,
    func_2,
    change_handler,
    change_handler_1,
    change_handler_2,
    func_3,
    func_4,
    func_5
  ];
}
var CalendarView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance70, create_fragment70, safe_not_equal, {
      project: 0,
      frame: 21,
      readonly: 1,
      api: 2,
      config: 3,
      onConfigChange: 22
    }, add_css42, [-1, -1]);
  }
};
var CalendarView_default = CalendarView;

// src/views/Calendar/calendar-view.ts
var CalendarView2 = class extends ProjectView {
  getViewType() {
    return "calendar";
  }
  getDisplayName() {
    return "Calendar";
  }
  getIcon() {
    return "calendar";
  }
  onData(result) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.view && this.props) {
        this.view = new CalendarView_default({
          target: this.props.contentEl,
          props: {
            frame: (_a = result.data) != null ? _a : { fields: [], records: [] },
            api: result.viewApi,
            project: result.project,
            readonly: result.readonly,
            config: this.props.config,
            onConfigChange: this.props.saveConfig
          }
        });
      } else {
        (_b = this.view) == null ? void 0 : _b.$set({
          frame: result.data,
          api: result.viewApi,
          project: result.project,
          readonly: result.readonly
        });
      }
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.props = props;
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/views/Board/board.ts
function unique(records, fieldName) {
  const keys = records.map((record) => record.values[fieldName]).map((value) => value && isString(value) ? value : null).filter(notEmpty);
  const set = new Set(keys);
  return [...set];
}
function groupRecordsByField2(records, fieldName) {
  var _a;
  const noStatus = get_store_value(i18n).t("views.board.no-status");
  if (!fieldName) {
    return { [noStatus]: records };
  }
  const keys = unique(records, fieldName);
  const res = {
    [noStatus]: []
  };
  for (const key of keys) {
    res[key] = [];
  }
  records.forEach((record) => {
    var _a2, _b;
    const value = record.values[fieldName];
    if (value && isString(value)) {
      (_a2 = res[value]) == null ? void 0 : _a2.push(record);
    } else {
      (_b = res[noStatus]) == null ? void 0 : _b.push(record);
    }
  });
  if (!((_a = res[noStatus]) == null ? void 0 : _a.length)) {
    delete res[noStatus];
  }
  return res;
}

// src/views/Board/settings/settings-modal.ts
var import_obsidian36 = __toModule(require("obsidian"));

// src/views/Board/settings/BoardSettings.svelte
function create_default_slot_212(ctx) {
  let numberinput;
  let updating_value;
  let current;
  function numberinput_value_binding(value) {
    ctx[3](value);
  }
  let numberinput_props = { placeholder: "270" };
  if (ctx[2] !== void 0) {
    numberinput_props.value = ctx[2];
  }
  numberinput = new NumberInput_default({ props: numberinput_props });
  binding_callbacks.push(() => bind(numberinput, "value", numberinput_value_binding));
  numberinput.$on("blur", ctx[4]);
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberinput_changes = {};
      if (!updating_value && dirty & 4) {
        updating_value = true;
        numberinput_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_default_slot_113(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Column width",
      description: "Width of each column in pixels.",
      $$slots: { default: [create_default_slot_212] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & 71) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot22(ctx) {
  let modalcontent;
  let current;
  modalcontent = new ModalContent_default({
    props: {
      $$slots: { default: [create_default_slot_113] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modalcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modalcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modalcontent_changes = {};
      if (dirty & 71) {
        modalcontent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcontent.$set(modalcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modalcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modalcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modalcontent, detaching);
    }
  };
}
function create_fragment71(ctx) {
  let modallayout;
  let current;
  modallayout = new ModalLayout_default({
    props: {
      title: "Board settings",
      $$slots: { default: [create_default_slot22] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modallayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modallayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modallayout_changes = {};
      if (dirty & 71) {
        modallayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modallayout.$set(modallayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modallayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modallayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modallayout, detaching);
    }
  };
}
function instance71($$self, $$props, $$invalidate) {
  var _a;
  let { config } = $$props;
  let { onSave } = $$props;
  let columnWidthValue = (_a = config.columnWidth) !== null && _a !== void 0 ? _a : null;
  function numberinput_value_binding(value) {
    columnWidthValue = value;
    $$invalidate(2, columnWidthValue);
  }
  const blur_handler = () => onSave(immer_esm_default(config, (draft) => {
    const _a2 = draft, { columnWidth } = _a2, rest = __objRest(_a2, ["columnWidth"]);
    if (!columnWidthValue) {
      return rest;
    }
    return __spreadProps(__spreadValues({}, rest), { columnWidth: columnWidthValue });
  }));
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
  };
  return [config, onSave, columnWidthValue, numberinput_value_binding, blur_handler];
}
var BoardSettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance71, create_fragment71, safe_not_equal, { config: 0, onSave: 1 });
  }
};
var BoardSettings_default = BoardSettings;

// src/views/Board/settings/settings-modal.ts
var BoardSettingsModal = class extends import_obsidian36.Modal {
  constructor(app2, config, onSave) {
    super(app2);
    this.config = config;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    this.component = new BoardSettings_default({
      target: contentEl,
      props: {
        config: this.config,
        onSave: (config) => {
          this.onSave(config);
        }
      }
    });
  }
  onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/views/Board/components/Board/BoardColumn.svelte
var import_path3 = __toModule(require("path"));

// src/views/Board/components/Card/Card.svelte
function add_css43(target) {
  append_styles(target, "svelte-aji0dr", "div.svelte-aji0dr{background-color:var(--background-primary);border-radius:var(--radius-s);border:1px solid var(--background-modifier-border);padding:var(--size-4-2)}div.svelte-aji0dr:hover{border:1px solid var(--background-modifier-border-hover)}");
}
function create_fragment72(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-aji0dr");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance72($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots, click_handler];
}
var Card2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance72, create_fragment72, safe_not_equal, {}, add_css43);
  }
};
var Card_default3 = Card2;

// src/views/Board/components/Card/CardList.svelte
function add_css44(target) {
  append_styles(target, "svelte-2czsfa", "div.svelte-2czsfa{display:flex;flex-direction:column;gap:var(--size-4-2)}");
}
function create_fragment73(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-2czsfa");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance73($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var CardList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance73, create_fragment73, safe_not_equal, {}, add_css44);
  }
};
var CardList_default = CardList;

// src/views/Board/components/Board/BoardColumn.svelte
function add_css45(target) {
  append_styles(target, "svelte-epk499", ".column.svelte-epk499{border:1px solid var(--background-modifier-border);border-radius:var(--radius-m);background-color:var(--background-secondary);display:flex;flex-direction:column}.column-section.svelte-epk499{padding:var(--size-4-2);display:flex;flex-direction:column}.unprio.svelte-epk499{border-top:1px solid var(--background-modifier-border)}p.svelte-epk499{font-weight:500;margin:0;margin-bottom:4px;color:var(--text-faint);font-size:var(--font-smaller)}");
}
function get_each_context_22(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function get_each_context11(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function get_each_context_13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  return child_ctx;
}
function create_default_slot_103(ctx) {
  let t3;
  return {
    c() {
      t3 = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_else_block6(ctx) {
  let div;
  let cardlist;
  let current;
  cardlist = new CardList_default({
    props: {
      $$slots: { default: [create_default_slot_75] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(cardlist.$$.fragment);
      attr(div, "class", "column-section svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(cardlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const cardlist_changes = {};
      if (dirty & 134218002) {
        cardlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardlist.$set(cardlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardlist);
    }
  };
}
function create_if_block_110(ctx) {
  let t3;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[7].length && create_if_block_33(ctx);
  let if_block1 = ctx[6].length && create_if_block_24(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7].length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_default_slot_94(ctx) {
  let t_value = ctx[10](ctx[20]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[10](ctx2[20]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_84(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler_2(...args) {
    return ctx[15](ctx[20], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[20].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_94] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler_2);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 2)
        internallink_changes.linkText = ctx[20].id;
      if (dirty & 134217730) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_22(ctx) {
  let card;
  let current;
  function click_handler_2() {
    return ctx[16](ctx[20]);
  }
  card = new Card_default3({
    props: {
      $$slots: { default: [create_default_slot_84] },
      $$scope: { ctx }
    }
  });
  card.$on("click", click_handler_2);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 134218002) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_75(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_22(get_each_context_22(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1298) {
        each_value_2 = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_22(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_33(ctx) {
  let div;
  let cardlist;
  let current;
  cardlist = new CardList_default({
    props: {
      $$slots: { default: [create_default_slot_410] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(cardlist.$$.fragment);
      attr(div, "class", "column-section svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(cardlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const cardlist_changes = {};
      if (dirty & 134218128) {
        cardlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardlist.$set(cardlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardlist);
    }
  };
}
function create_default_slot_67(ctx) {
  let t_value = ctx[10](ctx[20]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = ctx2[10](ctx2[20]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_59(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler(...args) {
    return ctx[11](ctx[20], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[20].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_67] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 128)
        internallink_changes.linkText = ctx[20].id;
      if (dirty & 134217856) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block_13(ctx) {
  let card;
  let current;
  function click_handler() {
    return ctx[12](ctx[20]);
  }
  card = new Card_default3({
    props: {
      $$slots: { default: [create_default_slot_59] },
      $$scope: { ctx }
    }
  });
  card.$on("click", click_handler);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 134218128) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_410(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[7];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_13(get_each_context_13(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1424) {
        each_value_1 = ctx2[7];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_13(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_24(ctx) {
  let div;
  let p2;
  let t0_value = ctx[9].t("views.board.unprioritized") + "";
  let t0;
  let t1;
  let cardlist;
  let current;
  cardlist = new CardList_default({
    props: {
      $$slots: { default: [create_default_slot_114] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      p2 = element("p");
      t0 = text(t0_value);
      t1 = space();
      create_component(cardlist.$$.fragment);
      attr(p2, "class", "svelte-epk499");
      attr(div, "class", "column-section unprio svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p2);
      append(p2, t0);
      append(div, t1);
      mount_component(cardlist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 512) && t0_value !== (t0_value = ctx2[9].t("views.board.unprioritized") + ""))
        set_data(t0, t0_value);
      const cardlist_changes = {};
      if (dirty & 134218064) {
        cardlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardlist.$set(cardlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(cardlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cardlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(cardlist);
    }
  };
}
function create_default_slot_310(ctx) {
  let t_value = ctx[10](ctx[20]) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = ctx2[10](ctx2[20]) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_default_slot_213(ctx) {
  let internallink;
  let t3;
  let current;
  function open_handler_1(...args) {
    return ctx[13](ctx[20], ...args);
  }
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[20].id,
      sourcePath: "",
      resolved: true,
      $$slots: { default: [create_default_slot_310] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", open_handler_1);
  return {
    c() {
      create_component(internallink.$$.fragment);
      t3 = space();
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      insert(target, t3, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const internallink_changes = {};
      if (dirty & 64)
        internallink_changes.linkText = ctx[20].id;
      if (dirty & 134217792) {
        internallink_changes.$$scope = { dirty, ctx };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
      if (detaching)
        detach(t3);
    }
  };
}
function create_each_block11(ctx) {
  let card;
  let current;
  function click_handler_1() {
    return ctx[14](ctx[20]);
  }
  card = new Card_default3({
    props: {
      $$slots: { default: [create_default_slot_213] },
      $$scope: { ctx }
    }
  });
  card.$on("click", click_handler_1);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 134218064) {
        card_changes.$$scope = { dirty, ctx };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_default_slot_114(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[6];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block11(get_each_context11(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1360) {
        each_value = ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block11(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block19(ctx) {
  let div;
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot23] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[17]);
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "class", "column-section svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 134218240) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(button);
    }
  };
}
function create_default_slot23(ctx) {
  let t_value = ctx[9].t("views.board.note.add") + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t_value !== (t_value = ctx2[9].t("views.board.note.add") + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment74(ctx) {
  let div1;
  let div0;
  let typography;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let current;
  typography = new Typography_default({
    props: {
      variant: "label",
      nomargin: true,
      $$slots: { default: [create_default_slot_103] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_110, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !ctx[3] && create_if_block19(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(typography.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "column-section svelte-epk499");
      attr(div1, "class", "column svelte-epk499");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(typography, div0, null);
      append(div1, t0);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const typography_changes = {};
      if (dirty & 134217729) {
        typography_changes.$$scope = { dirty, ctx: ctx2 };
      }
      typography.$set(typography_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div1, t1);
      }
      if (!ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block19(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typography.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(typography.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(typography);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance74($$self, $$props, $$invalidate) {
  let prioritized;
  let unprioritized;
  let $app;
  let $i18n;
  component_subscribe($$self, app, ($$value) => $$invalidate(8, $app = $$value));
  component_subscribe($$self, i18n, ($$value) => $$invalidate(9, $i18n = $$value));
  let { name } = $$props;
  let { records } = $$props;
  let { groupByPriority } = $$props;
  let { readonly } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordAdd } = $$props;
  function getPrioritizedRecords(records2) {
    return records2.filter((record) => {
      return groupByPriority && isNumber(record.values[groupByPriority]);
    });
  }
  function getUnprioritizedRecords(records2) {
    return records2.filter((record) => {
      return groupByPriority && !isNumber(record.values[groupByPriority]);
    });
  }
  function getDisplayName(record) {
    const basename = import_path3.default.basename(record.id);
    return basename.slice(0, basename.lastIndexOf("."));
  }
  const open_handler = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const click_handler = (record) => onRecordClick(record);
  const open_handler_1 = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const click_handler_1 = (record) => onRecordClick(record);
  const open_handler_2 = (record, { detail: { linkText, sourcePath, newLeaf } }) => {
    if (newLeaf) {
      $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
    } else {
      onRecordClick(record);
    }
  };
  const click_handler_2 = (record) => onRecordClick(record);
  const click_handler_3 = () => {
    onRecordAdd();
  };
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("records" in $$props2)
      $$invalidate(1, records = $$props2.records);
    if ("groupByPriority" in $$props2)
      $$invalidate(2, groupByPriority = $$props2.groupByPriority);
    if ("readonly" in $$props2)
      $$invalidate(3, readonly = $$props2.readonly);
    if ("onRecordClick" in $$props2)
      $$invalidate(4, onRecordClick = $$props2.onRecordClick);
    if ("onRecordAdd" in $$props2)
      $$invalidate(5, onRecordAdd = $$props2.onRecordAdd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(7, prioritized = getPrioritizedRecords(records));
    }
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(6, unprioritized = getUnprioritizedRecords(records));
    }
  };
  return [
    name,
    records,
    groupByPriority,
    readonly,
    onRecordClick,
    onRecordAdd,
    unprioritized,
    prioritized,
    $app,
    $i18n,
    getDisplayName,
    open_handler,
    click_handler,
    open_handler_1,
    click_handler_1,
    open_handler_2,
    click_handler_2,
    click_handler_3
  ];
}
var BoardColumn = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance74, create_fragment74, safe_not_equal, {
      name: 0,
      records: 1,
      groupByPriority: 2,
      readonly: 3,
      onRecordClick: 4,
      onRecordAdd: 5
    }, add_css45);
  }
};
var BoardColumn_default = BoardColumn;

// src/views/Board/components/Board/Board.svelte
function add_css46(target) {
  append_styles(target, "svelte-pei0r2", "div.svelte-pei0r2{display:grid;column-gap:8px;align-items:flex-start}");
}
function get_each_context12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_each_block12(key_1, ctx) {
  let first;
  let boardcolumn;
  let current;
  function func7() {
    return ctx[6](ctx[7]);
  }
  boardcolumn = new BoardColumn_default({
    props: {
      readonly: ctx[2],
      name: ctx[7].name,
      records: ctx[7].records,
      groupByPriority: ctx[1],
      onRecordClick: ctx[3],
      onRecordAdd: func7
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(boardcolumn.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(boardcolumn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const boardcolumn_changes = {};
      if (dirty & 4)
        boardcolumn_changes.readonly = ctx[2];
      if (dirty & 1)
        boardcolumn_changes.name = ctx[7].name;
      if (dirty & 1)
        boardcolumn_changes.records = ctx[7].records;
      if (dirty & 2)
        boardcolumn_changes.groupByPriority = ctx[1];
      if (dirty & 8)
        boardcolumn_changes.onRecordClick = ctx[3];
      if (dirty & 17)
        boardcolumn_changes.onRecordAdd = func7;
      boardcolumn.$set(boardcolumn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(boardcolumn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(boardcolumn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(boardcolumn, detaching);
    }
  };
}
function create_fragment75(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let div_style_value;
  let current;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[7].name;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context12(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block12(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "style", div_style_value = `grid-template-columns: repeat(${ctx[0].length}, ${ctx[5]}px);`);
      attr(div, "class", "svelte-pei0r2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 31) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block12, null, get_each_context12);
        check_outros();
      }
      if (!current || dirty & 33 && div_style_value !== (div_style_value = `grid-template-columns: repeat(${ctx2[0].length}, ${ctx2[5]}px);`)) {
        attr(div, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance75($$self, $$props, $$invalidate) {
  let { columns } = $$props;
  let { groupByPriority } = $$props;
  let { readonly } = $$props;
  let { onRecordClick } = $$props;
  let { onRecordAdd } = $$props;
  let { columnWidth } = $$props;
  const func7 = (column) => onRecordAdd(column.name);
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("groupByPriority" in $$props2)
      $$invalidate(1, groupByPriority = $$props2.groupByPriority);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("onRecordClick" in $$props2)
      $$invalidate(3, onRecordClick = $$props2.onRecordClick);
    if ("onRecordAdd" in $$props2)
      $$invalidate(4, onRecordAdd = $$props2.onRecordAdd);
    if ("columnWidth" in $$props2)
      $$invalidate(5, columnWidth = $$props2.columnWidth);
  };
  return [
    columns,
    groupByPriority,
    readonly,
    onRecordClick,
    onRecordAdd,
    columnWidth,
    func7
  ];
}
var Board = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      columns: 0,
      groupByPriority: 1,
      readonly: 2,
      onRecordClick: 3,
      onRecordAdd: 4,
      columnWidth: 5
    }, add_css46);
  }
};
var Board_default = Board;

// src/views/Board/BoardView.svelte
function add_css47(target) {
  append_styles(target, "svelte-17wav3a", "div.svelte-17wav3a{background-color:var(--background-primary);overflow:auto;padding:8px}");
}
function create_default_slot_311(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[3]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[8].map(fieldToSelectableValue),
      placeholder: (_c = ctx[9].t("views.board.fields.none")) != null ? _c : "",
      allowEmpty: true
    }
  });
  select.$on("change", ctx[18]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & 8)
        select_changes.value = (_b2 = (_a2 = ctx2[3]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & 256)
        select_changes.options = ctx2[8].map(fieldToSelectableValue);
      if (dirty & 512)
        select_changes.placeholder = (_c2 = ctx2[9].t("views.board.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_214(ctx) {
  var _a, _b, _c;
  let select;
  let current;
  select = new Select_default({
    props: {
      value: (_b = (_a = ctx[6]) == null ? void 0 : _a.name) != null ? _b : "",
      options: ctx[7].map(fieldToSelectableValue),
      placeholder: (_c = ctx[9].t("views.board.fields.none")) != null ? _c : "",
      allowEmpty: true
    }
  });
  select.$on("change", ctx[19]);
  return {
    c() {
      create_component(select.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const select_changes = {};
      if (dirty & 64)
        select_changes.value = (_b2 = (_a2 = ctx2[6]) == null ? void 0 : _a2.name) != null ? _b2 : "";
      if (dirty & 128)
        select_changes.options = ctx2[7].map(fieldToSelectableValue);
      if (dirty & 512)
        select_changes.placeholder = (_c2 = ctx2[9].t("views.board.fields.none")) != null ? _c2 : "";
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_115(ctx) {
  let field0;
  let t0;
  let field1;
  let t1;
  let iconbutton;
  let current;
  field0 = new Field_default({
    props: {
      name: ctx[9].t("views.board.fields.status"),
      $$slots: { default: [create_default_slot_311] },
      $$scope: { ctx }
    }
  });
  field1 = new Field_default({
    props: {
      name: ctx[9].t("views.board.fields.priority"),
      $$slots: { default: [create_default_slot_214] },
      $$scope: { ctx }
    }
  });
  iconbutton = new IconButton_default({ props: { icon: "settings" } });
  iconbutton.$on("click", ctx[20]);
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 512)
        field0_changes.name = ctx2[9].t("views.board.fields.status");
      if (dirty & 8389389) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 512)
        field1_changes.name = ctx2[9].t("views.board.fields.priority");
      if (dirty & 8389317) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_default_slot24(ctx) {
  let p2;
  let t3;
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_115] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      p2 = element("p");
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & 8390605) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_fragment76(ctx) {
  var _a, _b, _c;
  let toolbar;
  let t3;
  let div;
  let board;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot24] },
      $$scope: { ctx }
    }
  });
  board = new Board_default({
    props: {
      readonly: ctx[1],
      columns: ctx[5].sort(ctx[21]).map(ctx[22]),
      groupByPriority: (_a = ctx[6]) == null ? void 0 : _a.name,
      onRecordClick: ctx[11],
      onRecordAdd: ctx[12],
      columnWidth: (_c = (_b = ctx[0]) == null ? void 0 : _b.columnWidth) != null ? _c : 270
    }
  });
  return {
    c() {
      create_component(toolbar.$$.fragment);
      t3 = space();
      div = element("div");
      create_component(board.$$.fragment);
      attr(div, "class", "svelte-17wav3a");
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      mount_component(board, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2;
      const toolbar_changes = {};
      if (dirty & 8390605) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      const board_changes = {};
      if (dirty & 2)
        board_changes.readonly = ctx2[1];
      if (dirty & 560)
        board_changes.columns = ctx2[5].sort(ctx2[21]).map(ctx2[22]);
      if (dirty & 64)
        board_changes.groupByPriority = (_a2 = ctx2[6]) == null ? void 0 : _a2.name;
      if (dirty & 1)
        board_changes.columnWidth = (_c2 = (_b2 = ctx2[0]) == null ? void 0 : _b2.columnWidth) != null ? _c2 : 270;
      board.$set(board_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(board.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(board.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_component(board);
    }
  };
}
function instance76($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let textFields;
  let groupByField;
  let numberFields;
  let priorityField;
  let groupedRecords;
  let columns;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(9, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(10, $app = $$value));
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function handleRecordClick(record) {
    new EditNoteModal($app, fields, (record2) => api2.updateRecord(record2, fields), record).open();
  }
  function handleRecordAdd(column) {
    new CreateNoteModal($app, project, (name, templatePath) => {
      if (groupByField) {
        api2.addRecord(createDataRecord(name, project, groupByField ? {
          [groupByField.name]: column !== $i18n.t("views.board.no-status") ? column : void 0
        } : {}), templatePath);
      }
    }).open();
  }
  const change_handler = ({ detail: value }) => onConfigChange(__spreadProps(__spreadValues({}, config), { groupByField: value }));
  const change_handler_1 = ({ detail: value }) => {
    onConfigChange(__spreadProps(__spreadValues({}, config), { priorityField: value }));
  };
  const click_handler = () => {
    new BoardSettingsModal($app, config != null ? config : {}, (value) => {
      $$invalidate(0, config = value);
      onConfigChange(value);
    }).open();
  };
  const func7 = (a2, b2) => {
    if (a2 === $i18n.t("views.board.no-status"))
      return -1;
    if (b2 === $i18n.t("views.board.no-status"))
      return 1;
    if (a2 === $i18n.t("views.board.no-status") && a2 === b2)
      return 0;
    return a2.localeCompare(b2);
  };
  const func_13 = (column) => {
    var _a;
    return {
      id: column,
      name: column,
      records: (_a = groupedRecords[column]) != null ? _a : []
    };
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(13, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(14, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(15, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(2, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      $:
        $$invalidate(16, { fields, records } = frame, fields, ($$invalidate(17, records), $$invalidate(14, frame)));
    }
    if ($$self.$$.dirty & 65536) {
      $:
        $$invalidate(8, textFields = fields.filter((field) => field.type === DataFieldType.String));
    }
    if ($$self.$$.dirty & 65537) {
      $:
        $$invalidate(3, groupByField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.groupByField) === field.name));
    }
    if ($$self.$$.dirty & 65536) {
      $:
        $$invalidate(7, numberFields = fields.filter((field) => field.type === DataFieldType.Number));
    }
    if ($$self.$$.dirty & 65537) {
      $:
        $$invalidate(6, priorityField = fields.find((field) => (config === null || config === void 0 ? void 0 : config.priorityField) === field.name));
    }
    if ($$self.$$.dirty & 131080) {
      $:
        $$invalidate(4, groupedRecords = groupRecordsByField2(records, groupByField === null || groupByField === void 0 ? void 0 : groupByField.name));
    }
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(5, columns = Object.entries(groupedRecords).map((entry) => entry[0]));
    }
  };
  return [
    config,
    readonly,
    onConfigChange,
    groupByField,
    groupedRecords,
    columns,
    priorityField,
    numberFields,
    textFields,
    $i18n,
    $app,
    handleRecordClick,
    handleRecordAdd,
    project,
    frame,
    api2,
    fields,
    records,
    change_handler,
    change_handler_1,
    click_handler,
    func7,
    func_13
  ];
}
var BoardView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance76, create_fragment76, safe_not_equal, {
      project: 13,
      frame: 14,
      readonly: 1,
      api: 15,
      config: 0,
      onConfigChange: 2
    }, add_css47);
  }
};
var BoardView_default = BoardView;

// src/views/Board/board-view.ts
var BoardView2 = class extends ProjectView {
  getViewType() {
    return "board";
  }
  getDisplayName() {
    return "Board";
  }
  getIcon() {
    return "columns";
  }
  onData(result) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.view && this.props) {
        this.view = new BoardView_default({
          target: this.props.contentEl,
          props: {
            frame: (_a = result.data) != null ? _a : { fields: [], records: [] },
            api: result.viewApi,
            project: result.project,
            readonly: result.readonly,
            config: this.props.config,
            onConfigChange: this.props.saveConfig
          }
        });
      } else {
        (_b = this.view) == null ? void 0 : _b.$set({
          frame: result.data,
          api: result.viewApi,
          project: result.project,
          readonly: result.readonly
        });
      }
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.props = props;
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/views/Table/components/DataGrid/DataGrid.svelte
var import_obsidian45 = __toModule(require("obsidian"));

// src/views/Table/components/DataGrid/GridCell/Resizer.svelte
function add_css48(target) {
  append_styles(target, "svelte-ke01nl", ".handle.svelte-ke01nl{position:relative;left:7.5px;width:6px;min-width:6px;height:100%;border-radius:1px}.handle.svelte-ke01nl:hover{background-color:var(--interactive-accent);cursor:ew-resize}.visible.svelte-ke01nl{background-color:var(--interactive-accent);cursor:ew-resize}");
}
function create_else_block7(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "handle svelte-ke01nl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = listen(span, "mousedown", ctx[1]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block20(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "handle visible svelte-ke01nl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (!mounted) {
        dispose = listen(span, "mousedown", ctx[1]);
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment77(ctx) {
  let if_block_anchor;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block20;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(window, "mouseup", ctx[2]),
          listen(window, "mousemove", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance77($$self, $$props, $$invalidate) {
  let { width } = $$props;
  let { onChange } = $$props;
  let { onFinalize } = $$props;
  let { min: min2 } = $$props;
  let start2;
  let initial;
  function startResize(event) {
    $$invalidate(0, start2 = event.pageX);
    initial = width;
  }
  function stopResize(event) {
    if (start2 && initial) {
      const delta = event.pageX - start2;
      const newWidth = initial + delta;
      if (newWidth >= min2) {
        onFinalize(width);
      }
    }
    $$invalidate(0, start2 = null);
    initial = null;
  }
  function resize(event) {
    if (start2 && initial) {
      const delta = event.pageX - start2;
      const newWidth = initial + delta;
      if (newWidth >= min2) {
        onChange(newWidth);
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(4, width = $$props2.width);
    if ("onChange" in $$props2)
      $$invalidate(5, onChange = $$props2.onChange);
    if ("onFinalize" in $$props2)
      $$invalidate(6, onFinalize = $$props2.onFinalize);
    if ("min" in $$props2)
      $$invalidate(7, min2 = $$props2.min);
  };
  return [start2, startResize, stopResize, resize, width, onChange, onFinalize, min2];
}
var Resizer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance77, create_fragment77, safe_not_equal, {
      width: 4,
      onChange: 5,
      onFinalize: 6,
      min: 7
    }, add_css48);
  }
};
var Resizer_default = Resizer;

// src/views/Table/components/DataGrid/GridCell/GridCell.svelte
function add_css49(target) {
  append_styles(target, "svelte-njsjbi", "div.svelte-njsjbi{display:flex;flex-direction:row;align-items:center;justify-content:center;background-color:var(--background-primary);border-right:1px solid var(--background-modifier-border);border-left-color:var(--background-modifier-border);border-bottom:1px solid var(--background-modifier-border);box-sizing:border-box;vertical-align:middle;width:100%;min-height:30px}.selected.svelte-njsjbi{box-shadow:0 0 0 3px var(--interactive-accent);z-index:4;padding:0}.columnHeader.svelte-njsjbi{background-color:var(--background-secondary);font-weight:500;text-align:center;justify-content:space-between;padding:0 4px}.header.svelte-njsjbi{background-color:var(--background-secondary);position:sticky;left:60px}.rowHeader.svelte-njsjbi{left:0px;justify-content:center;z-index:5;background-color:var(--background-secondary);font-weight:500;text-align:center;padding:0 4px}");
}
var get_read_slot_changes_1 = (dirty) => ({});
var get_read_slot_context_1 = (ctx) => ({});
var get_hover_slot_changes = (dirty) => ({});
var get_hover_slot_context = (ctx) => ({});
var get_selected_slot_changes = (dirty) => ({});
var get_selected_slot_context = (ctx) => ({});
var get_read_slot_changes = (dirty) => ({});
var get_read_slot_context = (ctx) => ({});
var get_edit_slot_changes = (dirty) => ({});
var get_edit_slot_context = (ctx) => ({});
function create_else_block_12(ctx) {
  let current;
  const read_slot_template = ctx[23].read;
  const read_slot = create_slot(read_slot_template, ctx, ctx[22], get_read_slot_context_1);
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(read_slot, read_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(read_slot_template, ctx2[22], dirty, get_read_slot_changes_1), get_read_slot_context_1);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let current;
  const hover_slot_template = ctx[23].hover;
  const hover_slot = create_slot(hover_slot_template, ctx, ctx[22], get_hover_slot_context);
  return {
    c() {
      if (hover_slot)
        hover_slot.c();
    },
    m(target, anchor) {
      if (hover_slot) {
        hover_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (hover_slot) {
        if (hover_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(hover_slot, hover_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(hover_slot_template, ctx2[22], dirty, get_hover_slot_changes), get_hover_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hover_slot, local);
      current = true;
    },
    o(local) {
      transition_out(hover_slot, local);
      current = false;
    },
    d(detaching) {
      if (hover_slot)
        hover_slot.d(detaching);
    }
  };
}
function create_if_block_34(ctx) {
  let current;
  const selected_slot_template = ctx[23].selected;
  const selected_slot = create_slot(selected_slot_template, ctx, ctx[22], get_selected_slot_context);
  return {
    c() {
      if (selected_slot)
        selected_slot.c();
    },
    m(target, anchor) {
      if (selected_slot) {
        selected_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (selected_slot) {
        if (selected_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(selected_slot, selected_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(selected_slot_template, ctx2[22], dirty, get_selected_slot_changes), get_selected_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selected_slot, local);
      current = true;
    },
    o(local) {
      transition_out(selected_slot, local);
      current = false;
    },
    d(detaching) {
      if (selected_slot)
        selected_slot.d(detaching);
    }
  };
}
function create_if_block_111(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_25, create_else_block8];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[5].editable)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block8(ctx) {
  let current;
  const read_slot_template = ctx[23].read;
  const read_slot = create_slot(read_slot_template, ctx, ctx[22], get_read_slot_context);
  return {
    c() {
      if (read_slot)
        read_slot.c();
    },
    m(target, anchor) {
      if (read_slot) {
        read_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (read_slot) {
        if (read_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(read_slot, read_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(read_slot_template, ctx2[22], dirty, get_read_slot_changes), get_read_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(read_slot, local);
      current = true;
    },
    o(local) {
      transition_out(read_slot, local);
      current = false;
    },
    d(detaching) {
      if (read_slot)
        read_slot.d(detaching);
    }
  };
}
function create_if_block_25(ctx) {
  let current;
  const edit_slot_template = ctx[23].edit;
  const edit_slot = create_slot(edit_slot_template, ctx, ctx[22], get_edit_slot_context);
  return {
    c() {
      if (edit_slot)
        edit_slot.c();
    },
    m(target, anchor) {
      if (edit_slot) {
        edit_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (edit_slot) {
        if (edit_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(edit_slot, edit_slot_template, ctx2, ctx2[22], !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(edit_slot_template, ctx2[22], dirty, get_edit_slot_changes), get_edit_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(edit_slot, local);
      current = true;
    },
    o(local) {
      transition_out(edit_slot, local);
      current = false;
    },
    d(detaching) {
      if (edit_slot)
        edit_slot.d(detaching);
    }
  };
}
function create_if_block21(ctx) {
  var _a;
  let resizer;
  let current;
  resizer = new Resizer_default({
    props: {
      width: (_a = ctx[5].width) != null ? _a : 180,
      min: 100,
      onChange: ctx[3],
      onFinalize: ctx[4]
    }
  });
  return {
    c() {
      create_component(resizer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(resizer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const resizer_changes = {};
      if (dirty & 32)
        resizer_changes.width = (_a2 = ctx2[5].width) != null ? _a2 : 180;
      if (dirty & 8)
        resizer_changes.onChange = ctx2[3];
      if (dirty & 16)
        resizer_changes.onFinalize = ctx2[4];
      resizer.$set(resizer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(resizer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(resizer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(resizer, detaching);
    }
  };
}
function create_fragment78(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t3;
  let div_role_value;
  let div_aria_selected_value;
  let div_style_value;
  let div_tabindex_value;
  let useClickOutside_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_111, create_if_block_34, create_if_block_42, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[17].edit && ctx2[1])
      return 0;
    if (ctx2[17].selected && ctx2[0])
      return 1;
    if (ctx2[17].hover && ctx2[11])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block21(ctx);
  return {
    c() {
      div = element("div");
      if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "role", div_role_value = ctx[16]());
      attr(div, "aria-selected", div_aria_selected_value = ctx[8] || ctx[7] ? void 0 : ctx[0]);
      attr(div, "aria-colindex", ctx[6]);
      attr(div, "style", div_style_value = `width: ${ctx[5].width}px`);
      attr(div, "tabindex", div_tabindex_value = !ctx[7] && !ctx[8] ? 1 : void 0);
      attr(div, "class", "svelte-njsjbi");
      toggle_class(div, "columnHeader", ctx[7]);
      toggle_class(div, "header", ctx[5].header);
      toggle_class(div, "selected", ctx[0]);
      toggle_class(div, "rowHeader", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      ctx[25](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[12]),
          listen(div, "dblclick", ctx[13]),
          listen(div, "mousedown", ctx[24]),
          listen(div, "mouseenter", ctx[26]),
          listen(div, "mouseleave", ctx[27]),
          listen(div, "focus", ctx[28]),
          listen(div, "blur", ctx[15]),
          listen(div, "keydown", ctx[14]),
          action_destroyer(useClickOutside_action = useClickOutside2.call(null, div, ctx[29]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t3);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block21(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 385 && div_aria_selected_value !== (div_aria_selected_value = ctx2[8] || ctx2[7] ? void 0 : ctx2[0])) {
        attr(div, "aria-selected", div_aria_selected_value);
      }
      if (!current || dirty & 64) {
        attr(div, "aria-colindex", ctx2[6]);
      }
      if (!current || dirty & 32 && div_style_value !== (div_style_value = `width: ${ctx2[5].width}px`)) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & 384 && div_tabindex_value !== (div_tabindex_value = !ctx2[7] && !ctx2[8] ? 1 : void 0)) {
        attr(div, "tabindex", div_tabindex_value);
      }
      if (useClickOutside_action && is_function(useClickOutside_action.update) && dirty & 513)
        useClickOutside_action.update.call(null, ctx2[29]);
      if (!current || dirty & 128) {
        toggle_class(div, "columnHeader", ctx2[7]);
      }
      if (!current || dirty & 32) {
        toggle_class(div, "header", ctx2[5].header);
      }
      if (!current || dirty & 1) {
        toggle_class(div, "selected", ctx2[0]);
      }
      if (!current || dirty & 256) {
        toggle_class(div, "rowHeader", ctx2[8]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { edit = false } = $$props;
  let { resizable = false } = $$props;
  let { onResize = () => {
  } } = $$props;
  let { onFinalizeResize = () => {
  } } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { columnHeader = false } = $$props;
  let { rowHeader = false } = $$props;
  let { onEditChange = (value) => {
    $$invalidate(1, edit = value);
  } } = $$props;
  let { onCopy = () => {
  } } = $$props;
  let { onCut = () => {
  } } = $$props;
  let { onPaste = () => {
  } } = $$props;
  const dispatch = createEventDispatcher();
  let hover = false;
  let ref;
  function handleClick() {
    if (!column.header && !columnHeader && !rowHeader) {
      $$invalidate(0, selected = true);
    }
  }
  function handleDoubleClick() {
    if (!column.header && !columnHeader && !rowHeader) {
      onEditChange(true);
    }
  }
  function handleKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      switch (event.key) {
        case "c":
          onCopy();
          break;
        case "x":
          onCut();
          break;
        case "v":
          onPaste();
          break;
      }
    }
    switch (event.key) {
      case "Enter":
        if (edit) {
          onEditChange(false);
          ref.focus();
        } else {
          onEditChange(true);
        }
        break;
      case "Escape":
        onEditChange(false);
        ref.focus();
        break;
      case "ArrowLeft":
        dispatch("navigate", [colindex - 1, rowindex]);
        event.preventDefault();
        break;
      case "ArrowRight":
        dispatch("navigate", [colindex + 1, rowindex]);
        event.preventDefault();
        break;
      case "ArrowUp":
        dispatch("navigate", [colindex, rowindex - 1]);
        event.preventDefault();
        break;
      case "ArrowDown":
        dispatch("navigate", [colindex, rowindex + 1]);
        event.preventDefault();
        break;
      case "Tab":
        if (event.shiftKey) {
          dispatch("navigate", [colindex - 1, rowindex]);
        } else {
          dispatch("navigate", [colindex + 1, rowindex]);
        }
        event.preventDefault();
        break;
    }
  }
  function handleBlur(event) {
    $$invalidate(11, hover = false);
    if (event.currentTarget instanceof HTMLDivElement && event.relatedTarget instanceof HTMLElement && !event.currentTarget.contains(event.relatedTarget)) {
      $$invalidate(0, selected = false);
      onEditChange(false);
    }
  }
  function role() {
    if (columnHeader) {
      return "columnheader";
    } else if (rowHeader) {
      return "rowheader";
    } else {
      return "gridcell";
    }
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(10, ref);
    });
  }
  const mouseenter_handler = () => $$invalidate(11, hover = true);
  const mouseleave_handler = () => $$invalidate(11, hover = false);
  const focus_handler = () => {
    $$invalidate(11, hover = true);
    $$invalidate(0, selected = true);
  };
  const useClickOutside_function = () => {
    onEditChange(false);
    $$invalidate(0, selected = false);
  };
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("edit" in $$props2)
      $$invalidate(1, edit = $$props2.edit);
    if ("resizable" in $$props2)
      $$invalidate(2, resizable = $$props2.resizable);
    if ("onResize" in $$props2)
      $$invalidate(3, onResize = $$props2.onResize);
    if ("onFinalizeResize" in $$props2)
      $$invalidate(4, onFinalizeResize = $$props2.onFinalizeResize);
    if ("column" in $$props2)
      $$invalidate(5, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(18, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(6, colindex = $$props2.colindex);
    if ("columnHeader" in $$props2)
      $$invalidate(7, columnHeader = $$props2.columnHeader);
    if ("rowHeader" in $$props2)
      $$invalidate(8, rowHeader = $$props2.rowHeader);
    if ("onEditChange" in $$props2)
      $$invalidate(9, onEditChange = $$props2.onEditChange);
    if ("onCopy" in $$props2)
      $$invalidate(19, onCopy = $$props2.onCopy);
    if ("onCut" in $$props2)
      $$invalidate(20, onCut = $$props2.onCut);
    if ("onPaste" in $$props2)
      $$invalidate(21, onPaste = $$props2.onPaste);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1025) {
      $:
        if (selected && ref) {
          ref.focus();
          ref.scrollIntoView({ block: "nearest", inline: "nearest" });
        }
    }
  };
  return [
    selected,
    edit,
    resizable,
    onResize,
    onFinalizeResize,
    column,
    colindex,
    columnHeader,
    rowHeader,
    onEditChange,
    ref,
    hover,
    handleClick,
    handleDoubleClick,
    handleKeyDown,
    handleBlur,
    role,
    $$slots,
    rowindex,
    onCopy,
    onCut,
    onPaste,
    $$scope,
    slots,
    mousedown_handler,
    div_binding,
    mouseenter_handler,
    mouseleave_handler,
    focus_handler,
    useClickOutside_function
  ];
}
var GridCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance78, create_fragment78, safe_not_equal, {
      selected: 0,
      edit: 1,
      resizable: 2,
      onResize: 3,
      onFinalizeResize: 4,
      column: 5,
      rowindex: 18,
      colindex: 6,
      columnHeader: 7,
      rowHeader: 8,
      onEditChange: 9,
      onCopy: 19,
      onCut: 20,
      onPaste: 21
    }, add_css49);
  }
};
var GridCell_default = GridCell;

// src/views/Table/components/DataGrid/GridCell/GridBooleanCell/GridBooleanCell.svelte
function create_if_block22(ctx) {
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      checked: ctx[0],
      disabled: !ctx[2].editable
    }
  });
  switch_1.$on("check", ctx[7]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = ctx2[0];
      if (dirty & 4)
        switch_1_changes.disabled = !ctx2[2].editable;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_read_slot(ctx) {
  let show_if = isBoolean(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block22(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = isBoolean(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot(ctx) {
  var _a;
  let switch_1;
  let current;
  switch_1 = new Switch_default({
    props: {
      slot: "edit",
      checked: (_a = ctx[0]) != null ? _a : false
    }
  });
  switch_1.$on("check", ctx[6]);
  return {
    c() {
      create_component(switch_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switch_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const switch_1_changes = {};
      if (dirty & 1)
        switch_1_changes.checked = (_a2 = ctx2[0]) != null ? _a2 : false;
      switch_1.$set(switch_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switch_1, detaching);
    }
  };
}
function create_fragment79(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      column: ctx[2],
      $$slots: {
        edit: [create_edit_slot],
        read: [create_read_slot]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[8]);
  gridcell.$on("navigate", ctx[9]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 1031) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance79($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  const check_handler = ({ detail: checked }) => onChange(checked);
  const check_handler_1 = ({ detail: checked }) => onChange(checked);
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    check_handler,
    check_handler_1,
    mousedown_handler,
    navigate_handler
  ];
}
var GridBooleanCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance79, create_fragment79, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridBooleanCell_default = GridBooleanCell;

// src/views/Table/components/DataGrid/GridCell/GridDateCell/GridDateCell.svelte
function create_if_block23(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      value: ctx[0].toLocaleDateString()
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & 1)
        textlabel_changes.value = ctx2[0].toLocaleDateString();
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_read_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block23(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot2(ctx) {
  var _a;
  let dateinput;
  let current;
  dateinput = new DateInput_default({
    props: {
      value: (_a = ctx[0]) != null ? _a : null,
      embed: true
    }
  });
  dateinput.$on("change", ctx[7]);
  return {
    c() {
      create_component(dateinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dateinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const dateinput_changes = {};
      if (dirty & 1)
        dateinput_changes.value = (_a2 = ctx2[0]) != null ? _a2 : null;
      dateinput.$set(dateinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dateinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dateinput, detaching);
    }
  };
}
function create_fragment80(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      edit: ctx[6],
      onEditChange: ctx[8],
      column: ctx[2],
      onCopy: ctx[9],
      $$slots: {
        edit: [create_edit_slot2],
        read: [create_read_slot2]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[10]);
  gridcell.$on("navigate", ctx[11]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 64)
        gridcell_changes.edit = ctx2[6];
      if (dirty & 64)
        gridcell_changes.onEditChange = ctx2[8];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 1)
        gridcell_changes.onCopy = ctx2[9];
      if (dirty & 4163) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance80($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const change_handler = ({ detail: value2 }) => {
    $$invalidate(6, edit = false);
    onChange(value2);
  };
  const func7 = (mode) => {
    $$invalidate(6, edit = mode);
  };
  const func_13 = () => {
    if (value) {
      navigator.clipboard.writeText(value.toLocaleDateString());
    }
  };
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    edit,
    change_handler,
    func7,
    func_13,
    mousedown_handler,
    navigate_handler
  ];
}
var GridDateCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance80, create_fragment80, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridDateCell_default = GridDateCell;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/NumberLabel.svelte
function add_css50(target) {
  append_styles(target, "svelte-1636x3v", "div.svelte-1636x3v{width:100%;padding:6px;text-align:right}");
}
function create_fragment81(ctx) {
  let div;
  let t_value = new Intl.NumberFormat().format(ctx[0]) + "";
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(t_value);
      attr(div, "class", "svelte-1636x3v");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t_value !== (t_value = new Intl.NumberFormat().format(ctx2[0]) + ""))
        set_data(t3, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance81($$self, $$props, $$invalidate) {
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value];
}
var NumberLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance81, create_fragment81, safe_not_equal, { value: 0 }, add_css50);
  }
};
var NumberLabel_default = NumberLabel;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/NumberInput.svelte
function add_css51(target) {
  append_styles(target, "svelte-1uq2i75", "input.svelte-1uq2i75{all:unset;background-color:var(--background-primary);box-sizing:border-box;width:100%;padding:6px;font-weight:400;font-family:var(--font-default);color:var(--text-normal);text-align:right}input.svelte-1uq2i75:focus{box-shadow:none !important}input.svelte-1uq2i75:hover{background-color:transparent}");
}
function create_fragment82(ctx) {
  let input;
  let input_tabindex_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "tabindex", input_tabindex_value = -1);
      attr(input, "type", "number");
      input.value = ctx[0];
      attr(input, "class", "svelte-1uq2i75");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[6](input);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[2]),
          listen(input, "keypress", ctx[3]),
          listen(input, "blur", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[6](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance82($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let ref;
  function handleInput(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
      onChange(value);
    }
  }
  function handleKeyup(event) {
    if (event.currentTarget instanceof HTMLInputElement) {
      $$invalidate(0, value = event.currentTarget.valueAsNumber);
    }
  }
  onMount(() => {
    ref.focus();
  });
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(1, ref);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(4, onChange = $$props2.onChange);
  };
  return [value, ref, handleInput, handleKeyup, onChange, blur_handler, input_binding];
}
var NumberInput2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance82, create_fragment82, safe_not_equal, { value: 0, onChange: 4 }, add_css51);
  }
};
var NumberInput_default2 = NumberInput2;

// src/views/Table/components/DataGrid/GridCell/GridNumberCell/GridNumberCell.svelte
function create_if_block24(ctx) {
  let numberlabel;
  let current;
  numberlabel = new NumberLabel_default({ props: { value: ctx[1] } });
  return {
    c() {
      create_component(numberlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberlabel_changes = {};
      if (dirty & 2)
        numberlabel_changes.value = ctx2[1];
      numberlabel.$set(numberlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberlabel, detaching);
    }
  };
}
function create_read_slot3(ctx) {
  let show_if = isNumber(ctx[1]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block24(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = isNumber(ctx2[1]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_edit_slot3(ctx) {
  var _a;
  let numberinput;
  let current;
  numberinput = new NumberInput_default2({
    props: {
      slot: "edit",
      value: (_a = ctx[1]) != null ? _a : 0,
      onChange: ctx[7]
    }
  });
  numberinput.$on("blur", ctx[8]);
  return {
    c() {
      create_component(numberinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const numberinput_changes = {};
      if (dirty & 2)
        numberinput_changes.value = (_a2 = ctx2[1]) != null ? _a2 : 0;
      if (dirty & 4)
        numberinput_changes.onChange = ctx2[7];
      numberinput.$set(numberinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberinput, detaching);
    }
  };
}
function create_fragment83(ctx) {
  let gridcell;
  let updating_edit;
  let updating_selected;
  let current;
  function gridcell_edit_binding(value) {
    ctx[12](value);
  }
  function gridcell_selected_binding(value) {
    ctx[13](value);
  }
  let gridcell_props = {
    column: ctx[3],
    rowindex: ctx[4],
    colindex: ctx[5],
    onCopy: ctx[9],
    onCut: ctx[10],
    onPaste: ctx[11],
    $$slots: {
      edit: [create_edit_slot3],
      read: [create_read_slot3]
    },
    $$scope: { ctx }
  };
  if (ctx[6] !== void 0) {
    gridcell_props.edit = ctx[6];
  }
  if (ctx[0] !== void 0) {
    gridcell_props.selected = ctx[0];
  }
  gridcell = new GridCell_default({ props: gridcell_props });
  binding_callbacks.push(() => bind(gridcell, "edit", gridcell_edit_binding));
  binding_callbacks.push(() => bind(gridcell, "selected", gridcell_selected_binding));
  gridcell.$on("mousedown", ctx[14]);
  gridcell.$on("navigate", ctx[15]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 8)
        gridcell_changes.column = ctx2[3];
      if (dirty & 16)
        gridcell_changes.rowindex = ctx2[4];
      if (dirty & 32)
        gridcell_changes.colindex = ctx2[5];
      if (dirty & 2)
        gridcell_changes.onCopy = ctx2[9];
      if (dirty & 6)
        gridcell_changes.onCut = ctx2[10];
      if (dirty & 4)
        gridcell_changes.onPaste = ctx2[11];
      if (dirty & 65607) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_edit && dirty & 64) {
        updating_edit = true;
        gridcell_changes.edit = ctx2[6];
        add_flush_callback(() => updating_edit = false);
      }
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        gridcell_changes.selected = ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance83($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const func7 = (value2) => {
    onChange(value2);
  };
  const blur_handler = (event) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(0, selected = false);
      $$invalidate(6, edit = false);
    }
  };
  const func_13 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
  };
  const func_2 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
    onChange(void 0);
  };
  const func_3 = () => __async(this, null, function* () {
    onChange(parseFloat(yield navigator.clipboard.readText()));
  });
  function gridcell_edit_binding(value2) {
    edit = value2;
    $$invalidate(6, edit);
  }
  function gridcell_selected_binding(value2) {
    selected = value2;
    $$invalidate(0, selected);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(3, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(4, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(5, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  return [
    selected,
    value,
    onChange,
    column,
    rowindex,
    colindex,
    edit,
    func7,
    blur_handler,
    func_13,
    func_2,
    func_3,
    gridcell_edit_binding,
    gridcell_selected_binding,
    mousedown_handler,
    navigate_handler
  ];
}
var GridNumberCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      value: 1,
      onChange: 2,
      column: 3,
      rowindex: 4,
      colindex: 5,
      selected: 0
    });
  }
};
var GridNumberCell_default = GridNumberCell;

// src/views/Table/components/DataGrid/GridCell/GridTextCell/TextLabel.svelte
function add_css52(target) {
  append_styles(target, "svelte-q1s3im", "div.svelte-q1s3im{padding:6px;width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}");
}
function create_fragment84(ctx) {
  let div;
  let t3;
  return {
    c() {
      div = element("div");
      t3 = text(ctx[0]);
      attr(div, "class", "svelte-q1s3im");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t3, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance84($$self, $$props, $$invalidate) {
  let { value } = $$props;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value];
}
var TextLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance84, create_fragment84, safe_not_equal, { value: 0 }, add_css52);
  }
};
var TextLabel_default = TextLabel;

// src/views/Table/components/DataGrid/GridCell/GridTextCell/GridTextCell.svelte
function create_read_slot4(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      slot: "read",
      value: ctx[0] || ""
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & 1)
        textlabel_changes.value = ctx2[0] || "";
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_edit_slot4(ctx) {
  let textinput;
  let current;
  textinput = new TextInput_default({
    props: {
      autoFocus: true,
      slot: "edit",
      value: ctx[0] || "",
      embed: true,
      width: "100%"
    }
  });
  textinput.$on("input", ctx[7]);
  textinput.$on("blur", ctx[8]);
  return {
    c() {
      create_component(textinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textinput_changes = {};
      if (dirty & 1)
        textinput_changes.value = ctx2[0] || "";
      textinput.$set(textinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textinput, detaching);
    }
  };
}
function create_fragment85(ctx) {
  let gridcell;
  let updating_edit;
  let updating_selected;
  let current;
  function gridcell_edit_binding(value) {
    ctx[12](value);
  }
  function gridcell_selected_binding(value) {
    ctx[13](value);
  }
  let gridcell_props = {
    column: ctx[3],
    rowindex: ctx[4],
    colindex: ctx[5],
    onCopy: ctx[9],
    onCut: ctx[10],
    onPaste: ctx[11],
    $$slots: {
      edit: [create_edit_slot4],
      read: [create_read_slot4]
    },
    $$scope: { ctx }
  };
  if (ctx[6] !== void 0) {
    gridcell_props.edit = ctx[6];
  }
  if (ctx[1] !== void 0) {
    gridcell_props.selected = ctx[1];
  }
  gridcell = new GridCell_default({ props: gridcell_props });
  binding_callbacks.push(() => bind(gridcell, "edit", gridcell_edit_binding));
  binding_callbacks.push(() => bind(gridcell, "selected", gridcell_selected_binding));
  gridcell.$on("mousedown", ctx[14]);
  gridcell.$on("navigate", ctx[15]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 8)
        gridcell_changes.column = ctx2[3];
      if (dirty & 16)
        gridcell_changes.rowindex = ctx2[4];
      if (dirty & 32)
        gridcell_changes.colindex = ctx2[5];
      if (dirty & 1)
        gridcell_changes.onCopy = ctx2[9];
      if (dirty & 5)
        gridcell_changes.onCut = ctx2[10];
      if (dirty & 4)
        gridcell_changes.onPaste = ctx2[11];
      if (dirty & 65607) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_edit && dirty & 64) {
        updating_edit = true;
        gridcell_changes.edit = ctx2[6];
        add_flush_callback(() => updating_edit = false);
      }
      if (!updating_selected && dirty & 2) {
        updating_selected = true;
        gridcell_changes.selected = ctx2[1];
        add_flush_callback(() => updating_selected = false);
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance85($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  let edit = false;
  const input_handler = ({ detail }) => $$invalidate(0, value = detail);
  const blur_handler = (event) => {
    if (event.currentTarget instanceof HTMLInputElement && event.relatedTarget instanceof HTMLDivElement && !event.relatedTarget.contains(event.currentTarget)) {
      $$invalidate(1, selected = false);
      $$invalidate(6, edit = false);
    }
    onChange(value);
  };
  const func7 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
  };
  const func_13 = () => {
    var _a;
    navigator.clipboard.writeText((_a = value == null ? void 0 : value.toString()) != null ? _a : "");
    onChange(void 0);
  };
  const func_2 = () => __async(this, null, function* () {
    onChange(yield navigator.clipboard.readText());
  });
  function gridcell_edit_binding(value2) {
    edit = value2;
    $$invalidate(6, edit);
  }
  function gridcell_selected_binding(value2) {
    selected = value2;
    $$invalidate(1, selected);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(2, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(3, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(4, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(5, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(1, selected = $$props2.selected);
  };
  return [
    value,
    selected,
    onChange,
    column,
    rowindex,
    colindex,
    edit,
    input_handler,
    blur_handler,
    func7,
    func_13,
    func_2,
    gridcell_edit_binding,
    gridcell_selected_binding,
    mousedown_handler,
    navigate_handler
  ];
}
var GridTextCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance85, create_fragment85, safe_not_equal, {
      value: 0,
      onChange: 2,
      column: 3,
      rowindex: 4,
      colindex: 5,
      selected: 1
    });
  }
};
var GridTextCell_default = GridTextCell;

// src/views/Table/components/DataGrid/GridCell/GridLinkCell/GridLinkCell.svelte
var import_obsidian40 = __toModule(require("obsidian"));

// src/views/Table/components/DataGrid/GridCell/GridLinkCell/LinkLabel.svelte
function add_css53(target) {
  append_styles(target, "svelte-1ip22jj", "div.svelte-1ip22jj{padding:6px;width:100%}");
}
function create_if_block25(ctx) {
  let internallink;
  let current;
  internallink = new InternalLink_default({
    props: {
      linkText: ctx[0].linkText,
      sourcePath: ctx[0].sourcePath,
      resolved: !!ctx[1].metadataCache.getFirstLinkpathDest(ctx[0].linkText, ctx[0].sourcePath),
      $$slots: { default: [create_default_slot25] },
      $$scope: { ctx }
    }
  });
  internallink.$on("open", ctx[2]);
  return {
    c() {
      create_component(internallink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(internallink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const internallink_changes = {};
      if (dirty & 1)
        internallink_changes.linkText = ctx2[0].linkText;
      if (dirty & 1)
        internallink_changes.sourcePath = ctx2[0].sourcePath;
      if (dirty & 3)
        internallink_changes.resolved = !!ctx2[1].metadataCache.getFirstLinkpathDest(ctx2[0].linkText, ctx2[0].sourcePath);
      if (dirty & 9) {
        internallink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      internallink.$set(internallink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(internallink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(internallink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(internallink, detaching);
    }
  };
}
function create_default_slot25(ctx) {
  var _a;
  let t_value = ((_a = ctx[0].displayName) != null ? _a : ctx[0].linkText) + "";
  let t3;
  return {
    c() {
      t3 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t3, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 1 && t_value !== (t_value = ((_a2 = ctx2[0].displayName) != null ? _a2 : ctx2[0].linkText) + ""))
        set_data(t3, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t3);
    }
  };
}
function create_fragment86(ctx) {
  let div;
  let current;
  let if_block = ctx[0] && create_if_block25(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "svelte-1ip22jj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance86($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let { value } = $$props;
  const open_handler = ({ detail: { linkText, sourcePath, newLeaf } }) => {
    $app.workspace.openLinkText(linkText, sourcePath, newLeaf);
  };
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, $app, open_handler];
}
var LinkLabel = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance86, create_fragment86, safe_not_equal, { value: 0 }, add_css53);
  }
};
var LinkLabel_default = LinkLabel;

// src/views/Table/components/DataGrid/GridCell/GridLinkCell/GridLinkCell.svelte
function create_if_block_112(ctx) {
  let linklabel;
  let current;
  linklabel = new LinkLabel_default({ props: { value: ctx[0] } });
  return {
    c() {
      create_component(linklabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(linklabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const linklabel_changes = {};
      if (dirty & 1)
        linklabel_changes.value = ctx2[0];
      linklabel.$set(linklabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(linklabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(linklabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(linklabel, detaching);
    }
  };
}
function create_read_slot5(ctx) {
  let show_if = isOptionalLink(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_112(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = isOptionalLink(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_112(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block26(ctx) {
  var _a, _b;
  let fileautocomplete;
  let current;
  fileautocomplete = new FileAutocomplete_default({
    props: {
      files: getNotesInFolder(ctx[7].vault.getRoot()),
      value: (_b = (_a = ctx[0]) == null ? void 0 : _a.linkText) != null ? _b : "",
      embed: true,
      autoFocus: true,
      width: "100%",
      getLabel: ctx[9],
      getDescription: func_12
    }
  });
  fileautocomplete.$on("blur", ctx[10]);
  fileautocomplete.$on("change", ctx[11]);
  return {
    c() {
      create_component(fileautocomplete.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fileautocomplete, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const fileautocomplete_changes = {};
      if (dirty & 128)
        fileautocomplete_changes.files = getNotesInFolder(ctx2[7].vault.getRoot());
      if (dirty & 1)
        fileautocomplete_changes.value = (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.linkText) != null ? _b2 : "";
      fileautocomplete.$set(fileautocomplete_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fileautocomplete.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fileautocomplete.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fileautocomplete, detaching);
    }
  };
}
function create_edit_slot5(ctx) {
  let show_if = isOptionalLink(ctx[0]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block26(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = isOptionalLink(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment87(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      edit: ctx[6],
      onEditChange: ctx[12],
      column: ctx[2],
      $$slots: {
        edit: [create_edit_slot5],
        read: [create_read_slot5]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[13]);
  gridcell.$on("navigate", ctx[14]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 64)
        gridcell_changes.edit = ctx2[6];
      if (dirty & 64)
        gridcell_changes.onEditChange = ctx2[12];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 32963) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
var func_12 = (file) => file.path.split("/").slice(0, -1).join("/");
function instance87($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(7, $app = $$value));
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  const sourcePath = getContext("sourcePath");
  let edit = false;
  const func7 = (file) => file instanceof import_obsidian40.TFile ? file.basename : "";
  const blur_handler = () => {
    $$invalidate(6, edit = false);
  };
  const change_handler = ({ detail: linkText }) => {
    onChange(linkText ? { linkText, sourcePath } : void 0);
  };
  const func_2 = (value2) => $$invalidate(6, edit = value2);
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    edit,
    $app,
    sourcePath,
    func7,
    blur_handler,
    change_handler,
    func_2,
    mousedown_handler,
    navigate_handler
  ];
}
var GridLinkCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance87, create_fragment87, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridLinkCell_default = GridLinkCell;

// src/views/Table/components/DataGrid/GridCell/GridListCell/GridListCell.svelte
function create_read_slot6(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      slot: "read",
      edit: false,
      values: (_a = ctx[0]) != null ? _a : []
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & 1)
        taglist_changes.values = (_a2 = ctx2[0]) != null ? _a2 : [];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_edit_slot6(ctx) {
  var _a;
  let taglist;
  let current;
  taglist = new TagList_default({
    props: {
      slot: "edit",
      edit: true,
      values: (_a = ctx[0]) != null ? _a : [],
      onChange: ctx[1]
    }
  });
  return {
    c() {
      create_component(taglist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taglist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const taglist_changes = {};
      if (dirty & 1)
        taglist_changes.values = (_a2 = ctx2[0]) != null ? _a2 : [];
      if (dirty & 2)
        taglist_changes.onChange = ctx2[1];
      taglist.$set(taglist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taglist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taglist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taglist, detaching);
    }
  };
}
function create_fragment88(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      column: ctx[2],
      $$slots: {
        edit: [create_edit_slot6],
        read: [create_read_slot6]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[6]);
  gridcell.$on("navigate", ctx[7]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcell_changes = {};
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      if (dirty & 259) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function instance88($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    mousedown_handler,
    navigate_handler
  ];
}
var GridListCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridListCell_default = GridListCell;

// src/views/Table/components/DataGrid/GridCell/GridTypedCell.svelte
function create_else_block9(ctx) {
  let gridcell;
  let current;
  gridcell = new GridCell_default({
    props: {
      rowindex: ctx[3],
      selected: ctx[5],
      colindex: ctx[4],
      column: ctx[2]
    }
  });
  gridcell.$on("mousedown", ctx[18]);
  gridcell.$on("navigate", ctx[19]);
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridcell_changes = {};
      if (dirty & 8)
        gridcell_changes.rowindex = ctx2[3];
      if (dirty & 32)
        gridcell_changes.selected = ctx2[5];
      if (dirty & 16)
        gridcell_changes.colindex = ctx2[4];
      if (dirty & 4)
        gridcell_changes.column = ctx2[2];
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function create_if_block_52(ctx) {
  let gridlistcell;
  let current;
  gridlistcell = new GridListCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridlistcell.$on("mousedown", ctx[16]);
  gridlistcell.$on("navigate", ctx[17]);
  return {
    c() {
      create_component(gridlistcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridlistcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridlistcell_changes = {};
      if (dirty & 32)
        gridlistcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridlistcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridlistcell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridlistcell_changes.value = ctx2[0];
      if (dirty & 2)
        gridlistcell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridlistcell_changes.column = ctx2[2];
      gridlistcell.$set(gridlistcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridlistcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridlistcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridlistcell, detaching);
    }
  };
}
function create_if_block_43(ctx) {
  let gridlinkcell;
  let current;
  gridlinkcell = new GridLinkCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridlinkcell.$on("mousedown", ctx[14]);
  gridlinkcell.$on("navigate", ctx[15]);
  return {
    c() {
      create_component(gridlinkcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridlinkcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridlinkcell_changes = {};
      if (dirty & 32)
        gridlinkcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridlinkcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridlinkcell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridlinkcell_changes.value = ctx2[0];
      if (dirty & 2)
        gridlinkcell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridlinkcell_changes.column = ctx2[2];
      gridlinkcell.$set(gridlinkcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridlinkcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridlinkcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridlinkcell, detaching);
    }
  };
}
function create_if_block_35(ctx) {
  let griddatecell;
  let current;
  griddatecell = new GridDateCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  griddatecell.$on("mousedown", ctx[12]);
  griddatecell.$on("navigate", ctx[13]);
  return {
    c() {
      create_component(griddatecell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(griddatecell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const griddatecell_changes = {};
      if (dirty & 32)
        griddatecell_changes.selected = ctx2[5];
      if (dirty & 8)
        griddatecell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        griddatecell_changes.colindex = ctx2[4];
      if (dirty & 1)
        griddatecell_changes.value = ctx2[0];
      if (dirty & 2)
        griddatecell_changes.onChange = ctx2[1];
      if (dirty & 4)
        griddatecell_changes.column = ctx2[2];
      griddatecell.$set(griddatecell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(griddatecell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(griddatecell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(griddatecell, detaching);
    }
  };
}
function create_if_block_26(ctx) {
  let gridnumbercell;
  let current;
  gridnumbercell = new GridNumberCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridnumbercell.$on("mousedown", ctx[10]);
  gridnumbercell.$on("navigate", ctx[11]);
  return {
    c() {
      create_component(gridnumbercell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridnumbercell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridnumbercell_changes = {};
      if (dirty & 32)
        gridnumbercell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridnumbercell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridnumbercell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridnumbercell_changes.value = ctx2[0];
      if (dirty & 2)
        gridnumbercell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridnumbercell_changes.column = ctx2[2];
      gridnumbercell.$set(gridnumbercell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridnumbercell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridnumbercell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridnumbercell, detaching);
    }
  };
}
function create_if_block_113(ctx) {
  let gridbooleancell;
  let current;
  gridbooleancell = new GridBooleanCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridbooleancell.$on("mousedown", ctx[8]);
  gridbooleancell.$on("navigate", ctx[9]);
  return {
    c() {
      create_component(gridbooleancell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridbooleancell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridbooleancell_changes = {};
      if (dirty & 32)
        gridbooleancell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridbooleancell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridbooleancell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridbooleancell_changes.value = ctx2[0];
      if (dirty & 2)
        gridbooleancell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridbooleancell_changes.column = ctx2[2];
      gridbooleancell.$set(gridbooleancell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridbooleancell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridbooleancell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridbooleancell, detaching);
    }
  };
}
function create_if_block27(ctx) {
  let gridtextcell;
  let current;
  gridtextcell = new GridTextCell_default({
    props: {
      selected: ctx[5],
      rowindex: ctx[3],
      colindex: ctx[4],
      value: ctx[0],
      onChange: ctx[1],
      column: ctx[2]
    }
  });
  gridtextcell.$on("mousedown", ctx[6]);
  gridtextcell.$on("navigate", ctx[7]);
  return {
    c() {
      create_component(gridtextcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridtextcell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridtextcell_changes = {};
      if (dirty & 32)
        gridtextcell_changes.selected = ctx2[5];
      if (dirty & 8)
        gridtextcell_changes.rowindex = ctx2[3];
      if (dirty & 16)
        gridtextcell_changes.colindex = ctx2[4];
      if (dirty & 1)
        gridtextcell_changes.value = ctx2[0];
      if (dirty & 2)
        gridtextcell_changes.onChange = ctx2[1];
      if (dirty & 4)
        gridtextcell_changes.column = ctx2[2];
      gridtextcell.$set(gridtextcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridtextcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridtextcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridtextcell, detaching);
    }
  };
}
function create_fragment89(ctx) {
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let show_if_5;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block27,
    create_if_block_113,
    create_if_block_26,
    create_if_block_35,
    create_if_block_43,
    create_if_block_52,
    create_else_block9
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 5)
      show_if = null;
    if (dirty & 5)
      show_if_1 = null;
    if (dirty & 5)
      show_if_2 = null;
    if (dirty & 5)
      show_if_3 = null;
    if (dirty & 5)
      show_if_4 = null;
    if (dirty & 5)
      show_if_5 = null;
    if (show_if == null)
      show_if = !!(ctx2[2].type === "string" && isOptionalString(ctx2[0]));
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!(ctx2[2].type === "boolean" && isOptionalBoolean(ctx2[0]));
    if (show_if_1)
      return 1;
    if (show_if_2 == null)
      show_if_2 = !!(ctx2[2].type === "number" && isOptionalNumber(ctx2[0]));
    if (show_if_2)
      return 2;
    if (show_if_3 == null)
      show_if_3 = !!(ctx2[2].type === "date" && isOptionalDate(ctx2[0]));
    if (show_if_3)
      return 3;
    if (show_if_4 == null)
      show_if_4 = !!(ctx2[2].type === "link" && isOptionalLink(ctx2[0]));
    if (show_if_4)
      return 4;
    if (show_if_5 == null)
      show_if_5 = !!(ctx2[2].type === "list" && isOptionalList(ctx2[0]));
    if (show_if_5)
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance89($$self, $$props, $$invalidate) {
  let { value } = $$props;
  let { onChange } = $$props;
  let { column } = $$props;
  let { rowindex } = $$props;
  let { colindex } = $$props;
  let { selected } = $$props;
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function navigate_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("column" in $$props2)
      $$invalidate(2, column = $$props2.column);
    if ("rowindex" in $$props2)
      $$invalidate(3, rowindex = $$props2.rowindex);
    if ("colindex" in $$props2)
      $$invalidate(4, colindex = $$props2.colindex);
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
  };
  return [
    value,
    onChange,
    column,
    rowindex,
    colindex,
    selected,
    mousedown_handler,
    navigate_handler,
    mousedown_handler_1,
    navigate_handler_1,
    mousedown_handler_2,
    navigate_handler_2,
    mousedown_handler_3,
    navigate_handler_3,
    mousedown_handler_4,
    navigate_handler_4,
    mousedown_handler_5,
    navigate_handler_5,
    mousedown_handler_6,
    navigate_handler_6
  ];
}
var GridTypedCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance89, create_fragment89, safe_not_equal, {
      value: 0,
      onChange: 1,
      column: 2,
      rowindex: 3,
      colindex: 4,
      selected: 5
    });
  }
};
var GridTypedCell_default = GridTypedCell;

// src/views/Table/components/DataGrid/data-grid.ts
function fieldIcon(field) {
  switch (field) {
    case DataFieldType.String:
      return "text";
    case DataFieldType.Number:
      return "hash";
    case DataFieldType.Boolean:
      return "check";
    case DataFieldType.Date:
      return "calendar-days";
    case DataFieldType.Link:
      return "link";
    case DataFieldType.List:
      return "list";
  }
  return "alert-triangle";
}
function sortRows(rows, sortModel) {
  return rows.sort((a2, b2) => {
    let aval = a2.row[sortModel.field];
    let bval = b2.row[sortModel.field];
    const isAsc = sortModel.sort === "asc";
    if (!aval && bval)
      return isAsc ? 1 : -1;
    if (aval && !bval)
      return isAsc ? -1 : 1;
    if (!aval && !bval)
      return 0;
    if (isNumber(aval) && isNumber(bval)) {
      if (aval < bval) {
        return isAsc ? -1 : 1;
      } else if (aval > bval) {
        return isAsc ? 1 : -1;
      } else {
        return 0;
      }
    }
    aval = aval.toString().toLocaleLowerCase();
    bval = bval.toString().toLocaleLowerCase();
    if (aval < bval) {
      return isAsc ? -1 : 1;
    } else if (aval > bval) {
      return isAsc ? 1 : -1;
    } else {
      return 0;
    }
  });
}
function sortColumns(columns) {
  return columns.sort((a2, b2) => {
    var _a, _b;
    const left2 = (_a = a2.weight) != null ? _a : 9999;
    const right2 = (_b = b2.weight) != null ? _b : 9999;
    if (left2 < right2) {
      return -1;
    } else if (left2 > right2) {
      return 1;
    } else {
      return 0;
    }
  });
}
function menuOnContextMenu(event, menu) {
  const contextMenuFunc = (event2) => {
    window.removeEventListener("contextmenu", contextMenuFunc);
    event2.preventDefault();
    event2.stopPropagation();
    menu.showAtMouseEvent(event2);
  };
  window.addEventListener("contextmenu", contextMenuFunc, false);
}

// src/views/Table/components/DataGrid/GridCellGroup.svelte
function add_css54(target) {
  append_styles(target, "svelte-1jrmech", "div.svelte-1jrmech{display:flex}.header.svelte-1jrmech{position:sticky;top:0;z-index:10}");
}
function create_fragment90(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "role", "row");
      attr(div, "aria-rowindex", ctx[0]);
      attr(div, "class", "svelte-1jrmech");
      toggle_class(div, "header", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "mouseover", ctx[4]),
          listen(div, "focus", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[2], !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null), null);
        }
      }
      if (!current || dirty & 1) {
        attr(div, "aria-rowindex", ctx2[0]);
      }
      if (!current || dirty & 2) {
        toggle_class(div, "header", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance90($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { index: index2 } = $$props;
  let { header = false } = $$props;
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(0, index2 = $$props2.index);
    if ("header" in $$props2)
      $$invalidate(1, header = $$props2.header);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [index2, header, $$scope, slots, mouseover_handler, focus_handler];
}
var GridCellGroup = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance90, create_fragment90, safe_not_equal, { index: 0, header: 1 }, add_css54);
  }
};
var GridCellGroup_default = GridCellGroup;

// src/views/Table/components/DataGrid/GridHeader.svelte
function get_each_context13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  child_ctx[10] = i2;
  return child_ctx;
}
function create_read_slot7(ctx) {
  var _a, _b;
  let icon;
  let t0;
  let textlabel;
  let t1;
  let iconbutton;
  let t22;
  let current;
  icon = new Icon_default({
    props: {
      name: fieldIcon((_a = ctx[8].type) != null ? _a : DataFieldType.Unknown),
      tooltip: (_b = get_store_value(i18n).t(`data-types.${ctx[8].type}`)) != null ? _b : ""
    }
  });
  textlabel = new TextLabel_default({
    props: { value: ctx[8].field }
  });
  iconbutton = new IconButton_default({
    props: { size: "sm", icon: "vertical-three-dots" }
  });
  iconbutton.$on("click", function() {
    if (is_function(ctx[4](ctx[8])))
      ctx[4](ctx[8]).apply(this, arguments);
  });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      create_component(textlabel.$$.fragment);
      t1 = space();
      create_component(iconbutton.$$.fragment);
      t22 = space();
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      mount_component(textlabel, target, anchor);
      insert(target, t1, anchor);
      mount_component(iconbutton, target, anchor);
      insert(target, t22, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2, _b2;
      ctx = new_ctx;
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.name = fieldIcon((_a2 = ctx[8].type) != null ? _a2 : DataFieldType.Unknown);
      if (dirty & 1)
        icon_changes.tooltip = (_b2 = get_store_value(i18n).t(`data-types.${ctx[8].type}`)) != null ? _b2 : "";
      icon.$set(icon_changes);
      const textlabel_changes = {};
      if (dirty & 1)
        textlabel_changes.value = ctx[8].field;
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(textlabel.$$.fragment, local);
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(textlabel.$$.fragment, local);
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      destroy_component(textlabel, detaching);
      if (detaching)
        detach(t1);
      destroy_component(iconbutton, detaching);
      if (detaching)
        detach(t22);
    }
  };
}
function create_each_block13(ctx) {
  let gridcell;
  let current;
  function func7(...args) {
    return ctx[6](ctx[8], ...args);
  }
  function func_13(...args) {
    return ctx[7](ctx[8], ...args);
  }
  gridcell = new GridCell_default({
    props: {
      colindex: ctx[10] + 2,
      rowindex: 1,
      column: ctx[8],
      resizable: true,
      onResize: func7,
      onFinalizeResize: func_13,
      columnHeader: true,
      $$slots: { read: [create_read_slot7] },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", function() {
    if (is_function(ctx[3](ctx[8])))
      ctx[3](ctx[8]).apply(this, arguments);
  });
  return {
    c() {
      create_component(gridcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridcell_changes = {};
      if (dirty & 1)
        gridcell_changes.column = ctx[8];
      if (dirty & 3)
        gridcell_changes.onResize = func7;
      if (dirty & 5)
        gridcell_changes.onFinalizeResize = func_13;
      if (dirty & 2049) {
        gridcell_changes.$$scope = { dirty, ctx };
      }
      gridcell.$set(gridcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
    }
  };
}
function create_default_slot26(ctx) {
  let gridcell;
  let t3;
  let each_1_anchor;
  let current;
  gridcell = new GridCell_default({
    props: {
      colindex: 1,
      rowindex: 1,
      column: {
        field: "",
        width: 60,
        header: true,
        editable: false
      },
      columnHeader: true,
      rowHeader: true
    }
  });
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block13(get_each_context13(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(gridcell.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 31) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context13(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block13(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment91(ctx) {
  let gridcellgroup;
  let current;
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: 1,
      header: true,
      $$slots: { default: [create_default_slot26] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(gridcellgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcellgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcellgroup_changes = {};
      if (dirty & 2055) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcellgroup, detaching);
    }
  };
}
function instance91($$self, $$props, $$invalidate) {
  let { columns } = $$props;
  let { onResize } = $$props;
  let { onFinalizeResize } = $$props;
  let { onColumnMenu } = $$props;
  function handleColumnHeaderClick(column) {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onColumnMenu(column));
      }
    };
  }
  function handleFieldClick(column) {
    return (event) => {
      onColumnMenu(column).showAtMouseEvent(event);
    };
  }
  const func7 = (column, width) => {
    onResize(column.field, width);
  };
  const func_13 = (column, width) => {
    onFinalizeResize(column.field, width);
  };
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("onResize" in $$props2)
      $$invalidate(1, onResize = $$props2.onResize);
    if ("onFinalizeResize" in $$props2)
      $$invalidate(2, onFinalizeResize = $$props2.onFinalizeResize);
    if ("onColumnMenu" in $$props2)
      $$invalidate(5, onColumnMenu = $$props2.onColumnMenu);
  };
  return [
    columns,
    onResize,
    onFinalizeResize,
    handleColumnHeaderClick,
    handleFieldClick,
    onColumnMenu,
    func7,
    func_13
  ];
}
var GridHeader = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance91, create_fragment91, safe_not_equal, {
      columns: 0,
      onResize: 1,
      onFinalizeResize: 2,
      onColumnMenu: 5
    });
  }
};
var GridHeader_default = GridHeader;

// src/views/Table/components/DataGrid/GridRow.svelte
var import_obsidian43 = __toModule(require("obsidian"));
function get_each_context14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  child_ctx[17] = i2;
  return child_ctx;
}
function create_read_slot8(ctx) {
  let textlabel;
  let current;
  textlabel = new TextLabel_default({
    props: {
      slot: "read",
      value: (ctx[1] - 1).toString()
    }
  });
  return {
    c() {
      create_component(textlabel.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textlabel, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textlabel_changes = {};
      if (dirty & 2)
        textlabel_changes.value = (ctx2[1] - 1).toString();
      textlabel.$set(textlabel_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textlabel.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textlabel.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textlabel, detaching);
    }
  };
}
function create_hover_slot(ctx) {
  let iconbutton;
  let current;
  iconbutton = new IconButton_default({
    props: { slot: "hover", icon: "link", size: "sm" }
  });
  iconbutton.$on("click", function() {
    if (is_function(ctx[6]))
      ctx[6].apply(this, arguments);
  });
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block14(ctx) {
  let gridtypedcell;
  let current;
  function func7(...args) {
    return ctx[12](ctx[15], ...args);
  }
  gridtypedcell = new GridTypedCell_default({
    props: {
      selected: ctx[4][0] === ctx[17] + 2 && ctx[4][1] === ctx[1] + 2,
      rowindex: ctx[1] + 2,
      colindex: ctx[17] + 2,
      value: ctx[2][ctx[15].field],
      column: ctx[15],
      onChange: func7
    }
  });
  gridtypedcell.$on("mousedown", function() {
    if (is_function(ctx[8](ctx[15], ctx[2][ctx[15].field])))
      ctx[8](ctx[15], ctx[2][ctx[15].field]).apply(this, arguments);
  });
  gridtypedcell.$on("navigate", ctx[13]);
  return {
    c() {
      create_component(gridtypedcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridtypedcell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridtypedcell_changes = {};
      if (dirty & 18)
        gridtypedcell_changes.selected = ctx[4][0] === ctx[17] + 2 && ctx[4][1] === ctx[1] + 2;
      if (dirty & 2)
        gridtypedcell_changes.rowindex = ctx[1] + 2;
      if (dirty & 12)
        gridtypedcell_changes.value = ctx[2][ctx[15].field];
      if (dirty & 8)
        gridtypedcell_changes.column = ctx[15];
      if (dirty & 45)
        gridtypedcell_changes.onChange = func7;
      gridtypedcell.$set(gridtypedcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridtypedcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridtypedcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridtypedcell, detaching);
    }
  };
}
function create_default_slot27(ctx) {
  let gridcell;
  let t3;
  let each_1_anchor;
  let current;
  gridcell = new GridCell_default({
    props: {
      rowindex: 1,
      colindex: 1,
      column: {
        field: "",
        header: true,
        width: 60,
        editable: false
      },
      rowHeader: true,
      $$slots: {
        hover: [create_hover_slot],
        read: [create_read_slot8]
      },
      $$scope: { ctx }
    }
  });
  gridcell.$on("mousedown", ctx[7]());
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block14(get_each_context14(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      create_component(gridcell.$$.fragment);
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(gridcell, target, anchor);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridcell_changes = {};
      if (dirty & 262210) {
        gridcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcell.$set(gridcell_changes);
      if (dirty & 319) {
        each_value = ctx2[3];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context14(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block14(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcell.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(gridcell.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(gridcell, detaching);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment92(ctx) {
  let gridcellgroup;
  let current;
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: ctx[1],
      $$slots: { default: [create_default_slot27] },
      $$scope: { ctx }
    }
  });
  gridcellgroup.$on("mouseover", ctx[9]);
  return {
    c() {
      create_component(gridcellgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcellgroup, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcellgroup_changes = {};
      if (dirty & 2)
        gridcellgroup_changes.index = ctx2[1];
      if (dirty & 262271) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridcellgroup, detaching);
    }
  };
}
function instance92($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(14, $app = $$value));
  let { rowId } = $$props;
  let { index: index2 } = $$props;
  let { row } = $$props;
  let { columns } = $$props;
  let { activeCell } = $$props;
  setContext("sourcePath", row["path"]);
  let { onRowChange } = $$props;
  let { onRowMenu } = $$props;
  let { onCellMenu } = $$props;
  let { onNavigate } = $$props;
  function handleHeaderClick() {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onRowMenu(rowId, row));
      }
    };
  }
  function handleCellClick(column, value) {
    return (event) => {
      if (event.button === 2) {
        menuOnContextMenu(event, onCellMenu(rowId, column, value));
      }
      if (event.target instanceof HTMLTableCellElement) {
        if (event.target.firstChild instanceof HTMLInputElement) {
          event.target.firstChild.focus();
          event.preventDefault();
        }
      }
    };
  }
  function handleHoverLink(event) {
    if (!event.ctrlKey && !event.metaKey) {
      return;
    }
    const targetEl = event.target;
    if (targetEl instanceof HTMLDivElement) {
      const file = $app.vault.getAbstractFileByPath(rowId);
      if (file instanceof import_obsidian43.TFile) {
        $app.workspace.trigger("hover-link", {
          event,
          source: "obsidian-projects-table-view",
          hoverParent: targetEl.parentElement,
          targetEl,
          linktext: file.name,
          sourcePath: file.path
        });
      }
    }
  }
  const func7 = (column, value) => {
    onRowChange(rowId, immer_esm_default(row, (draft) => {
      draft[column.field] = value;
      return draft;
    }));
  };
  function navigate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("rowId" in $$props2)
      $$invalidate(0, rowId = $$props2.rowId);
    if ("index" in $$props2)
      $$invalidate(1, index2 = $$props2.index);
    if ("row" in $$props2)
      $$invalidate(2, row = $$props2.row);
    if ("columns" in $$props2)
      $$invalidate(3, columns = $$props2.columns);
    if ("activeCell" in $$props2)
      $$invalidate(4, activeCell = $$props2.activeCell);
    if ("onRowChange" in $$props2)
      $$invalidate(5, onRowChange = $$props2.onRowChange);
    if ("onRowMenu" in $$props2)
      $$invalidate(10, onRowMenu = $$props2.onRowMenu);
    if ("onCellMenu" in $$props2)
      $$invalidate(11, onCellMenu = $$props2.onCellMenu);
    if ("onNavigate" in $$props2)
      $$invalidate(6, onNavigate = $$props2.onNavigate);
  };
  return [
    rowId,
    index2,
    row,
    columns,
    activeCell,
    onRowChange,
    onNavigate,
    handleHeaderClick,
    handleCellClick,
    handleHoverLink,
    onRowMenu,
    onCellMenu,
    func7,
    navigate_handler
  ];
}
var GridRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance92, create_fragment92, safe_not_equal, {
      rowId: 0,
      index: 1,
      row: 2,
      columns: 3,
      activeCell: 4,
      onRowChange: 5,
      onRowMenu: 10,
      onCellMenu: 11,
      onNavigate: 6
    });
  }
};
var GridRow_default = GridRow;

// src/views/Table/components/DataGrid/DataGrid.svelte
function add_css55(target) {
  append_styles(target, "svelte-8irtc3", "div.svelte-8irtc3{display:inline-block}span.svelte-8irtc3{padding:4px;position:sticky;left:0}");
}
function get_each_context15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i2].rowId;
  child_ctx[33] = list[i2].row;
  child_ctx[35] = i2;
  return child_ctx;
}
function create_each_block15(ctx) {
  let gridrow;
  let current;
  function func_4(...args) {
    return ctx[28](ctx[33], ...args);
  }
  function func_5(...args) {
    return ctx[29](ctx[32], ...args);
  }
  gridrow = new GridRow_default({
    props: {
      columns: ctx[9],
      index: ctx[35] + 2,
      rowId: ctx[32],
      row: ctx[33],
      activeCell: ctx[6],
      onRowChange: ctx[4],
      onRowMenu: ctx[27],
      onCellMenu: func_4,
      onNavigate: func_5
    }
  });
  gridrow.$on("navigate", ctx[30]);
  return {
    c() {
      create_component(gridrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridrow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const gridrow_changes = {};
      if (dirty[0] & 512)
        gridrow_changes.columns = ctx[9];
      if (dirty[0] & 256)
        gridrow_changes.rowId = ctx[32];
      if (dirty[0] & 256)
        gridrow_changes.row = ctx[33];
      if (dirty[0] & 64)
        gridrow_changes.activeCell = ctx[6];
      if (dirty[0] & 16)
        gridrow_changes.onRowChange = ctx[4];
      if (dirty[0] & 256)
        gridrow_changes.onCellMenu = func_4;
      if (dirty[0] & 288)
        gridrow_changes.onNavigate = func_5;
      gridrow.$set(gridrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridrow, detaching);
    }
  };
}
function create_if_block28(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "plain",
      $$slots: { default: [create_default_slot_116] },
      $$scope: { ctx }
    }
  });
  button.$on("click", ctx[31]);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & 128 | dirty[1] & 32) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_116(ctx) {
  let icon;
  let t0;
  let t1_value = ctx[7]("components.data-grid.row.add") + "";
  let t1;
  let current;
  icon = new Icon_default({ props: { name: "plus" } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 128) && t1_value !== (t1_value = ctx2[7]("components.data-grid.row.add") + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot28(ctx) {
  let span;
  let span_style_value;
  let current;
  let if_block = !ctx[1] && create_if_block28(ctx);
  return {
    c() {
      var _a, _b;
      span = element("span");
      if (if_block)
        if_block.c();
      attr(span, "style", span_style_value = `width: ${60 + ((_b = (_a = ctx[9][0]) == null ? void 0 : _a.width) != null ? _b : 0)}`);
      attr(span, "class", "svelte-8irtc3");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a, _b;
      if (!ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 512 && span_style_value !== (span_style_value = `width: ${60 + ((_b = (_a = ctx2[9][0]) == null ? void 0 : _a.width) != null ? _b : 0)}`)) {
        attr(span, "style", span_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment93(ctx) {
  let div;
  let gridheader;
  let t0;
  let t1;
  let gridcellgroup;
  let div_aria_colcount_value;
  let div_aria_rowcount_value;
  let current;
  gridheader = new GridHeader_default({
    props: {
      columns: ctx[9],
      onResize: ctx[24],
      onFinalizeResize: ctx[25],
      onColumnMenu: ctx[26]
    }
  });
  let each_value = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block15(get_each_context15(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  gridcellgroup = new GridCellGroup_default({
    props: {
      index: ctx[8].length + 2,
      $$slots: { default: [create_default_slot28] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(gridheader.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(gridcellgroup.$$.fragment);
      attr(div, "role", "grid");
      attr(div, "aria-colcount", div_aria_colcount_value = ctx[9].length + 1);
      attr(div, "aria-rowcount", div_aria_rowcount_value = ctx[8].length + 2);
      attr(div, "class", "svelte-8irtc3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(gridheader, div, null);
      append(div, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div, null);
      }
      append(div, t1);
      mount_component(gridcellgroup, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const gridheader_changes = {};
      if (dirty[0] & 512)
        gridheader_changes.columns = ctx2[9];
      if (dirty[0] & 1)
        gridheader_changes.onResize = ctx2[24];
      if (dirty[0] & 4)
        gridheader_changes.onFinalizeResize = ctx2[25];
      gridheader.$set(gridheader_changes);
      if (dirty[0] & 15216) {
        each_value = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context15(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block15(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t1);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const gridcellgroup_changes = {};
      if (dirty[0] & 256)
        gridcellgroup_changes.index = ctx2[8].length + 2;
      if (dirty[0] & 650 | dirty[1] & 32) {
        gridcellgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcellgroup.$set(gridcellgroup_changes);
      if (!current || dirty[0] & 512 && div_aria_colcount_value !== (div_aria_colcount_value = ctx2[9].length + 1)) {
        attr(div, "aria-colcount", div_aria_colcount_value);
      }
      if (!current || dirty[0] & 256 && div_aria_rowcount_value !== (div_aria_rowcount_value = ctx2[8].length + 2)) {
        attr(div, "aria-rowcount", div_aria_rowcount_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(gridheader.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(gridcellgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(gridcellgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(gridheader);
      destroy_each(each_blocks, detaching);
      destroy_component(gridcellgroup);
    }
  };
}
function instance93($$self, $$props, $$invalidate) {
  let t3;
  let visibleColumns;
  let sortedColumns;
  let sortedRows;
  let $i18n;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(23, $i18n = $$value));
  let { columns } = $$props;
  let { rows } = $$props;
  let { sortModel } = $$props;
  let { readonly } = $$props;
  let { onSortModelChange } = $$props;
  let { onColumnResize } = $$props;
  let { onRowAdd } = $$props;
  let { onRowChange } = $$props;
  let { onRowNavigate } = $$props;
  let { onColumnRename } = $$props;
  let { onColumnDelete } = $$props;
  let { onColumnHide } = $$props;
  let { onRowDelete } = $$props;
  let { onRowEdit } = $$props;
  let activeCell = [3, 3];
  function createColumnMenu(column) {
    const menu = new import_obsidian45.Menu();
    if (column.editable && !readonly) {
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.column.rename")).setIcon("edit").onClick(() => onColumnRename(column.field));
      });
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.column.delete")).setIcon("trash").onClick(() => onColumnDelete(column.field));
      });
      menu.addSeparator();
    }
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.sort.asc")).setIcon("sort-asc").onClick(() => onSortModelChange(column.field, "asc"));
    });
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.sort.desc")).setIcon("sort-desc").onClick(() => onSortModelChange(column.field, "desc"));
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.column.hide")).setIcon("eye-off").onClick(() => {
        onColumnHide(column);
      });
    });
    return menu;
  }
  function createRowMenu(rowId, row) {
    const menu = new import_obsidian45.Menu();
    menu.addItem((item) => {
      item.setTitle(t3("components.data-grid.row.edit")).setIcon("edit").onClick(() => onRowEdit(rowId, row));
    });
    if (!readonly) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.row.delete")).setIcon("trash").onClick(() => onRowDelete(rowId));
      });
    }
    return menu;
  }
  function createCellMenu(rowId, row, column) {
    const menu = new import_obsidian45.Menu();
    if (column.editable) {
      menu.addItem((item) => {
        item.setTitle(t3("components.data-grid.cell.clear")).setIcon("x").onClick(() => {
          onRowChange(rowId, immer_esm_default(row, (draft) => {
            draft[column.field] = null;
            return draft;
          }));
        });
      });
    }
    return menu;
  }
  const clamp = (num, min2, max2) => Math.min(Math.max(num, min2), max2);
  const func7 = (name, width) => {
    $$invalidate(0, columns = columns.map((column) => column.field === name ? __spreadProps(__spreadValues({}, column), { width }) : column));
  };
  const func_13 = (name, width) => {
    onColumnResize(name, width);
  };
  const func_2 = (field) => createColumnMenu(field);
  const func_3 = (rowId, row) => createRowMenu(rowId, row);
  const func_4 = (row, rowId, column) => createCellMenu(rowId, row, column);
  const func_5 = (rowId, event) => onRowNavigate(rowId, event.ctrlKey || event.metaKey);
  const navigate_handler = ({ detail: cell }) => {
    $$invalidate(6, activeCell = [
      clamp(cell[0], 2, sortedColumns.length + 1),
      clamp(cell[1], 4, sortedRows.length + 3)
    ]);
  };
  const click_handler = () => onRowAdd();
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("rows" in $$props2)
      $$invalidate(14, rows = $$props2.rows);
    if ("sortModel" in $$props2)
      $$invalidate(15, sortModel = $$props2.sortModel);
    if ("readonly" in $$props2)
      $$invalidate(1, readonly = $$props2.readonly);
    if ("onSortModelChange" in $$props2)
      $$invalidate(16, onSortModelChange = $$props2.onSortModelChange);
    if ("onColumnResize" in $$props2)
      $$invalidate(2, onColumnResize = $$props2.onColumnResize);
    if ("onRowAdd" in $$props2)
      $$invalidate(3, onRowAdd = $$props2.onRowAdd);
    if ("onRowChange" in $$props2)
      $$invalidate(4, onRowChange = $$props2.onRowChange);
    if ("onRowNavigate" in $$props2)
      $$invalidate(5, onRowNavigate = $$props2.onRowNavigate);
    if ("onColumnRename" in $$props2)
      $$invalidate(17, onColumnRename = $$props2.onColumnRename);
    if ("onColumnDelete" in $$props2)
      $$invalidate(18, onColumnDelete = $$props2.onColumnDelete);
    if ("onColumnHide" in $$props2)
      $$invalidate(19, onColumnHide = $$props2.onColumnHide);
    if ("onRowDelete" in $$props2)
      $$invalidate(20, onRowDelete = $$props2.onRowDelete);
    if ("onRowEdit" in $$props2)
      $$invalidate(21, onRowEdit = $$props2.onRowEdit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8388608) {
      $:
        $$invalidate(7, t3 = $i18n.t);
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(22, visibleColumns = columns.filter((column) => !column.hide));
    }
    if ($$self.$$.dirty[0] & 4194304) {
      $:
        $$invalidate(9, sortedColumns = sortColumns(visibleColumns));
    }
    if ($$self.$$.dirty[0] & 49152) {
      $:
        $$invalidate(8, sortedRows = sortRows(rows, sortModel));
    }
  };
  return [
    columns,
    readonly,
    onColumnResize,
    onRowAdd,
    onRowChange,
    onRowNavigate,
    activeCell,
    t3,
    sortedRows,
    sortedColumns,
    createColumnMenu,
    createRowMenu,
    createCellMenu,
    clamp,
    rows,
    sortModel,
    onSortModelChange,
    onColumnRename,
    onColumnDelete,
    onColumnHide,
    onRowDelete,
    onRowEdit,
    visibleColumns,
    $i18n,
    func7,
    func_13,
    func_2,
    func_3,
    func_4,
    func_5,
    navigate_handler,
    click_handler
  ];
}
var DataGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance93, create_fragment93, safe_not_equal, {
      columns: 0,
      rows: 14,
      sortModel: 15,
      readonly: 1,
      onSortModelChange: 16,
      onColumnResize: 2,
      onRowAdd: 3,
      onRowChange: 4,
      onRowNavigate: 5,
      onColumnRename: 17,
      onColumnDelete: 18,
      onColumnHide: 19,
      onRowDelete: 20,
      onRowEdit: 21
    }, add_css55, [-1, -1]);
  }
};
var DataGrid_default = DataGrid;

// src/views/Table/components/SwitchSelect/SwitchSelect.svelte
function add_css56(target) {
  append_styles(target, "svelte-zdcf2i", "div.svelte-zdcf2i{align-items:center;display:inline-flex;text-align:start}");
}
function get_each_context16(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2].label;
  child_ctx[9] = list[i2].value;
  child_ctx[10] = list[i2].enabled;
  return child_ctx;
}
function create_each_block16(ctx) {
  let menuitem;
  let current;
  function check_handler(...args) {
    return ctx[7](ctx[9], ...args);
  }
  menuitem = new MenuItem_default({
    props: {
      label: ctx[2],
      checked: ctx[10]
    }
  });
  menuitem.$on("check", check_handler);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 1)
        menuitem_changes.label = ctx[2];
      if (dirty & 1)
        menuitem_changes.checked = ctx[10];
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot29(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block16(get_each_context16(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context16(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block16(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment94(ctx) {
  let div;
  let t0;
  let t1;
  let menu;
  let current;
  let mounted;
  let dispose;
  menu = new Menu_default({
    props: {
      anchorEl: ctx[3],
      open: ctx[4],
      onClose: ctx[8],
      $$slots: { default: [create_default_slot29] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      t0 = text(ctx[2]);
      t1 = space();
      create_component(menu.$$.fragment);
      attr(div, "class", "dropdown svelte-zdcf2i");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      ctx[5](div);
      insert(target, t1, anchor);
      mount_component(menu, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t0, ctx2[2]);
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.anchorEl = ctx2[3];
      if (dirty & 16)
        menu_changes.open = ctx2[4];
      if (dirty & 16)
        menu_changes.onClose = ctx2[8];
      if (dirty & 8195) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[5](null);
      if (detaching)
        detach(t1);
      destroy_component(menu, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance94($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { label } = $$props;
  let { onChange } = $$props;
  let ref;
  let isOpen = false;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(3, ref);
    });
  }
  const click_handler = () => $$invalidate(4, isOpen = true);
  const check_handler = (value, { detail: checked }) => onChange(value, checked);
  const func7 = () => $$invalidate(4, isOpen = false);
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
  };
  return [
    items,
    onChange,
    label,
    ref,
    isOpen,
    div_binding,
    click_handler,
    check_handler,
    func7
  ];
}
var SwitchSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance94, create_fragment94, safe_not_equal, { items: 0, label: 2, onChange: 1 }, add_css56);
  }
};
var SwitchSelect_default = SwitchSelect;

// src/views/Table/TableView.svelte
function add_css57(target) {
  append_styles(target, "svelte-15cnmpm", "div.svelte-15cnmpm{overflow:auto}");
}
function create_default_slot_117(ctx) {
  let switchselect;
  let current;
  switchselect = new SwitchSelect_default({
    props: {
      label: ctx[8].t("views.table.hide-fields"),
      items: ctx[7].map(func6),
      onChange: ctx[10]
    }
  });
  return {
    c() {
      create_component(switchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(switchselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switchselect_changes = {};
      if (dirty & 256)
        switchselect_changes.label = ctx2[8].t("views.table.hide-fields");
      if (dirty & 128)
        switchselect_changes.items = ctx2[7].map(func6);
      switchselect.$set(switchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(switchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(switchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(switchselect, detaching);
    }
  };
}
function create_default_slot30(ctx) {
  let p2;
  let t3;
  let horizontalgroup;
  let current;
  horizontalgroup = new HorizontalGroup_default({
    props: {
      $$slots: { default: [create_default_slot_117] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      p2 = element("p");
      t3 = space();
      create_component(horizontalgroup.$$.fragment);
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      mount_component(horizontalgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const horizontalgroup_changes = {};
      if (dirty & 33554816) {
        horizontalgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      horizontalgroup.$set(horizontalgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(horizontalgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(horizontalgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      destroy_component(horizontalgroup, detaching);
    }
  };
}
function create_fragment95(ctx) {
  var _a, _b, _c;
  let toolbar;
  let t3;
  let div;
  let datagrid;
  let current;
  toolbar = new ToolBar_default({
    props: {
      $$slots: { default: [create_default_slot30] },
      $$scope: { ctx }
    }
  });
  datagrid = new DataGrid_default({
    props: {
      columns: ctx[7],
      rows: ctx[6],
      readonly: ctx[2],
      onRowAdd: ctx[16],
      onRowEdit: ctx[17],
      onRowDelete: ctx[18],
      onColumnHide: ctx[19],
      onColumnRename: ctx[20],
      onColumnDelete: ctx[21],
      onRowChange: ctx[22],
      onColumnResize: ctx[11],
      onRowNavigate: ctx[23],
      sortModel: {
        field: (_b = (_a = ctx[0]) == null ? void 0 : _a.sortField) != null ? _b : "name",
        sort: ((_c = ctx[0]) == null ? void 0 : _c.sortAsc) ? "asc" : "desc"
      },
      onSortModelChange: ctx[24]
    }
  });
  return {
    c() {
      create_component(toolbar.$$.fragment);
      t3 = space();
      div = element("div");
      create_component(datagrid.$$.fragment);
      attr(div, "class", "svelte-15cnmpm");
    },
    m(target, anchor) {
      mount_component(toolbar, target, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      mount_component(datagrid, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2;
      const toolbar_changes = {};
      if (dirty & 33554816) {
        toolbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toolbar.$set(toolbar_changes);
      const datagrid_changes = {};
      if (dirty & 128)
        datagrid_changes.columns = ctx2[7];
      if (dirty & 64)
        datagrid_changes.rows = ctx2[6];
      if (dirty & 4)
        datagrid_changes.readonly = ctx2[2];
      if (dirty & 522)
        datagrid_changes.onRowAdd = ctx2[16];
      if (dirty & 552)
        datagrid_changes.onRowEdit = ctx2[17];
      if (dirty & 8)
        datagrid_changes.onRowDelete = ctx2[18];
      if (dirty & 776)
        datagrid_changes.onColumnRename = ctx2[20];
      if (dirty & 8)
        datagrid_changes.onColumnDelete = ctx2[21];
      if (dirty & 40)
        datagrid_changes.onRowChange = ctx2[22];
      if (dirty & 512)
        datagrid_changes.onRowNavigate = ctx2[23];
      if (dirty & 1)
        datagrid_changes.sortModel = {
          field: (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.sortField) != null ? _b2 : "name",
          sort: ((_c2 = ctx2[0]) == null ? void 0 : _c2.sortAsc) ? "asc" : "desc"
        };
      if (dirty & 17)
        datagrid_changes.onSortModelChange = ctx2[24];
      datagrid.$set(datagrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      transition_in(datagrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toolbar.$$.fragment, local);
      transition_out(datagrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toolbar, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_component(datagrid);
    }
  };
}
function defaultWeight(field) {
  switch (field) {
    case "name":
      return 1;
    case "path":
      return 2;
    case "Field":
      return 1;
    default:
      return void 0;
  }
}
var func6 = (column) => ({
  label: column.field,
  value: column.field,
  enabled: !column.hide
});
function instance95($$self, $$props, $$invalidate) {
  let fields;
  let records;
  let fieldConfig;
  let columns;
  let rows;
  let $i18n;
  let $app;
  component_subscribe($$self, i18n, ($$value) => $$invalidate(8, $i18n = $$value));
  component_subscribe($$self, app, ($$value) => $$invalidate(9, $app = $$value));
  var _a;
  let { project } = $$props;
  let { frame } = $$props;
  let { readonly } = $$props;
  let { api: api2 } = $$props;
  let { config } = $$props;
  let { onConfigChange } = $$props;
  function handleVisibilityChange(field, enabled) {
    $$invalidate(0, config = Object.assign(Object.assign({}, config), {
      fieldConfig: Object.assign(Object.assign({}, fieldConfig), {
        [field]: Object.assign(Object.assign({}, fieldConfig[field]), { hide: !enabled })
      })
    }));
    onConfigChange(config);
  }
  function handleWidthChange(field, width) {
    $$invalidate(0, config = Object.assign(Object.assign({}, config), {
      fieldConfig: Object.assign(Object.assign({}, fieldConfig), {
        [field]: Object.assign(Object.assign({}, fieldConfig[field]), { width })
      })
    }));
    onConfigChange(config);
  }
  const func_13 = () => {
    new CreateNoteModal($app, project, (name, templatePath, project2) => {
      api2.addRecord(createDataRecord(name, project2), templatePath);
    }).open();
  };
  const func_2 = (id, values) => {
    new EditNoteModal($app, fields, (record) => {
      api2.updateRecord(record, fields);
    }, { id, values }).open();
  };
  const func_3 = (id) => api2.deleteRecord(id);
  const func_4 = (column) => handleVisibilityChange(column.field, false);
  const func_5 = (field) => {
    new InputDialogModal($app, $i18n.t("views.table.rename-field"), $i18n.t("views.table.rename"), (value) => {
      api2.renameField(field, value);
    }, field).open();
  };
  const func_6 = (field) => api2.deleteField(field);
  const func_7 = (rowId, row) => {
    api2.updateRecord({ id: rowId, values: row }, fields);
  };
  const func_8 = (rowId, openNew) => $app.workspace.openLinkText(rowId, "", openNew);
  const func_9 = (field, sort2) => {
    onConfigChange(__spreadProps(__spreadValues({}, config), {
      sortField: field,
      sortAsc: sort2 === "asc"
    }));
  };
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(1, project = $$props2.project);
    if ("frame" in $$props2)
      $$invalidate(12, frame = $$props2.frame);
    if ("readonly" in $$props2)
      $$invalidate(2, readonly = $$props2.readonly);
    if ("api" in $$props2)
      $$invalidate(3, api2 = $$props2.api);
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("onConfigChange" in $$props2)
      $$invalidate(4, onConfigChange = $$props2.onConfigChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(5, { fields, records } = frame, fields, ($$invalidate(15, records), $$invalidate(12, frame)));
    }
    if ($$self.$$.dirty & 8193) {
      $:
        $$invalidate(14, fieldConfig = $$invalidate(13, _a = config === null || config === void 0 ? void 0 : config.fieldConfig) !== null && _a !== void 0 ? _a : {});
    }
    if ($$self.$$.dirty & 16416) {
      $:
        $$invalidate(7, columns = fields.map((field) => {
          var _a2, _b, _c, _d;
          const colDef = {
            field: field.name,
            type: field.type,
            width: (_b = (_a2 = fieldConfig[field.name]) === null || _a2 === void 0 ? void 0 : _a2.width) !== null && _b !== void 0 ? _b : 180,
            hide: (_d = (_c = fieldConfig[field.name]) === null || _c === void 0 ? void 0 : _c.hide) !== null && _d !== void 0 ? _d : false,
            editable: !field.derived
          };
          const weight = defaultWeight(field.name);
          return weight ? Object.assign(Object.assign({}, colDef), { weight }) : colDef;
        }));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(6, rows = records.map(({ id, values }) => ({ rowId: id, row: values })));
    }
  };
  return [
    config,
    project,
    readonly,
    api2,
    onConfigChange,
    fields,
    rows,
    columns,
    $i18n,
    $app,
    handleVisibilityChange,
    handleWidthChange,
    frame,
    _a,
    fieldConfig,
    records,
    func_13,
    func_2,
    func_3,
    func_4,
    func_5,
    func_6,
    func_7,
    func_8,
    func_9
  ];
}
var TableView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance95, create_fragment95, safe_not_equal, {
      project: 1,
      frame: 12,
      readonly: 2,
      api: 3,
      config: 0,
      onConfigChange: 4
    }, add_css57);
  }
};
var TableView_default = TableView;

// src/views/Table/table-view.ts
var TableView2 = class extends ProjectView {
  getViewType() {
    return "table";
  }
  getDisplayName() {
    return "Table";
  }
  getIcon() {
    return "table";
  }
  onData(result) {
    return __async(this, null, function* () {
      var _a, _b;
      if (!this.view && this.props) {
        this.view = new TableView_default({
          target: this.props.contentEl,
          props: {
            frame: (_a = result.data) != null ? _a : { fields: [], records: [] },
            api: result.viewApi,
            project: result.project,
            readonly: result.readonly,
            config: this.props.config,
            onConfigChange: this.props.saveConfig
          }
        });
      } else {
        (_b = this.view) == null ? void 0 : _b.$set({
          frame: result.data,
          api: result.viewApi,
          project: result.project,
          readonly: result.readonly
        });
      }
    });
  }
  onOpen(props) {
    return __async(this, null, function* () {
      this.props = props;
    });
  }
  onClose() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.view) == null ? void 0 : _a.$destroy();
      this.view = null;
    });
  }
};

// src/view.ts
var VIEW_TYPE_PROJECTS = "obsidian-projects";
var ProjectsView = class extends import_obsidian47.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
    this.navigation = true;
  }
  getViewType() {
    return VIEW_TYPE_PROJECTS;
  }
  getDisplayText() {
    return "Projects";
  }
  getIcon() {
    return "layout";
  }
  onload() {
    return __async(this, null, function* () {
      view.set(this);
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      const views = this.getViews();
      customViews.set(views);
      this.component = new App_default({
        target: this.contentEl
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      if (this.component) {
        this.component.$destroy();
      }
    });
  }
  getViews() {
    const views = {};
    for (const pluginId in this.app.plugins.plugins) {
      if (this.app.plugins.enabledPlugins.has(pluginId)) {
        const plugin2 = this.app.plugins.plugins[pluginId];
        const registerView = plugin2 == null ? void 0 : plugin2.onRegisterProjectView;
        if (registerView) {
          const create = registerView.bind(plugin2);
          const instance96 = create();
          views[instance96.getViewType()] = instance96;
        }
      }
    }
    views["table"] = new TableView2();
    views["board"] = new BoardView2();
    views["calendar"] = new CalendarView2();
    views["gallery"] = new GalleryView2();
    return views;
  }
};

// src/events.ts
var import_obsidian49 = __toModule(require("obsidian"));
var import_obsidian_dataview3 = __toModule(require_lib());
function registerFileEvents(plugin2) {
  if (get_store_value(capabilities).dataview) {
    plugin2.registerEvent(plugin2.app.metadataCache.on("dataview:metadata-change", (type, file, oldPath) => __async(this, null, function* () {
      if (file instanceof import_obsidian49.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          switch (type) {
            case "update":
              dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
              break;
            case "delete":
              dataFrame.deleteRecord(file.path);
              break;
            case "rename":
              dataFrame.deleteRecord(oldPath);
              dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
              break;
          }
        }
      }
    })));
  } else {
    plugin2.registerEvent(plugin2.app.vault.on("create", (file) => __async(this, null, function* () {
      if (file instanceof import_obsidian49.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
        }
      }
    })));
    plugin2.registerEvent(plugin2.app.vault.on("rename", (file, oldPath) => __async(this, null, function* () {
      if (file instanceof import_obsidian49.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.deleteRecord(oldPath);
          dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
        }
      }
    })));
    plugin2.registerEvent(plugin2.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian49.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.deleteRecord(file.path);
        }
      }
    }));
    plugin2.registerEvent(plugin2.app.metadataCache.on("changed", (file) => __async(this, null, function* () {
      if (file instanceof import_obsidian49.TFile) {
        const source = get_store_value(dataSource);
        if (source == null ? void 0 : source.includes(file.path)) {
          dataFrame.merge(yield source.queryOne(file, get_store_value(dataFrame).fields));
        }
      }
    })));
  }
}

// src/main.ts
import_dayjs8.default.extend(import_isoWeek.default);
import_dayjs8.default.extend(import_localizedFormat.default);
var DEFAULT_SETTINGS = {
  projects: []
};
var ProjectsPlugin = class extends import_obsidian50.Plugin {
  onload() {
    return __async(this, null, function* () {
      const t3 = get_store_value(i18n).t;
      this.registerView(VIEW_TYPE_PROJECTS, (leaf) => new ProjectsView(leaf, this));
      this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian50.TFolder) {
          menu.addItem((item) => {
            item.setTitle(t3("menus.project.create.title")).setIcon("folder-plus").onClick(() => __async(this, null, function* () {
              const project = createProject();
              new CreateProjectModal(this.app, t3("modals.project.create.title"), t3("modals.project.create.cta"), settings.addProject, __spreadProps(__spreadValues({}, project), {
                name: file.name,
                path: file.path
              })).open();
            }));
          });
        }
      }));
      this.addCommand({
        id: "show-projects",
        name: t3("commands.show-projects.name"),
        callback: () => {
          this.activateView();
        }
      });
      this.addCommand({
        id: "create-project",
        name: t3("commands.create-project.name"),
        callback: () => {
          new CreateProjectModal(this.app, t3("modals.project.create.title"), t3("modals.project.create.cta"), settings.addProject, createProject()).open();
        }
      });
      this.addCommand({
        id: "create-note",
        name: t3("commands.create-note.name"),
        checkCallback: (checking) => {
          const projectDefinition = get_store_value(settings).projects[0];
          if (projectDefinition) {
            if (!checking) {
              new CreateNoteModal(this.app, projectDefinition, (name, templatePath, project) => __async(this, null, function* () {
                const file = yield get_store_value(api).createNote(createDataRecord(name, project), templatePath);
                this.app.workspace.getLeaf(true).openFile(file);
              })).open();
            }
            return true;
          }
          return false;
        }
      });
      this.addRibbonIcon("layout", "Open projects", () => {
        this.activateView();
      });
      (0, import_obsidian50.addIcon)("text", `<g transform="matrix(1,0,0,1,2,2)"><path d="M20,32L28,32L28,24L41.008,24L30.72,72L20,72L20,80L52,80L52,72L42.992,72L53.28,24L68,24L68,32L76,32L76,16L20,16L20,32Z" /></g>`);
      app.set(this.app);
      plugin.set(this);
      settings.set(migrateAny(yield this.loadData()));
      registerFileEvents(this);
      this.unsubscribeSettings = settings.subscribe((value) => {
        this.saveData(value);
      });
    });
  }
  onunload() {
    return __async(this, null, function* () {
      var _a;
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_PROJECTS);
      (_a = this.unsubscribeSettings) == null ? void 0 : _a.call(this);
    });
  }
  activateView() {
    return __async(this, null, function* () {
      this.app.workspace.revealLeaf(yield this.getOrCreateLeaf());
    });
  }
  getOrCreateLeaf() {
    return __async(this, null, function* () {
      const existingLeaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_PROJECTS);
      if (existingLeaves[0]) {
        return existingLeaves[0];
      }
      const leaf = this.app.workspace.getLeaf(true);
      yield leaf.setViewState({
        type: VIEW_TYPE_PROJECTS
      });
      return leaf;
    });
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
